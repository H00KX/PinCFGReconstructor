#line 1 "analyzer.cpp"
#line 1 "C:\\Pin35\\extras\\crt\\include/msvc_compat.h"























#line 25 "C:\\Pin35\\extras\\crt\\include/msvc_compat.h"
#line 1 "analyzer.cpp"
#line 1 "C:\\Pin35\\source\\include\\pin\\pin.H"








































#line 1 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"









































#line 43 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"


#line 46 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"




#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\cc_used_ia32_w.CVH"

















#line 51 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"






#line 58 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"

















#line 76 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"






#line 83 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"


































#line 118 "c:\\pin35\\source\\include\\pin\\compiler_version_check2.H"
#line 42 "C:\\Pin35\\source\\include\\pin\\pin.H"

#line 1 "c:\\pin35\\source\\include\\pin\\level_base.PLH"











































#line 45 "c:\\pin35\\source\\include\\pin\\level_base.PLH"



#line 49 "c:\\pin35\\source\\include\\pin\\level_base.PLH"



#line 53 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 56 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 59 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 62 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 65 "c:\\pin35\\source\\include\\pin\\level_base.PLH"







#line 73 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 76 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 79 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\string"






















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"

















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"
 








































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_stlport_version.h"
 




























#line 31 "C:\\Pin35\\extras\\stlport\\include\\stl/_stlport_version.h"
#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/user_config.h"






































































































































































































































































































































#line 64 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 70 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 74 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"















#line 90 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"








#line 10 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 22 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 39 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 42 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 46 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"


#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 53 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 57 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 61 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"



#line 69 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"






#line 76 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"




#line 81 "C:\\Pin35\\extras\\stlport\\include\\stl/config/compat.h"
#line 95 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/host.h"




























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/host.h"



























#line 58 "C:\\Pin35\\extras\\stlport\\include\\stl/config/host.h"








































































































































































































































































#line 323 "C:\\Pin35\\extras\\stlport\\include\\stl/config/host.h"













#line 337 "C:\\Pin35\\extras\\stlport\\include\\stl/config/host.h"






#line 98 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_system.h"






















































#line 56 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_system.h"






#line 63 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_system.h"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"































































#line 90 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"









#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"














#line 42 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"





#line 48 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"










#line 59 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 63 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 67 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 71 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"







#line 79 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"











#line 91 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 95 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"






















#line 118 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"






#line 125 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"


#line 128 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"
#line 129 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"














#line 144 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"




#line 149 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"






#line 156 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"
























#line 181 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"





#line 187 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"

#line 189 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"







#line 198 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 202 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"






#line 209 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"





#line 215 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"








#line 224 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"


#line 229 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"






























#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"
















#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"



#line 53 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"




#line 58 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"
#line 59 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"





#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"
#line 66 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"








#line 75 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_detect_dll_or_lib.h"
#line 230 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"









#line 240 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"






#line 247 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"
#line 248 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_auto_link.h"

























































#line 61 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_auto_link.h"

#line 251 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"












#line 264 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_feedback.h"










































#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_feedback.h"
#line 267 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"
#line 268 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_msvc.h"



#line 91 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"



#line 95 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"







#line 103 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"









#line 113 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"




#line 118 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_pin.h"
#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_system.h"








































































































#line 170 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_system.h"





#line 176 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_system.h"

#line 178 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_system.h"
#line 101 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"








#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/stl_confix.h"





























#line 31 "C:\\Pin35\\extras\\stlport\\include\\stl/config/stl_confix.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/config/stl_confix.h"










#line 46 "C:\\Pin35\\extras\\stlport\\include\\stl/config/stl_confix.h"
































#line 79 "C:\\Pin35\\extras\\stlport\\include\\stl/config/stl_confix.h"
















#line 96 "C:\\Pin35\\extras\\stlport\\include\\stl/config/stl_confix.h"

#line 98 "C:\\Pin35\\extras\\stlport\\include\\stl/config/stl_confix.h"
#line 110 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 114 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 118 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 122 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 126 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 130 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 134 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 139 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 143 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 145 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 150 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 155 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 159 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 164 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



















#line 184 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"







#line 192 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 195 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 200 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 204 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"
#line 205 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 209 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 215 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 219 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 221 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_native_headers.h"
 

















#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_native_headers.h"






#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_native_headers.h"







#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_native_headers.h"







#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_native_headers.h"







#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_native_headers.h"
#line 225 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"
#line 226 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"







#line 234 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 241 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 243 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 250 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 254 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 258 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 261 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 263 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 265 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 269 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 273 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 277 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 283 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 287 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 291 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 296 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 300 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 307 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 312 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 319 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 324 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 327 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 330 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 334 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 339 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 342 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 344 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 348 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 351 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"








#line 360 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"









#line 370 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 374 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 379 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 384 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 389 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 394 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"












#line 407 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 414 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 418 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



namespace std { }
namespace __std_alias = std;




#line 428 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 430 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"









#line 440 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 445 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 447 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"
#line 448 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 452 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"







#line 460 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"









































#line 502 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 504 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"









#line 514 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 519 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 524 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"












#line 537 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





namespace stlport = std;



namespace _STL = std;























#line 571 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 578 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 580 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 584 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"











#line 596 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 600 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 604 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 606 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 612 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 618 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 624 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 629 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 632 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 636 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 643 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 648 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 652 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 654 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 660 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 666 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




















#line 687 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 692 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 695 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 697 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"
#line 698 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 705 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 709 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"







#line 717 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 724 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 728 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 732 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"















#line 748 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"













































#line 794 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 796 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 800 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 802 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 809 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 811 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 815 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 819 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"























#line 843 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 848 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 854 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"









#line 864 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


#line 867 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"







#line 876 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 878 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






















#line 901 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 903 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 909 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"


















#line 928 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






















#line 951 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 955 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 957 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 961 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"























#line 985 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 990 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 996 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 998 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 1002 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 1008 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 1014 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"






#line 1021 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"




#line 1026 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"







#line 1034 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"





#line 1041 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"









#line 1051 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"



#line 1055 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"







#line 1063 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"











#line 1075 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"










#line 1086 "C:\\Pin35\\extras\\stlport\\include\\stl/config/features.h"

#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"




#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 




#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"
























#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"









































































































































#line 165 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"

#line 167 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"















































































































































































































































































#line 439 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"


#line 442 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"





















#line 464 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"



#line 468 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"

#line 470 "C:\\Pin35\\extras\\stlport\\include\\stl/debug/_debug.h"




#line 18 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 24 "C:\\Pin35\\extras\\stlport\\include\\string"

#line 26 "C:\\Pin35\\extras\\stlport\\include\\string"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"






















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"






























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstddef.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstddef.h"







#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstddef.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"












#line 35 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/errno.h"






























#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"













































#line 47 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


#line 50 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


#line 53 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


#line 56 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



















#line 76 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs_elf.h"












































#line 46 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs_elf.h"






#line 53 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs_elf.h"




#line 58 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs_elf.h"
    
#line 60 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs_elf.h"
#line 78 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"









#line 88 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"





















#line 110 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"






#line 117 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"




































#line 154 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"








#line 163 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


















#line 182 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"














#line 197 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
#line 198 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"





#line 204 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 208 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 210 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"





#line 216 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 218 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"





#line 224 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 228 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 232 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 236 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 240 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 242 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 244 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
















#line 261 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


#line 264 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
#line 265 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"








#line 274 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 276 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 278 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
#line 279 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"






#line 286 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"








#line 295 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 297 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
































#line 330 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


#line 333 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"





#line 339 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 343 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 347 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 349 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 353 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 355 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"




#line 360 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


#line 363 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"































#line 395 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



#line 399 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"


























#line 426 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"





#line 432 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
























#line 457 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"









































#line 499 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"




#line 504 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"




#line 509 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
#line 510 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"






#line 517 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"











#line 1 "C:\\Pin35\\extras\\crt\\include\\android/api-level.h"





































#line 39 "C:\\Pin35\\extras\\crt\\include\\android/api-level.h"
#line 529 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"




#line 534 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"

#line 536 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"




















#line 557 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"










#line 568 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"











#line 580 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"
#line 32 "C:\\Pin35\\extras\\crt\\include/errno.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/errno.h"


















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/errno.h"


















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/errno.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/errno-base.h"































































#line 65 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/errno-base.h"
#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/errno.h"




























































































































#line 147 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/errno.h"
#line 20 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/errno.h"
#line 20 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/errno.h"
#line 33 "C:\\Pin35\\extras\\crt\\include/errno.h"

extern "C" {






#line 42 "C:\\Pin35\\extras\\crt\\include/errno.h"


extern volatile int* __errno(void) ;




}

#line 52 "C:\\Pin35\\extras\\crt\\include/errno.h"
#line 36 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 37 "c:\\pin35\\extras\\stlport\\include\\errno.h"




#line 42 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 43 "c:\\pin35\\extras\\stlport\\include\\errno.h"













#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"


































#line 40 "C:\\Pin35\\extras\\crt\\include/stddef.h"



#line 44 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 46 "C:\\Pin35\\extras\\crt\\include/stddef.h"




typedef __int32 ptrdiff_t;
#line 52 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 54 "C:\\Pin35\\extras\\crt\\include/stddef.h"






#line 61 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 62 "C:\\Pin35\\extras\\crt\\include/stddef.h"






typedef unsigned int size_t;
#line 70 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 71 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 73 "C:\\Pin35\\extras\\crt\\include/stddef.h"









#line 84 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 85 "C:\\Pin35\\extras\\crt\\include/stddef.h"



#line 89 "C:\\Pin35\\extras\\crt\\include/stddef.h"












#line 102 "C:\\Pin35\\extras\\crt\\include/stddef.h"






#line 109 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 111 "C:\\Pin35\\extras\\crt\\include/stddef.h"


#line 114 "C:\\Pin35\\extras\\crt\\include/stddef.h"


namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#line 119 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 120 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 122 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















#line 140 "C:\\Pin35\\extras\\crt\\include/stddef.h"








#line 149 "C:\\Pin35\\extras\\crt\\include/stddef.h"









#line 159 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 160 "C:\\Pin35\\extras\\crt\\include/stddef.h"









#line 170 "C:\\Pin35\\extras\\crt\\include/stddef.h"



extern "C" {
#line 175 "C:\\Pin35\\extras\\crt\\include/stddef.h"
int __cdecl _resetstkoflw(void);

}
#line 179 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstddef.h"


namespace std {
using ::ptrdiff_t;
using ::size_t;
}
#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstddef.h"

#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstddef.h"
#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
#line 33 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"

#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"







#line 38 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"







#line 46 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"



#line 50 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdlib.h"






























#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 32 "C:\\Pin35\\extras\\crt\\include/stdlib.h"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 34 "C:\\Pin35\\extras\\crt\\include/stdlib.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\string.h"





























#line 31 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 39 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/string.h"































#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 33 "C:\\Pin35\\extras\\crt\\include/string.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 34 "C:\\Pin35\\extras\\crt\\include/string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\malloc.h"
























#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 26 "C:\\Pin35\\extras\\crt\\include\\malloc.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 27 "C:\\Pin35\\extras\\crt\\include\\malloc.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


























#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


#line 35 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdio.h"
















































#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 50 "C:\\Pin35\\extras\\crt\\include/stdio.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"






























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 32 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\stdint.h"































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 33 "C:\\Pin35\\extras\\crt\\include\\stdint.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\machine/wchar_limits.h"







































#line 41 "C:\\Pin35\\extras\\crt\\include\\machine/wchar_limits.h"

#line 43 "C:\\Pin35\\extras\\crt\\include\\machine/wchar_limits.h"
#line 34 "C:\\Pin35\\extras\\crt\\include\\stdint.h"

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;



typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;






















#line 71 "C:\\Pin35\\extras\\crt\\include\\stdint.h"




#line 76 "C:\\Pin35\\extras\\crt\\include\\stdint.h"
typedef int32_t __intptr_t;
typedef uint32_t __uintptr_t;
#line 79 "C:\\Pin35\\extras\\crt\\include\\stdint.h"

typedef __int8_t      int8_t;
typedef __uint8_t     uint8_t;

typedef __int16_t     int16_t;
typedef __uint16_t    uint16_t;



typedef __intptr_t    intptr_t;
#line 90 "C:\\Pin35\\extras\\crt\\include\\stdint.h"



typedef __uintptr_t   uintptr_t;
#line 95 "C:\\Pin35\\extras\\crt\\include\\stdint.h"

typedef int8_t        int_least8_t;
typedef uint8_t       uint_least8_t;

typedef int16_t       int_least16_t;
typedef uint16_t      uint_least16_t;

typedef int32_t       int_least32_t;
typedef uint32_t      uint_least32_t;

typedef int64_t       int_least64_t;
typedef uint64_t      uint_least64_t;

typedef int8_t        int_fast8_t;
typedef uint8_t       uint_fast8_t;

typedef int64_t       int_fast64_t;
typedef uint64_t      uint_fast64_t;






#line 120 "C:\\Pin35\\extras\\crt\\include\\stdint.h"
typedef int32_t       int_fast16_t;
typedef uint32_t      uint_fast16_t;
typedef int32_t       int_fast32_t;
typedef uint32_t      uint_fast32_t;
#line 125 "C:\\Pin35\\extras\\crt\\include\\stdint.h"

typedef uint64_t      uintmax_t;
typedef int64_t       intmax_t;









































#line 170 "C:\\Pin35\\extras\\crt\\include\\stdint.h"





#line 176 "C:\\Pin35\\extras\\crt\\include\\stdint.h"























































#line 232 "C:\\Pin35\\extras\\crt\\include\\stdint.h"


#line 235 "C:\\Pin35\\extras\\crt\\include\\stdint.h"








#line 244 "C:\\Pin35\\extras\\crt\\include\\stdint.h"






#line 251 "C:\\Pin35\\extras\\crt\\include\\stdint.h"

#line 253 "C:\\Pin35\\extras\\crt\\include\\stdint.h"
#line 33 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 34 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"

#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/types.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/types.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/types.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/int-ll64.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/bitsperlong.h"

























#line 27 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/bitsperlong.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/bitsperlong.h"
























#line 26 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/bitsperlong.h"
#line 28 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/bitsperlong.h"

#line 30 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/bitsperlong.h"
#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/int-ll64.h"


typedef signed char __s8;
typedef unsigned char __u8;
typedef signed short __s16;
typedef unsigned short __u16;

typedef signed int __s32;
typedef unsigned int __u32;





typedef signed long long __s64;
typedef unsigned long long __u64;

#line 40 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/int-ll64.h"
#line 41 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/int-ll64.h"
#line 42 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/int-ll64.h"
#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/types.h"
#line 23 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/types.h"

#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/types.h"
#line 23 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/types.h"

#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/types.h"


#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/posix_types.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/stddef.h"


















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/compiler.h"

















#line 19 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/compiler.h"
#line 20 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/stddef.h"
#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/posix_types.h"



typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;

typedef void (*__kernel_sighandler_t)(int);
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/posix_types.h"



















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/posix_types_32.h"




















typedef unsigned short __kernel_mode_t;


typedef unsigned short __kernel_ipc_pid_t;

typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;


typedef unsigned short __kernel_old_dev_t;

#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/bitsperlong.h"





























#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"





#line 28 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
#line 31 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"
#line 32 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"


typedef __kernel_ulong_t __kernel_ino_t;
#line 36 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"









typedef int __kernel_pid_t;
#line 47 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"











typedef __kernel_long_t __kernel_suseconds_t;
#line 60 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"

typedef int __kernel_daddr_t;

#line 64 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"

typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;

#line 69 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"

typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;

#line 74 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"






typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;

typedef int __kernel_ptrdiff_t;





#line 90 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"
#line 91 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"


typedef struct {
 int val[2];
} __kernel_fsid_t;
#line 97 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"

typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;

typedef unsigned short __kernel_gid16_t;
#line 110 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-generic/posix_types.h"
#line 33 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/posix_types_32.h"

#line 35 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/posix_types_32.h"
#line 21 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/posix_types.h"





#line 27 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\asm-x86\\asm/posix_types.h"
#line 33 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/posix_types.h"

#line 35 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/posix_types.h"
#line 25 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/types.h"


typedef __u16  __le16;

typedef __u16  __be16;
typedef __u32  __le32;
typedef __u32  __be32;
typedef __u64  __le64;

typedef __u64  __be64;
typedef __u16  __sum16;
typedef __u32  __wsum;




#line 42 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/types.h"
#line 43 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/types.h"

#line 36 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/posix_types.h"


































#line 37 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"


typedef __kernel_gid32_t __gid_t;
typedef __gid_t gid_t;
typedef __kernel_uid32_t __uid_t;
typedef __uid_t uid_t;
typedef __kernel_pid_t __pid_t;
typedef __pid_t pid_t;
typedef uint32_t __id_t;
typedef __id_t id_t;

typedef unsigned long blkcnt_t;
typedef unsigned long blksize_t;
typedef __kernel_caddr_t caddr_t;
typedef __kernel_clock_t clock_t;

typedef __kernel_clockid_t __clockid_t;
typedef __clockid_t clockid_t;

typedef __kernel_daddr_t daddr_t;
typedef unsigned long fsblkcnt_t;
typedef unsigned long fsfilcnt_t;

typedef __kernel_mode_t __mode_t;
typedef __mode_t mode_t;

typedef __kernel_key_t __key_t;
typedef __key_t key_t;

typedef __kernel_ino_t __ino_t;
typedef __ino_t ino_t;

typedef uint32_t __nlink_t;
typedef __nlink_t nlink_t;

typedef void* __timer_t;
typedef __timer_t timer_t;

typedef __kernel_suseconds_t __suseconds_t;
typedef __suseconds_t suseconds_t;


typedef uint32_t __useconds_t;
typedef __useconds_t useconds_t;



typedef uint32_t dev_t;


#line 88 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"


typedef __kernel_time_t __time_t;
typedef __time_t time_t;





#line 98 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"

typedef __kernel_off_t off_t;
typedef __kernel_loff_t loff_t;
typedef loff_t off64_t;






#line 109 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"













#line 123 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"



typedef int32_t __socklen_t;



#line 131 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"
typedef __socklen_t socklen_t;













typedef __kernel_ssize_t ssize_t;
#line 147 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"

typedef unsigned int        uint_t;
typedef unsigned int        uint;


#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/sysmacros.h"



































static inline int major(dev_t _dev)
{
  return (_dev >> 8) & 0xfff;
}

static inline int minor(dev_t _dev)
{
  return (_dev & 0xff) | ((_dev >> 12) & 0xfff00);
}

static inline dev_t makedev(int __ma, int __mi)
{
  return ((__ma & 0xfff) << 8) | (__mi & 0xff) | ((__mi & 0xfff00) << 12);
}

#line 52 "C:\\Pin35\\extras\\crt\\include\\sys/sysmacros.h"

#line 153 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"



typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;

typedef uint32_t       u_int32_t;
typedef uint16_t       u_int16_t;
typedef uint8_t        u_int8_t;
typedef uint64_t       u_int64_t;
#line 166 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"









#line 176 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"
#line 51 "C:\\Pin35\\extras\\crt\\include/stdio.h"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"

#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdarg.h"






#line 1 "C:\\Pin35\\extras\\crt\\include\\stdint.h"




























































































































































































































































#line 8 "C:\\Pin35\\extras\\crt\\include/stdarg.h"


typedef char*  va_list;

#line 13 "C:\\Pin35\\extras\\crt\\include/stdarg.h"

typedef va_list __va_list;
#line 16 "C:\\Pin35\\extras\\crt\\include/stdarg.h"


extern "C" {
#line 20 "C:\\Pin35\\extras\\crt\\include/stdarg.h"

extern void __cdecl __va_start(va_list *, ...);

}
#line 25 "C:\\Pin35\\extras\\crt\\include/stdarg.h"















#line 41 "C:\\Pin35\\extras\\crt\\include/stdarg.h"




#line 46 "C:\\Pin35\\extras\\crt\\include/stdarg.h"


#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"








#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 48 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 53 "C:\\Pin35\\extras\\crt\\include/stdio.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 54 "C:\\Pin35\\extras\\crt\\include/stdio.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\types.h"



















#line 21 "c:\\pin35\\extras\\crt\\include\\types.h"





typedef bool BOOL_T;


#line 30 "c:\\pin35\\extras\\crt\\include\\types.h"



#line 34 "c:\\pin35\\extras\\crt\\include\\types.h"


#line 37 "c:\\pin35\\extras\\crt\\include\\types.h"


typedef void VOID;
#line 41 "c:\\pin35\\extras\\crt\\include\\types.h"



#line 45 "c:\\pin35\\extras\\crt\\include\\types.h"

typedef char            CHAR;
typedef unsigned int    UINT;
typedef int             INT;
typedef double          FLT64;
typedef float           FLT32;



enum TRI
{
    TRI_YES,
    TRI_NO,
    TRI_MAYBE
};


typedef unsigned __int8 UINT8 ;
typedef unsigned __int16 UINT16;
typedef unsigned __int32 UINT32;
typedef unsigned __int64 UINT64;
typedef signed __int8 INT8 ;
typedef signed __int16 INT16;
typedef signed __int32 INT32;
typedef signed __int64 INT64;





typedef __int32 INT32;










#line 87 "c:\\pin35\\extras\\crt\\include\\types.h"
typedef UINT64  ANYADDR;












typedef UINT32 ADDRINT;

typedef INT32 ADDRDELTA;














#line 118 "c:\\pin35\\extras\\crt\\include\\types.h"

typedef ADDRINT    USIZE;


typedef UINT32 VOIDINT;
typedef UINT32 PTRINT;









#line 134 "c:\\pin35\\extras\\crt\\include\\types.h"

typedef UINT64 REG_CLASS_BITS;
typedef UINT32 REG_SUBCLASS_BITS;









#line 147 "c:\\pin35\\extras\\crt\\include\\types.h"






typedef ADDRINT NATIVE_FD;





typedef UINT32 NATIVE_PID;





typedef UINT32 NATIVE_TID;

typedef ADDRINT NATIVE_UID;




typedef ADDRINT OS_EVENT;
#line 174 "c:\\pin35\\extras\\crt\\include\\types.h"
















#line 191 "c:\\pin35\\extras\\crt\\include\\types.h"

#line 193 "c:\\pin35\\extras\\crt\\include\\types.h"
#line 55 "C:\\Pin35\\extras\\crt\\include/stdio.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"


































#line 40 "C:\\Pin35\\extras\\crt\\include/stddef.h"



#line 44 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 46 "C:\\Pin35\\extras\\crt\\include/stddef.h"







#line 54 "C:\\Pin35\\extras\\crt\\include/stddef.h"


















#line 73 "C:\\Pin35\\extras\\crt\\include/stddef.h"









#line 84 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 85 "C:\\Pin35\\extras\\crt\\include/stddef.h"
















#line 102 "C:\\Pin35\\extras\\crt\\include/stddef.h"






#line 109 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 111 "C:\\Pin35\\extras\\crt\\include/stddef.h"


#line 114 "C:\\Pin35\\extras\\crt\\include/stddef.h"


namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#line 119 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 120 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 122 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















#line 140 "C:\\Pin35\\extras\\crt\\include/stddef.h"








#line 149 "C:\\Pin35\\extras\\crt\\include/stddef.h"









#line 159 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 160 "C:\\Pin35\\extras\\crt\\include/stddef.h"









#line 170 "C:\\Pin35\\extras\\crt\\include/stddef.h"



extern "C" {
#line 175 "C:\\Pin35\\extras\\crt\\include/stddef.h"
int __cdecl _resetstkoflw(void);

}
#line 179 "C:\\Pin35\\extras\\crt\\include/stddef.h"

#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 58 "C:\\Pin35\\extras\\crt\\include/stdio.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis.h"







extern "C" {
#line 10 "c:\\pin35\\extras\\crt\\include\\os-apis.h"











#line 22 "c:\\pin35\\extras\\crt\\include\\os-apis.h"

#line 1 "c:\\pin35\\extras\\crt\\include\\types.h"
































































































































































































#line 24 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\types_marker.h"




























#line 30 "c:\\pin35\\extras\\crt\\include\\types_marker.h"
















#line 47 "c:\\pin35\\extras\\crt\\include\\types_marker.h"

#pragma deprecated("SECTION")


#line 52 "c:\\pin35\\extras\\crt\\include\\types_marker.h"












































#line 97 "c:\\pin35\\extras\\crt\\include\\types_marker.h"










#line 108 "c:\\pin35\\extras\\crt\\include\\types_marker.h"



















#line 128 "c:\\pin35\\extras\\crt\\include\\types_marker.h"







#line 136 "c:\\pin35\\extras\\crt\\include\\types_marker.h"




#line 141 "c:\\pin35\\extras\\crt\\include\\types_marker.h"







#line 149 "c:\\pin35\\extras\\crt\\include\\types_marker.h"
#line 150 "c:\\pin35\\extras\\crt\\include\\types_marker.h"











#line 162 "c:\\pin35\\extras\\crt\\include\\types_marker.h"


#line 165 "c:\\pin35\\extras\\crt\\include\\types_marker.h"




#line 170 "c:\\pin35\\extras\\crt\\include\\types_marker.h"
#line 171 "c:\\pin35\\extras\\crt\\include\\types_marker.h"

















#line 189 "c:\\pin35\\extras\\crt\\include\\types_marker.h"


#pragma section(".CRT$XIU",read)

















#line 210 "c:\\pin35\\extras\\crt\\include\\types_marker.h"





#line 216 "c:\\pin35\\extras\\crt\\include\\types_marker.h"





#line 222 "c:\\pin35\\extras\\crt\\include\\types_marker.h"






#line 229 "c:\\pin35\\extras\\crt\\include\\types_marker.h"























#line 253 "c:\\pin35\\extras\\crt\\include\\types_marker.h"

#line 255 "c:\\pin35\\extras\\crt\\include\\types_marker.h"
#line 25 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/os_return_codes.h"














typedef enum
{
    OS_RETURN_CODE_NO_ERROR=0,
    OS_RETURN_CODE_INVALID_ARGS,
    OS_RETURN_CODE_MEMORY_MAP_FAILED,
    OS_RETURN_CODE_MEMORY_FREE_FAILED,
    OS_RETURN_CODE_QUERY_FAILED,
    OS_RETURN_CODE_FLUSH_ICACHE_FAILED,
    OS_RETURN_CODE_MEMORY_PROTECT_FAILED,
    OS_RETURN_CODE_MEMORY_INFO_FAILED,
    OS_RETURN_CODE_FILE_OPERATION_FAILED,
    OS_RETURN_CODE_FILE_OPEN_FAILED,
    OS_RETURN_CODE_FILE_WRITE_FAILED,
    OS_RETURN_CODE_FILE_READ_FAILED,
    OS_RETURN_CODE_FILE_SEEK_FAILED,
    OS_RETURN_CODE_FILE_CLOSE_FAILED,
    OS_RETURN_CODE_FILE_DELETE_FAILED,
    OS_RETURN_CODE_FILE_FLUSH_FAILED,
    OS_RETURN_CODE_FILE_QUERY_FAILED,
    OS_RETURN_CODE_THREAD_CREATE_FAILED,
    OS_RETURN_CODE_THREAD_EXIT_FAILED,
    OS_RETURN_CODE_THREAD_SUSPEND_FAILED,
    OS_RETURN_CODE_THREAD_RESUME_FAILED,
    OS_RETURN_CODE_THREAD_SLEEP_FAILED,
    OS_RETURN_CODE_THREAD_QUERY_FAILED,
    OS_RETURN_CODE_THREAD_EXCEPTION_FAILED,
    OS_RETURN_CODE_PROCESS_QUERY_FAILED,
    OS_RETURN_CODE_PROCESS_UPDATE_FAILED,
    OS_RETURN_CODE_TIME_QUERY_FAILED,
    OS_RETURN_CODE_BUFFER_TOO_SHORT,
    OS_RETURN_CODE_INTERRUPTED,
    OS_RETURN_CODE_FILE_EXIST,
    OS_RETURN_CODE_NOT_IMPLEMENTED_YET,
    OS_RETURN_CODE_EXCEED_LIMIT_OF_OPEN_OBJECTS,
    OS_RETURN_CODE_NO_MEMORY,
    OS_RETURN_CODE_PROCESS_CREATION_FAILED,
    OS_RETURN_CODE_PROCESS_WAIT_FAILED,
    OS_RETURN_CODE_NOT_IMPLEMENTED,
    OS_RETURN_CODE_RPC_FAILED,
    OS_RETURN_CODE_BAD_FILE_DESCRIPTOR
} OS_RETURN_CODE_GENERIC;




typedef struct _OS_RETURN_CODE
{
    OS_RETURN_CODE_GENERIC generic_err; 
    int os_specific_err;                
} OS_RETURN_CODE;

typedef struct _OS_RETURN_CODE_POSIX
{
    ADDRINT function_return_value;
    ADDRINT return_errno;
} OS_RETURN_CODE_POSIX;



extern "C++" {

inline bool operator==(const OS_RETURN_CODE_GENERIC& generic, const OS_RETURN_CODE& code)
{
    return code.generic_err == generic;
}

inline bool operator!=(const OS_RETURN_CODE_GENERIC& generic, const OS_RETURN_CODE& code)
{
    return code.generic_err != generic;
}

}
#line 88 "c:\\pin35\\extras\\crt\\include\\os-apis/os_return_codes.h"


























#line 115 "c:\\pin35\\extras\\crt\\include\\os-apis/os_return_codes.h"
#line 26 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/memory.h"














typedef enum
{
    OS_PAGE_PROTECTION_TYPE_NOACCESS            = 0,
    OS_PAGE_PROTECTION_TYPE_READ                = (1<<0),
    OS_PAGE_PROTECTION_TYPE_WRITE               = (1<<1),
    OS_PAGE_PROTECTION_TYPE_EXECUTE             = (1<<2),
    OS_PAGE_PROTECTION_TYPE_GUARD               = (1<<3)
} OS_PAGE_PROTECTION_TYPE;





typedef struct
{
    VOID *BaseAddress;                  
    USIZE MapSize;                      
    UINT Shared;                        
    OS_PAGE_PROTECTION_TYPE Protection; 
    UINT Type;                          
} OS_MEMORY_AT_ADDR_INFORMATION;





typedef enum
{
    OS_MEMORY_FLAGS_PRIVATE                     = 0,      
    OS_MEMORY_FLAGS_FIXED_ADDRESS               = (1<<0), 
    OS_MEMORY_FLAGS_STACK                       = (1<<1), 
    OS_MEMORY_FLAGS_SHARED                      = (1<<3)  
} OS_MEMORY_FLAGS;

































OS_RETURN_CODE OS_AllocateMemory(NATIVE_PID processId, UINT protectionType,
                                 USIZE size, OS_MEMORY_FLAGS flags, VOID **base);




































OS_RETURN_CODE OS_MapFileToMemory(NATIVE_PID processId, UINT protectionType,
        USIZE size, OS_MEMORY_FLAGS flags, NATIVE_FD fd, UINT64 offset, VOID **base);

























OS_RETURN_CODE OS_FreeMemory(NATIVE_PID processId, VOID *base, USIZE size);














OS_RETURN_CODE OS_GetPageSize(USIZE *size);































OS_RETURN_CODE OS_QueryMemory(NATIVE_PID processId, VOID *memoryAddr, OS_MEMORY_AT_ADDR_INFORMATION *info);




























OS_RETURN_CODE OS_ProtectMemory(NATIVE_PID processId, VOID *base, USIZE size, UINT newProtectionType);

#line 225 "c:\\pin35\\extras\\crt\\include\\os-apis/memory.h"
#line 27 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/file.h"











#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"















































































































































































#line 13 "c:\\pin35\\extras\\crt\\include\\os-apis/file.h"





typedef enum
{
    
    
    OS_FILE_OPEN_TYPE_READ                            = (1<<0),  
    OS_FILE_OPEN_TYPE_WRITE                           = (1<<1),  
    OS_FILE_OPEN_TYPE_EXECUTE                         = (1<<2),  
    OS_FILE_OPEN_TYPE_APPEND                          = (1<<3),  
    OS_FILE_OPEN_TYPE_TRUNCATE                        = (1<<4),  
    OS_FILE_OPEN_TYPE_CREATE                          = (1<<5),  
    OS_FILE_OPEN_TYPE_CREATE_EXCL                     = (1<<6),  
    OS_FILE_OPEN_TYPE_DELETE                          = (1<<7),  
    OS_FILE_OPEN_TYPE_CLOSE_ON_EXEC                   = (1<<8)   
} OS_FILE_OPEN_TYPE;





typedef enum
{
    OS_FILE_PERMISSION_TYPE_READ                 = (1<<0),
    OS_FILE_PERMISSION_TYPE_WRITE                = (1<<1),
    OS_FILE_PERMISSION_TYPE_EXECUTE              = (1<<2)
} OS_FILE_PERMISSION_TYPE;








typedef enum
{
    
    OS_FILE_SEEK_SET                 = 0,

    
    OS_FILE_SEEK_CUR                 = (1<<0),

    
    OS_FILE_SEEK_END                 = (1<<1)
} OS_FILE_SEEK_TYPE;




typedef struct _OS_FILE_UNIQUE_ID
{
    UINT64 _reserved[2];  
} OS_FILE_UNIQUE_ID;





typedef enum
{
    OS_FILE_ATTRIBUTES_NONE                            = 0,
    OS_FILE_ATTRIBUTES_EXIST                           = (1<<0), 
    OS_FILE_ATTRIBUTES_REGULAR                         = (1<<1), 
    OS_FILE_ATTRIBUTES_DIRECTORY                       = (1<<2), 
    OS_FILE_ATTRIBUTES_SYMLINK                         = (1<<3)  
} OS_FILE_ATTRIBUTES;























OS_RETURN_CODE OS_OpenFD(const CHAR* path, INT flags, INT mode, NATIVE_FD* fd);



















OS_RETURN_CODE OS_WriteFD(NATIVE_FD fd, const VOID *buffer, USIZE *count);




















OS_RETURN_CODE OS_ReadFD(NATIVE_FD fd, USIZE *count, VOID *buffer);





















OS_RETURN_CODE OS_SeekFD(NATIVE_FD fd, INT whence, INT64 *offset);














OS_RETURN_CODE OS_CloseFD(NATIVE_FD fd);













OS_RETURN_CODE OS_DeleteFile(const CHAR* name);













OS_RETURN_CODE OS_FlushFD(NATIVE_FD fd);















OS_RETURN_CODE OS_GetFDAttributes(NATIVE_FD fd, OS_FILE_ATTRIBUTES *attr);


















OS_RETURN_CODE OS_FilePermissionsFD(NATIVE_FD fd, OS_FILE_PERMISSION_TYPE *permissions);














OS_RETURN_CODE OS_FileSizeFD(NATIVE_FD fd, USIZE* size);














OS_RETURN_CODE OS_Cwd(CHAR* cwd, INT len);
















OS_RETURN_CODE OS_Chdir(const CHAR* dir, CHAR* cwd, INT len);














OS_RETURN_CODE OS_OpenDirFD(const CHAR* name, NATIVE_FD* fd);















OS_RETURN_CODE OS_MkDir(const CHAR* name, INT mode);













OS_RETURN_CODE OS_DeleteDirectory(const CHAR* name);






















OS_RETURN_CODE OS_IsConsoleFD(NATIVE_FD fd, INT* isConsole);




















OS_RETURN_CODE OS_ReadDirectoryFD(NATIVE_FD fd, USIZE* count, VOID* buffer);















OS_RETURN_CODE OS_GetFDAccessMode(NATIVE_FD fd, OS_FILE_OPEN_TYPE* mode);

















OS_RETURN_CODE OS_ReadLink(const CHAR* path, CHAR* buf, USIZE* size);














OS_RETURN_CODE OS_GetFileAttributes(const CHAR* path, OS_FILE_ATTRIBUTES* attr);














OS_RETURN_CODE OS_RenameFile(const CHAR* oldPath, const CHAR* newPath);
















OS_RETURN_CODE OS_FileUniqueID(NATIVE_FD fd, OS_FILE_UNIQUE_ID* uniqueId);


















OS_RETURN_CODE OS_DuplicateFD(NATIVE_FD fd, BOOL_T dupCloseOnExec, NATIVE_FD* outFd);
















OS_RETURN_CODE OS_Ftruncate(NATIVE_FD fd, INT64 length);












void OS_ReportFileOpen(NATIVE_FD fd);













void OS_ReportFileClose(NATIVE_FD fd);

















NATIVE_FD OS_GetLowestFileDescriptorToUse();














void OS_RelocateAndReportFileOpen(NATIVE_FD* fd);











BOOL_T OS_WasFileReportedOpen(NATIVE_FD fd);




#line 578 "c:\\pin35\\extras\\crt\\include\\os-apis/file.h"
#line 28 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/threads.h"


































OS_RETURN_CODE OS_CreateThread(VOID (*ThreadMainFunction)(VOID*), VOID *ThreadParam,
                                     VOID* stackBottom, ADDRINT stackSize, NATIVE_TID* td);














OS_RETURN_CODE OS_ExitThread(NATIVE_TID td);
















OS_RETURN_CODE OS_ThreadExitAndClear(void* stackAddr, ADDRINT stackSize, INT32* dwordToReset);














OS_RETURN_CODE OS_SuspendThread(NATIVE_TID td);














OS_RETURN_CODE OS_ResumeThread(NATIVE_TID td);














OS_RETURN_CODE OS_Sleep(INT interval);














OS_RETURN_CODE OS_GetTid(NATIVE_TID* id);












OS_RETURN_CODE OS_Yield(void);















OS_RETURN_CODE OS_RaiseException(NATIVE_TID td, UINT32 code);

#line 160 "c:\\pin35\\extras\\crt\\include\\os-apis/threads.h"
#line 29 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/process.h"











#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis\\process-core.h"

























OS_RETURN_CODE OS_GetPid(NATIVE_PID* pid);

#line 29 "c:\\pin35\\extras\\crt\\include\\os-apis\\process-core.h"
#line 13 "c:\\pin35\\extras\\crt\\include\\os-apis/process.h"




typedef UINT64 OS_PROCESS_WAITABLE_PROCESS;

















OS_RETURN_CODE OS_GetCommandLine(NATIVE_PID pid, USIZE* argc, CHAR*** argv, USIZE* bufsize);




















OS_RETURN_CODE OS_GetEnvironmentBlock(NATIVE_PID pid, CHAR*** block, USIZE* bufSize);










__declspec(noreturn) void OS_ExitProcess(INT code);















OS_RETURN_CODE OS_IsDebuggerPresent(NATIVE_PID pid, BOOL_T* isPresent);














OS_RETURN_CODE OS_GetUid(NATIVE_UID* uid);
















OS_RETURN_CODE OS_FindStdFiles(NATIVE_FD* files);


























OS_RETURN_CODE OS_CreateProcess(const CHAR* args, NATIVE_FD* stdFiles, NATIVE_FD* closeFiles, 
                                char **environ, OS_PROCESS_WAITABLE_PROCESS* process);




typedef OS_RETURN_CODE (*OS_FnPtrCreateProcess)(const CHAR* args, NATIVE_FD* stdFiles, NATIVE_FD* closeFiles, 
                                                char **environ, OS_PROCESS_WAITABLE_PROCESS* process);















OS_RETURN_CODE OS_WaitForProcessTermination(OS_PROCESS_WAITABLE_PROCESS process, UINT32* exitStatus);










VOID OS_TriggerSoftwareBreakpoint();













#line 191 "c:\\pin35\\extras\\crt\\include\\os-apis/process.h"
#line 30 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/time.h"
























OS_RETURN_CODE OS_Time(UINT64* CurrentTime);















OS_RETURN_CODE OS_GetDefaultTimeZone(CHAR* tzname, USIZE buflen);

#line 44 "c:\\pin35\\extras\\crt\\include\\os-apis/time.h"
#line 31 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/threads-management.h"






#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis.h"

















































#line 8 "c:\\pin35\\extras\\crt\\include\\os-apis/threads-management.h"
















VOID OS_DeregisterThread(NATIVE_TID ntid);









VOID OS_DeregisterCurrentThread(void);

#line 37 "c:\\pin35\\extras\\crt\\include\\os-apis/threads-management.h"

#line 32 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/pin-tls.h"






#line 1 "c:\\pin35\\extras\\crt\\include\\types.h"
































































































































































































#line 8 "c:\\pin35\\extras\\crt\\include\\os-apis/pin-tls.h"










typedef VOID (*TLS_DESTRUCTOR)(VOID*);




typedef ADDRINT PIN_TLS_INDEX;














VOID* OS_TlsGetBaseAddress();













PIN_TLS_INDEX OS_TlsAlloc(TLS_DESTRUCTOR dest);












BOOL_T OS_TlsFree(PIN_TLS_INDEX idx);













VOID* OS_TlsGetValue(PIN_TLS_INDEX idx);














VOID* OS_TlsGetValueForThread(PIN_TLS_INDEX idx, NATIVE_TID ntid);










VOID** OS_TlsGetArrayAddress(void);












VOID** OS_TlsGetArrayAddressForThread(NATIVE_TID ntid);














BOOL_T OS_TlsSetValue(PIN_TLS_INDEX idx, VOID* val);















BOOL_T OS_TlsSetValueForThread(PIN_TLS_INDEX idx, NATIVE_TID ntid, VOID* val);











VOID OS_TlsFreeThreadTls(NATIVE_TID ntid);













BOOL_T OS_TlsAddStaticTlsDestructor(TLS_DESTRUCTOR destructor);

#line 178 "c:\\pin35\\extras\\crt\\include\\os-apis/pin-tls.h"
#line 33 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/host.h"















typedef enum
{
    OS_HOST_CPU_ARCH_TYPE_INVALID                          = 0,
    OS_HOST_CPU_ARCH_TYPE_IA32                             = 1,
    OS_HOST_CPU_ARCH_TYPE_INTEL64                          = 2
} OS_HOST_CPU_ARCH_TYPE;















OS_RETURN_CODE OS_GetHostName(CHAR* buf, USIZE buflen);













OS_RETURN_CODE OS_GetHostCPUArch(OS_HOST_CPU_ARCH_TYPE* arch);












const char* OS_CPUArchToString(OS_HOST_CPU_ARCH_TYPE arch);














OS_RETURN_CODE OS_GetKernelRelease(CHAR* buf, USIZE bufsize);














OS_RETURN_CODE OS_GetOSName(CHAR* buf, USIZE bufsize);














OS_RETURN_CODE OS_GetOSVersion(CHAR* buf, USIZE bufsize);













OS_RETURN_CODE OS_ReadProcessorFrequency(UINT32* freq);

#line 126 "c:\\pin35\\extras\\crt\\include\\os-apis/host.h"
#line 34 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/mutex.h"











typedef ADDRINT OS_SPINLOCK_TYPE;

typedef enum _OS_APIS_MUTEX_KIND {
    OS_MUTEX_DEPTH_SIMPLE = 0, 
    OS_MUTEX_DEPTH_RECURSIVE   
} OS_MUTEX_DEPTH;








typedef struct _OS_APIS_MUTEX_TYPE {
    OS_MUTEX_DEPTH kind;
    OS_SPINLOCK_TYPE spinlock;
    OS_EVENT event;
    UINT32 num_waiters;
    UINT32 depth;



} OS_MUTEX_TYPE_IMPL;

typedef union
{
    OS_MUTEX_TYPE_IMPL impl;
    char reserved[64*2];
}  __declspec ( align(64) ) OS_MUTEX_TYPE;







#line 50 "c:\\pin35\\extras\\crt\\include\\os-apis/mutex.h"

























#line 76 "c:\\pin35\\extras\\crt\\include\\os-apis/mutex.h"


























void OS_MutexInit(volatile OS_MUTEX_TYPE *lock);












void OS_MutexRecursiveInit(volatile OS_MUTEX_TYPE *lock);














void OS_MutexDestroy(volatile OS_MUTEX_TYPE *lock);










void OS_MutexLock(volatile OS_MUTEX_TYPE *lock);















void OS_MutexLockTid(volatile OS_MUTEX_TYPE *lock, NATIVE_TID myTid);














BOOL_T OS_MutexTryLock(volatile OS_MUTEX_TYPE *lock);



















BOOL_T OS_MutexTryLockTid(volatile OS_MUTEX_TYPE *lock0, NATIVE_TID myTid);













BOOL_T OS_MutexIsLocked(volatile OS_MUTEX_TYPE *lock);
















BOOL_T OS_MutexTimedLock(volatile OS_MUTEX_TYPE *lock, UINT32 timeoutMillis);





















BOOL_T OS_MutexTimedLockTid(volatile OS_MUTEX_TYPE *lock0, NATIVE_TID myTid, UINT32 timeoutMillis);














NATIVE_TID OS_MutexGetOwner(volatile OS_MUTEX_TYPE *lock);
















UINT32 OS_MutexGetRecursionLevel(volatile OS_MUTEX_TYPE *lock);












BOOL_T OS_MutexUnlock(volatile OS_MUTEX_TYPE *lock);

#line 293 "c:\\pin35\\extras\\crt\\include\\os-apis/mutex.h"
#line 35 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/rw-lock.h"






#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis.h"

















































#line 8 "c:\\pin35\\extras\\crt\\include\\os-apis/rw-lock.h"






typedef enum
{
    OS_APIS_RW_LOCK_OWNER_TYPE_NONE,
    OS_APIS_RW_LOCK_OWNER_TYPE_WRITER,
    OS_APIS_RW_LOCK_OWNER_TYPE_READER
} OS_APIS_RW_LOCK_OWNER_TYPE;





typedef struct
{
    OS_MUTEX_TYPE_IMPL lock;
    OS_APIS_RW_LOCK_OWNER_TYPE owner_type;
    UINT32 readers;
    OS_EVENT no_readers_event;
    UINT32 waiters_count;



} OS_APIS_RW_LOCK_IMPL_T;

typedef union
{
    OS_APIS_RW_LOCK_IMPL_T impl;
    char reserved[64*2];
} __declspec ( align(64) ) OS_APIS_RW_LOCK_T;










#line 53 "c:\\pin35\\extras\\crt\\include\\os-apis/rw-lock.h"










void OS_RWLockInitialize(volatile OS_APIS_RW_LOCK_T* l);










void OS_RWLockDestroy(volatile OS_APIS_RW_LOCK_T* l);











void OS_RWLockAcquireWrite(volatile OS_APIS_RW_LOCK_T* lock);










void OS_RWLockReleaseWrite(volatile OS_APIS_RW_LOCK_T* lock);











void OS_RWLockAcquireRead(volatile OS_APIS_RW_LOCK_T* lock);










void OS_RWLockReleaseRead(volatile OS_APIS_RW_LOCK_T* lock);















BOOL_T OS_RWLockRelease(volatile OS_APIS_RW_LOCK_T* l);













BOOL_T OS_RWLockTryAcquireWrite(volatile OS_APIS_RW_LOCK_T* l);













BOOL_T OS_RWLockTryAcquireRead(volatile OS_APIS_RW_LOCK_T* l);

#line 167 "c:\\pin35\\extras\\crt\\include\\os-apis/rw-lock.h"
#line 36 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis/ipc-pipe.h"











#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis.h"

















































#line 13 "c:\\pin35\\extras\\crt\\include\\os-apis/ipc-pipe.h"




typedef enum
{
    OS_PIPE_CREATE_FLAGS_NONE                           = 0,       
    OS_PIPE_CREATE_FLAGS_READ_SIDE_INHERITABLE          = (1<<0),  
    OS_PIPE_CREATE_FLAGS_WRITE_SIDE_INHERITABLE         = (1<<1)   
} OS_PIPE_CREATE_FLAGS;
















OS_RETURN_CODE OS_Pipe(OS_PIPE_CREATE_FLAGS flags, NATIVE_FD* readFd, NATIVE_FD* writeFd);

#line 42 "c:\\pin35\\extras\\crt\\include\\os-apis/ipc-pipe.h"
#line 37 "c:\\pin35\\extras\\crt\\include\\os-apis.h"

#line 1 "c:\\pin35\\extras\\crt\\include\\windows/gcc_compat.h"










int __builtin_clz(unsigned int x);





int __builtin_ctz(unsigned int x);

#line 20 "c:\\pin35\\extras\\crt\\include\\windows/gcc_compat.h"
#line 39 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\windows/util-windows.h"






#line 1 "c:\\pin35\\extras\\crt\\include\\os-apis.h"

















































#line 8 "c:\\pin35\\extras\\crt\\include\\windows/util-windows.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\types.h"
































































































































































































#line 9 "c:\\pin35\\extras\\crt\\include\\windows/util-windows.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"







extern "C" {
#line 10 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"

#line 1 "c:\\pin35\\extras\\crt\\include\\baresyscall\\syscalltypes.h"
















#line 12 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"

typedef int OS_SYSCALL_TYPE;



#line 1 "c:\\pin35\\extras\\crt\\include\\baresyscall\\windows-baresyscall.h"







extern "C" {
#line 10 "c:\\pin35\\extras\\crt\\include\\baresyscall\\windows-baresyscall.h"

#line 1 "c:\\pin35\\extras\\crt\\include\\types.h"
































































































































































































#line 12 "c:\\pin35\\extras\\crt\\include\\baresyscall\\windows-baresyscall.h"



#line 1 "c:\\pin35\\extras\\crt\\include\\baresyscall\\ia32-windows/baresyscall.h"







extern "C" {
#line 10 "c:\\pin35\\extras\\crt\\include\\baresyscall\\ia32-windows/baresyscall.h"

#line 1 "c:\\pin35\\extras\\crt\\include\\types.h"
































































































































































































#line 12 "c:\\pin35\\extras\\crt\\include\\baresyscall\\ia32-windows/baresyscall.h"













}
#line 27 "c:\\pin35\\extras\\crt\\include\\baresyscall\\ia32-windows/baresyscall.h"

#line 29 "c:\\pin35\\extras\\crt\\include\\baresyscall\\ia32-windows/baresyscall.h"
#line 16 "c:\\pin35\\extras\\crt\\include\\baresyscall\\windows-baresyscall.h"



#line 20 "c:\\pin35\\extras\\crt\\include\\baresyscall\\windows-baresyscall.h"




typedef struct 
{
    long _status;
} OS_SYSCALLRETURN;











OS_SYSCALLRETURN OS_SyscallDoCall(ADDRINT sysno, const ADDRINT *args, ADDRINT argCount, OS_SYSCALL_TYPE);


}
#line 44 "c:\\pin35\\extras\\crt\\include\\baresyscall\\windows-baresyscall.h"

#line 46 "c:\\pin35\\extras\\crt\\include\\baresyscall\\windows-baresyscall.h"
#line 18 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"

#line 20 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"





#line 26 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"





#line 32 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"











OS_SYSCALLRETURN OS_SyscallDo(ADDRINT sysno, OS_SYSCALL_TYPE type, unsigned argCount, ...);



}
#line 49 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"

#line 51 "c:\\pin35\\extras\\crt\\include\\baresyscall/baresyscall.h"
#line 10 "c:\\pin35\\extras\\crt\\include\\windows/util-windows.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\windows\\win_syscalls.h"









typedef unsigned __int32 SYSCALL_NUMBER_T;









































































#line 85 "c:\\pin35\\extras\\crt\\include\\windows\\win_syscalls.h"




















typedef enum SYSCALL_KEY
{
    
    SYSCALL_KEY_NtContinue, SYSCALL_KEY_NtCallbackReturn, SYSCALL_KEY_NtGetContextThread, SYSCALL_KEY_NtSetContextThread, SYSCALL_KEY_NtTerminateThread, SYSCALL_KEY_NtTerminateProcess, SYSCALL_KEY_NtRaiseException, SYSCALL_KEY_NtAllocateVirtualMemory, SYSCALL_KEY_NtProtectVirtualMemory, SYSCALL_KEY_NtCreateSection, SYSCALL_KEY_NtMapViewOfSection, SYSCALL_KEY_NtUnmapViewOfSection, SYSCALL_KEY_NtFreeVirtualMemory, SYSCALL_KEY_NtFlushInstructionCache, SYSCALL_KEY_NtSuspendThread, SYSCALL_KEY_NtCreateProcess, SYSCALL_KEY_NtCreateProcessEx, SYSCALL_KEY_NtCreateThread, SYSCALL_KEY_NtResumeThread, SYSCALL_KEY_NtCreateUserProcess, SYSCALL_KEY_NtCreateThreadEx, SYSCALL_KEY_NtDelayExecution, SYSCALL_KEY_NtYieldExecution, SYSCALL_KEY_NtQueryInformationProcess, SYSCALL_KEY_NtQueryVirtualMemory, SYSCALL_KEY_NtAlertResumeThread, SYSCALL_KEY_NtClose, SYSCALL_KEY_NtCreateEvent, SYSCALL_KEY_NtCreateFile, SYSCALL_KEY_NtCreateMutant, SYSCALL_KEY_NtCreateNamedPipeFile, SYSCALL_KEY_NtCreateSemaphore, SYSCALL_KEY_NtDeleteFile, SYSCALL_KEY_NtDuplicateObject, SYSCALL_KEY_NtFlushBuffersFile, SYSCALL_KEY_NtOpenFile, SYSCALL_KEY_NtOpenKey, SYSCALL_KEY_NtOpenProcess, SYSCALL_KEY_NtOpenThread, SYSCALL_KEY_NtQueryAttributesFile, SYSCALL_KEY_NtQueryInformationFile, SYSCALL_KEY_NtQueryInformationThread, SYSCALL_KEY_NtQueryObject, SYSCALL_KEY_NtQueryPerformanceCounter, SYSCALL_KEY_NtQuerySecurityObject, SYSCALL_KEY_NtQuerySystemInformation, SYSCALL_KEY_NtQueryValueKey, SYSCALL_KEY_NtReadFile, SYSCALL_KEY_NtReadVirtualMemory, SYSCALL_KEY_NtReleaseMutant, SYSCALL_KEY_NtReleaseSemaphore, SYSCALL_KEY_NtResetEvent, SYSCALL_KEY_NtSetEvent, SYSCALL_KEY_NtSetInformationFile, SYSCALL_KEY_NtWaitForMultipleObjects, SYSCALL_KEY_NtWaitForSingleObject, SYSCALL_KEY_NtWriteFile, SYSCALL_KEY_NtWriteVirtualMemory, SYSCALL_KEY_NtSignalAndWaitForSingleObject, SYSCALL_KEY_NtQueryVolumeInformationFile, SYSCALL_KEY_NtCreateMailslotFile, 
    

    SYSCALL_KEY_END,
    SYSCALL_KEY_UNKNOWN = SYSCALL_KEY_END
} SYSCALL_KEY;



typedef char __TOO_MANY_SYSCALLS__[((unsigned)SYSCALL_KEY_END <= 128)?1:-1];

#line 120 "c:\\pin35\\extras\\crt\\include\\windows\\win_syscalls.h"
#line 11 "c:\\pin35\\extras\\crt\\include\\windows/util-windows.h"

void OS_SetSysCallTable(SYSCALL_NUMBER_T *input);

void OS_SetIfItIsWow64();

#line 17 "c:\\pin35\\extras\\crt\\include\\windows/util-windows.h"
#line 40 "c:\\pin35\\extras\\crt\\include\\os-apis.h"



#line 44 "c:\\pin35\\extras\\crt\\include\\os-apis.h"


}
#line 48 "c:\\pin35\\extras\\crt\\include\\os-apis.h"

#line 50 "c:\\pin35\\extras\\crt\\include\\os-apis.h"
#line 59 "C:\\Pin35\\extras\\crt\\include/stdio.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\toolchains.h"








#pragma section(".CRT$XIB",read)


























#line 37 "c:\\pin35\\extras\\crt\\include\\toolchains.h"





#line 43 "c:\\pin35\\extras\\crt\\include\\toolchains.h"


#line 46 "c:\\pin35\\extras\\crt\\include\\toolchains.h"
#line 60 "C:\\Pin35\\extras\\crt\\include/stdio.h"



typedef off_t fpos_t;		








struct __sbuf {
	unsigned char *_base;
	int	_size;
};




























typedef	struct __sFILE {
	unsigned char *_p;	
	int	_r;		
	int	_w;		
	short	_flags;		
	NATIVE_FD _file;		
	struct	__sbuf _bf;	
	int	_lbfsize;	

	
	void	*_cookie;	
	int	(*_close)(void *);
	int	(*_read)(void *, char *, int);
	fpos_t	(*_seek)(void *, fpos_t, int);
	int	(*_write)(void *, const char *, int);

	
	struct	__sbuf _ext;
	
	unsigned char *_up;	
	int	_ur;		

	
	unsigned char _ubuf[3];	
	unsigned char _nbuf[1];	

	
	struct	__sbuf _lb;	

	
	int	_blksize;	
	fpos_t	_offset;	
} FILE;

extern "C" {
__declspec(dllimport) extern FILE __sF[];
}





	










































#line 190 "C:\\Pin35\\extras\\crt\\include/stdio.h"






#line 197 "C:\\Pin35\\extras\\crt\\include/stdio.h"


#line 200 "C:\\Pin35\\extras\\crt\\include/stdio.h"


#line 203 "C:\\Pin35\\extras\\crt\\include/stdio.h"








extern "C" {
void	 clearerr(FILE *);
int	 fclose(FILE *);
int	 feof(FILE *);
int	 ferror(FILE *);
int	 fflush(FILE *);
int  fcloseall (void);
int	 fgetc(FILE *);
char	*fgets(char * , int, FILE * );
FILE	*fopen(const char *  , const char * );
int	 fprintf(FILE *  , const char * , ...)
		 ;
int	 fputc(int, FILE *);
int	 fputs(const char * , FILE * );
size_t	 fread(void * , size_t, size_t, FILE * );
FILE	*freopen(const char * , const char * ,
	    FILE * );
int	 fscanf(FILE * , const char * , ...)
		 ;
int	 fseek(FILE *, long, int);
long	 ftell(FILE *);
size_t	 fwrite(const void * , size_t, size_t, FILE * );
int	 getc(FILE *);
int	 getchar(void);
ssize_t	 getdelim(char ** , size_t * , int,
	    FILE * );
ssize_t	 getline(char ** , size_t * , FILE * );

void	 perror(const char *);
int	 printf(const char * , ...)
		 ;
int	 putc(int, FILE *);
int	 putchar(int);
int	 puts(const char *);
int	 remove(const char *);
void	 rewind(FILE *);
int	 scanf(const char * , ...)
		 ;
void	 setbuf(FILE * , char * );
int	 setvbuf(FILE * , char * , int, size_t);
int	 sscanf(const char * , const char * , ...)
		 ;
FILE	*tmpfile(void);
int	 ungetc(int, FILE *);
int	 vfprintf(FILE * , const char * , __va_list)
		 ;
int	 vprintf(const char * , __va_list)
		 ;

int dprintf(int, const char * , ...)  ;
int vdprintf(int, const char * , __va_list)  ;



char* gets(char*) ;
#line 267 "C:\\Pin35\\extras\\crt\\include/stdio.h"
int sprintf(char* , const char* , ...)
      ;
char* tmpnam(char*) ;
int vsprintf(char* , const char* , __va_list)
      ;

char* tempnam(const char*, const char*)
    ;
#line 276 "C:\\Pin35\\extras\\crt\\include/stdio.h"
#line 277 "C:\\Pin35\\extras\\crt\\include/stdio.h"

extern int rename(const char*, const char*);
extern int renameat(int, const char*, int, const char*);

int	 fgetpos(FILE * , fpos_t * );
int	 fsetpos(FILE *, const fpos_t *);

int	 fseeko(FILE *, off_t, int);
off_t	 ftello(FILE *);


int	 snprintf(char * , size_t, const char * , ...)
		 ;
int	 vfscanf(FILE * , const char * , __va_list)
		 ;
int	 vscanf(const char *, __va_list)
		 ;
int	 vsnprintf(char * , size_t, const char * , __va_list)
		 ;
int	 vsscanf(const char * , const char * , __va_list)
		 ;
#line 299 "C:\\Pin35\\extras\\crt\\include/stdio.h"

}








extern "C" {
FILE	*fdopen(NATIVE_FD, const char *);
NATIVE_FD	 fileno(FILE *);


int	 pclose(FILE *);
FILE	*popen(const char *, const char *);
#line 317 "C:\\Pin35\\extras\\crt\\include/stdio.h"


void	 flockfile(FILE *);
int	 ftrylockfile(FILE *);
void	 funlockfile(FILE *);





int	 getc_unlocked(FILE *);
int	 getchar_unlocked(void);
int	 putc_unlocked(int, FILE *);
int	 putchar_unlocked(int);
#line 332 "C:\\Pin35\\extras\\crt\\include/stdio.h"


FILE* fmemopen(void*, size_t, const char*);
FILE* open_memstream(char**, size_t*);
#line 337 "C:\\Pin35\\extras\\crt\\include/stdio.h"


int  _vscprintf(const char *fmt, __va_list ap);
int  _vscwprintf(const wchar_t *fmt, __va_list ap);
int  _scwprintf(const wchar_t *fmt, ...);
int  _scprintf(const char *fmt, ...);

}

#line 347 "C:\\Pin35\\extras\\crt\\include/stdio.h"





extern "C" {
int	 asprintf(char ** , const char * , ...)
		 ;
char	*fgetln(FILE * , size_t * );
int	 fpurge(FILE *);
void	 setbuffer(FILE *, char *, int);
int	 setlinebuf(FILE *);
int	 vasprintf(char ** , const char * ,
    __va_list)
		 ;

void clearerr_unlocked(FILE*);
int feof_unlocked(FILE*);
int ferror_unlocked(FILE*);

}




extern "C" {
FILE	*funopen(const void *,
		int (*)(void *, char *, int),
		int (*)(void *, const char *, int),
		fpos_t (*)(void *, fpos_t, int),
		int (*)(void *));
}


#line 382 "C:\\Pin35\\extras\\crt\\include/stdio.h"


























































































#line 473 "C:\\Pin35\\extras\\crt\\include/stdio.h"

#line 475 "C:\\Pin35\\extras\\crt\\include/stdio.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 41 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"





#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"








#line 56 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"

#line 58 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 28 "C:\\Pin35\\extras\\crt\\include\\malloc.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\alloca.h"






























#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 32 "C:\\Pin35\\extras\\crt\\include\\alloca.h"




extern "C" {

void* __cdecl _alloca(size_t _Size);

}



#line 45 "C:\\Pin35\\extras\\crt\\include\\alloca.h"

#line 47 "C:\\Pin35\\extras\\crt\\include\\alloca.h"

#line 29 "C:\\Pin35\\extras\\crt\\include\\malloc.h"

extern "C" {




#line 36 "C:\\Pin35\\extras\\crt\\include\\malloc.h"


#line 39 "C:\\Pin35\\extras\\crt\\include\\malloc.h"

extern void* malloc(size_t byte_count)   ;
extern void* calloc(size_t item_count, size_t item_size)   ;
extern void* realloc(void* p, size_t byte_count)  ;
extern void *valloc(size_t size)   ;
extern void free(void* p);

extern void* memalign(size_t alignment, size_t byte_count)   ;
extern size_t malloc_usable_size(const void* p);



struct mallinfo {
  size_t arena;    
  size_t ordblks;  
  size_t smblks;   
  size_t hblks;    
  size_t hblkhd;   
  size_t usmblks;  
  size_t fsmblks;  
  size_t uordblks; 
  size_t fordblks; 
  size_t keepcost; 
};
#line 64 "C:\\Pin35\\extras\\crt\\include\\malloc.h"

extern struct mallinfo mallinfo(void);




















extern int malloc_info(int, FILE *);

}

#line 91 "C:\\Pin35\\extras\\crt\\include\\malloc.h"
#line 35 "C:\\Pin35\\extras\\crt\\include/string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\xlocale.h"
































struct __locale_t;
typedef struct __locale_t* locale_t;

#line 37 "C:\\Pin35\\extras\\crt\\include\\xlocale.h"
#line 36 "C:\\Pin35\\extras\\crt\\include/string.h"

extern "C" {

extern void*  memccpy(void* , const void* , int, size_t);
extern void*  memchr(const void *, int, size_t) ;
extern void*  memrchr(const void *, int, size_t) ;
extern int    memcmp(const void *, const void *, size_t) ;
extern void*  memcpy(void* , const void* , size_t);
extern void*  memmove(void *, const void *, size_t);
extern void*  memset(void *, int, size_t);
extern void*  memmem(const void *, size_t, const void *, size_t) ;

extern char*  strchr(const char *, int) ;
extern char* __strchr_chk(const char *, int, size_t);

extern char*  strrchr(const char *, int) ;
extern char* __strrchr_chk(const char *, int, size_t);

extern size_t strlen(const char *) ;
extern size_t __strlen_chk(const char *, size_t);
extern int    strcmp(const char *, const char *) ;
extern char*  stpcpy(char* , const char* );
extern char*  strcpy(char* , const char* );
extern char*  strcat(char* , const char* );

extern int    strcasecmp(const char *, const char *) ;
extern int    strncasecmp(const char *, const char *, size_t) ;



extern char*  strdup(const char *);
extern char *_strlwr(char *);

extern char*  strstr(const char *, const char *) ;
extern char*  strcasestr(const char *haystack, const char *needle) ;
extern char*  strtok(char* , const char* );
extern char*  strtok_r(char* , const char* , char** );

extern char* strerror(int);


#line 78 "C:\\Pin35\\extras\\crt\\include/string.h"
extern int strerror_r(int, char*, size_t);
#line 80 "C:\\Pin35\\extras\\crt\\include/string.h"

extern size_t strnlen(const char *, size_t) ;
extern char*  strncat(char* , const char* , size_t);
extern char*  strndup(const char *, size_t);
extern int    strncmp(const char *, const char *, size_t) ;
extern char*  stpncpy(char* , const char* , size_t);
extern char*  strncpy(char* , const char* , size_t);

extern size_t strlcat(char* , const char* , size_t);
extern size_t strlcpy(char* , const char* , size_t);

extern size_t strcspn(const char *, const char *) ;
extern char*  strpbrk(const char *, const char *) ;
extern char*  strsep(char** , const char* );
extern size_t strspn(const char *, const char *);

extern char*  strsignal(int  sig);

extern int    strcoll(const char *, const char *) ;
extern size_t strxfrm(char* , const char* , size_t);

extern int    strcoll_l(const char *, const char *, locale_t) ;
extern size_t strxfrm_l(char* , const char* , size_t, locale_t);




#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#pragma intrinsic(strcat)
#pragma intrinsic(strcmp)
#pragma intrinsic(strcpy)
#pragma intrinsic(strlen)

#line 116 "C:\\Pin35\\extras\\crt\\include/string.h"













#line 130 "C:\\Pin35\\extras\\crt\\include/string.h"


































































































































































































#line 325 "C:\\Pin35\\extras\\crt\\include/string.h"

}

#line 329 "C:\\Pin35\\extras\\crt\\include/string.h"
#line 40 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\string.h"














#line 56 "C:\\Pin35\\extras\\stlport\\include\\string.h"








#line 65 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 66 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 67 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 35 "C:\\Pin35\\extras\\crt\\include/stdlib.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\alloca.h"















































#line 36 "C:\\Pin35\\extras\\crt\\include/stdlib.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\strings.h"









































#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"















































































































































































#line 43 "C:\\Pin35\\extras\\crt\\include\\strings.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 44 "C:\\Pin35\\extras\\crt\\include\\strings.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\string.h"





























#line 31 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 39 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/string.h"








































































































































































































































































































































#line 40 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\string.h"














#line 56 "C:\\Pin35\\extras\\stlport\\include\\string.h"








#line 65 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 66 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 67 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 45 "C:\\Pin35\\extras\\crt\\include\\strings.h"

extern "C" {





#line 53 "C:\\Pin35\\extras\\crt\\include\\strings.h"


#line 56 "C:\\Pin35\\extras\\crt\\include\\strings.h"


int	 ffs(int);

}

#line 63 "C:\\Pin35\\extras\\crt\\include\\strings.h"
#line 37 "C:\\Pin35\\extras\\crt\\include/stdlib.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\memory.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\string.h"





























#line 31 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 39 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/string.h"








































































































































































































































































































































#line 40 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\string.h"














#line 56 "C:\\Pin35\\extras\\stlport\\include\\string.h"








#line 65 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 66 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 67 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 2 "C:\\Pin35\\extras\\crt\\include\\memory.h"
#line 38 "C:\\Pin35\\extras\\crt\\include/stdlib.h"
#line 1 "c:\\pin35\\extras\\crt\\include\\types.h"
































































































































































































#line 39 "C:\\Pin35\\extras\\crt\\include/stdlib.h"

extern "C" {




extern  void abort(void);
extern  void exit(int);
extern  void _Exit(int);
extern int atexit(void (*)(void));




#line 54 "C:\\Pin35\\extras\\crt\\include/stdlib.h"

extern char* getenv(const char*);
extern int putenv(char*);
extern int setenv(const char*, const char*, int);
extern int unsetenv(const char*);
extern int clearenv(void);

extern char* mkdtemp(char*);
extern char* mktemp(char*) ;
extern NATIVE_FD mkstemp(char*);
extern NATIVE_FD mkstemp64(char*);

extern long strtol(const char *, char **, int);
extern long long strtoll(const char *, char **, int);
extern unsigned long strtoul(const char *, char **, int);
extern unsigned long long strtoull(const char *, char **, int);

extern int posix_memalign(void **memptr, size_t alignment, size_t size);

extern double atof(const char*);

extern double strtod(const char*, char**) ;
extern float strtof(const char*, char**) ;
extern long double strtold(const char*, char**) ;

extern long double strtold_l(const char *, char **, locale_t) ;
extern long long strtoll_l(const char *, char **, size_t, locale_t) ;
extern unsigned long long strtoull_l(const char *, char **, size_t, locale_t) ;

extern int atoi(const char*) ;
extern long atol(const char*) ;
extern long long atoll(const char*) ;
extern void _itoa(int val, char* buf, int radix);

extern int abs(int) ;
extern long labs(long) ;
extern long long llabs(long long) ;

extern char * realpath(const char *path, char *resolved);
extern int system(const char * string);

extern void * bsearch(const void *key, const void *base0,
	size_t nmemb, size_t size,
	int (*compar)(const void *, const void *));

extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));

extern long jrand48(unsigned short *);
extern long mrand48(void);
extern long nrand48(unsigned short *);
extern long lrand48(void);
extern unsigned short *seed48(unsigned short*);
extern double erand48(unsigned short xsubi[3]);
extern double drand48(void);
extern void srand48(long);

unsigned int arc4random(void);
unsigned int arc4random_uniform(unsigned int);
void arc4random_buf(void*, size_t);



int rand(void);
int rand_r(unsigned int*);
void srand(unsigned int);

char* initstate(unsigned int, char*, size_t);
long random(void);
char* setstate(char*);
void srandom(unsigned int);

int getpt(void);
int grantpt(int);
int posix_openpt(int);
char* ptsname(int) ;
int ptsname_r(int, char*, size_t);
int unlockpt(int);

typedef struct {
    int  quot;
    int  rem;
} div_t;

extern div_t   div(int, int) ;

typedef struct {
    long int  quot;
    long int  rem;
} ldiv_t;

extern ldiv_t   ldiv(long, long) ;

typedef struct {
    long long int  quot;
    long long int  rem;
} lldiv_t;

extern lldiv_t   lldiv(long long, long long) ;


extern const char* getprogname(void);
extern void setprogname(const char*);


extern int      mblen(const char *, size_t);
extern size_t   mbstowcs(wchar_t *, const char *, size_t);
extern int      mbtowc(wchar_t *, const char *, size_t);


extern int	wctomb(char *, wchar_t);
extern size_t	wcstombs(char *, const wchar_t *, size_t);

extern size_t __ctype_get_mb_cur_max(void);


}

#line 172 "C:\\Pin35\\extras\\crt\\include/stdlib.h"
#line 51 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"
#line 52 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"




#line 57 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"








#line 66 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"

#line 68 "C:\\Pin35\\extras\\stlport\\include\\stdlib.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"









#line 38 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"




#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"









#line 53 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"


namespace std {
using ::div_t;
using ::ldiv_t;
using ::size_t;




using ::abort;
using ::getenv;
using ::mblen;
using ::mbtowc;
using ::system;
using ::bsearch;
#line 70 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
using ::atexit;
using ::exit;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mbstowcs;
using ::strtod;
using ::strtol;
using ::strtoul;


using ::wcstombs;

using ::wctomb;
#line 89 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
#line 90 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
using ::qsort;
using ::labs;
using ::ldiv;










#line 104 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
using ::rand;
using ::srand;
#line 107 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
}
#line 109 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"






#line 116 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"






#line 123 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"






inline long abs(long __x) { return ::labs(__x); }
#line 133 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"



inline ::ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
#line 139 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"

#line 141 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"





#line 147 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"










#line 158 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
inline __int64  abs(__int64 __x) { return __x < 0 ? -__x : __x; }
#line 160 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
#line 161 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"








#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"




























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"













#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\math.h"


















#line 20 "C:\\Pin35\\extras\\stlport\\include\\math.h"

#line 22 "C:\\Pin35\\extras\\stlport\\include\\math.h"




#line 28 "C:\\Pin35\\extras\\stlport\\include\\math.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\math.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/math.h"



















#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 21 "C:\\Pin35\\extras\\crt\\include/math.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\limits.h"


















#line 20 "C:\\Pin35\\extras\\stlport\\include\\limits.h"

#line 22 "C:\\Pin35\\extras\\stlport\\include\\limits.h"



#line 26 "C:\\Pin35\\extras\\stlport\\include\\limits.h"



#line 30 "C:\\Pin35\\extras\\stlport\\include\\limits.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/limits.h"





































#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 39 "C:\\Pin35\\extras\\crt\\include/limits.h"































#line 71 "C:\\Pin35\\extras\\crt\\include/limits.h"
#line 72 "C:\\Pin35\\extras\\crt\\include/limits.h"












#line 85 "C:\\Pin35\\extras\\crt\\include/limits.h"

#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"




























#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 30 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/limits.h"




































#line 38 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/limits.h"

#line 31 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"















#line 47 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"
















#line 64 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"



#line 68 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"



					

					

					
#line 77 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"




#line 82 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"






#line 89 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\float.h"


















#line 20 "C:\\Pin35\\extras\\stlport\\include\\float.h"

#line 22 "C:\\Pin35\\extras\\stlport\\include\\float.h"

#line 24 "C:\\Pin35\\extras\\stlport\\include\\float.h"



#line 28 "C:\\Pin35\\extras\\stlport\\include\\float.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/float.h"








































#line 42 "C:\\Pin35\\extras\\crt\\include/float.h"

#line 33 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\float.h"









#line 44 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 45 "C:\\Pin35\\extras\\stlport\\include\\float.h"







#line 53 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 91 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"




















#line 112 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"








































#line 153 "C:\\Pin35\\extras\\crt\\include\\sys/limits.h"
#line 87 "C:\\Pin35\\extras\\crt\\include/limits.h"


#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/syslimits.h"
#line 90 "C:\\Pin35\\extras\\crt\\include/limits.h"
#line 91 "C:\\Pin35\\extras\\crt\\include/limits.h"







#line 99 "C:\\Pin35\\extras\\crt\\include/limits.h"



#line 103 "C:\\Pin35\\extras\\crt\\include/limits.h"



#line 107 "C:\\Pin35\\extras\\crt\\include/limits.h"




#line 112 "C:\\Pin35\\extras\\crt\\include/limits.h"








#line 121 "C:\\Pin35\\extras\\crt\\include/limits.h"


#line 124 "C:\\Pin35\\extras\\crt\\include/limits.h"




#line 129 "C:\\Pin35\\extras\\crt\\include/limits.h"
#line 31 "C:\\Pin35\\extras\\stlport\\include\\limits.h"
#line 32 "C:\\Pin35\\extras\\stlport\\include\\limits.h"







#line 40 "C:\\Pin35\\extras\\stlport\\include\\limits.h"
#line 22 "C:\\Pin35\\extras\\crt\\include/math.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\types_marker.h"






























































































































































































































































#line 23 "C:\\Pin35\\extras\\crt\\include/math.h"

extern "C" {







union __infinity_un {
	unsigned char	__uc[sizeof(double)];
	double		__ud;
};


extern const __declspec( selectany ) union __infinity_un __infinity = { { 0, 0, 0, 0, 0, 0, 0xf0, 0x7f } };

union __nan_un {
	unsigned char	__uc[sizeof(float)];
	float		__uf;
};


extern const __declspec( selectany ) union __nan_un __nan = { { 0, 0, 0xc0, 0xff } };



#line 51 "C:\\Pin35\\extras\\crt\\include/math.h"



#line 55 "C:\\Pin35\\extras\\crt\\include/math.h"





#line 61 "C:\\Pin35\\extras\\crt\\include/math.h"















#line 77 "C:\\Pin35\\extras\\crt\\include/math.h"






















































#line 132 "C:\\Pin35\\extras\\crt\\include/math.h"






typedef double __double_t;
typedef __double_t double_t;
typedef float __float_t;
typedef __float_t float_t;
#line 143 "C:\\Pin35\\extras\\crt\\include/math.h"




















extern int signgam;
#line 165 "C:\\Pin35\\extras\\crt\\include/math.h"





#line 171 "C:\\Pin35\\extras\\crt\\include/math.h"

#line 173 "C:\\Pin35\\extras\\crt\\include/math.h"
#line 174 "C:\\Pin35\\extras\\crt\\include/math.h"










int	__fpclassifyd(double) ;
int	__fpclassifyf(float) ;
int	__fpclassifyl(long double) ;
int	__isfinitef(float) ;
int	__isfinite(double) ;
int	__isfinitel(long double) ;
int	__isinff(float) ;
int	__isinfl(long double) ;
int	__isnanf(float) ;
int	__isnanl(long double) ;
int	__isnormalf(float) ;
int	__isnormal(double) ;
int	__isnormall(long double) ;
int	__signbit(double) ;
int	__signbitf(float) ;
int	__signbitl(long double) ;

double	acos(double);
double	asin(double);
double	atan(double);
double	atan2(double, double);
double	cos(double);
double	sin(double);
double	tan(double);

double	cosh(double);
double	sinh(double);
double	tanh(double);

double	exp(double);
double	frexp(double, int *);	
double	ldexp(double, int);
double	log(double);
double	log10(double);
double	modf(double, double *);	

double	pow(double, double);
double	sqrt(double);

double	ceil(double);
double	fabs(double) ;
double	floor(double);
double	fmod(double, double);





double	acosh(double);
double	asinh(double);
double	atanh(double);
double	cbrt(double);
double	erf(double);
double	erfc(double);
double	exp2(double);
double	expm1(double);
double	fma(double, double, double);
double	hypot(double, double);
int	ilogb(double) ;
int	(isinf)(double) ;
int	(isnan)(double) ;
double	lgamma(double);
long long llrint(double);
long long llround(double);
double	log1p(double);
double	log2(double);
double	logb(double);
long	lrint(double);
long	lround(double);
double	nan(const char *) ;
double	nextafter(double, double);
double	remainder(double, double);
double	remquo(double, double, int *);
double	rint(double);
#line 259 "C:\\Pin35\\extras\\crt\\include/math.h"


double	j0(double);
double	j1(double);
double	jn(int, double);
double	y0(double);
double	y1(double);
double	yn(int, double);


double	gamma(double);
#line 271 "C:\\Pin35\\extras\\crt\\include/math.h"


double	scalb(double, double);
#line 275 "C:\\Pin35\\extras\\crt\\include/math.h"
#line 276 "C:\\Pin35\\extras\\crt\\include/math.h"


double	copysign(double, double) ;
double	fdim(double, double);
double	fmax(double, double) ;
double	fmin(double, double) ;
double	nearbyint(double);
double	round(double);
double	scalbln(double, long);
double	scalbn(double, int);
double	tgamma(double);
double	trunc(double);
#line 289 "C:\\Pin35\\extras\\crt\\include/math.h"





double	drem(double, double);
int	finite(double) ;
int	isnanf(float) ;
long double significandl(long double);





double	gamma_r(double, int *);
double	lgamma_r(double, int *);




double	significand(double);
#line 311 "C:\\Pin35\\extras\\crt\\include/math.h"



float	acosf(float);
float	asinf(float);
float	atanf(float);
float	atan2f(float, float);
float	cosf(float);
float	sinf(float);
float	tanf(float);

float	coshf(float);
float	sinhf(float);
float	tanhf(float);

float	exp2f(float);
float	expf(float);
float	expm1f(float);
float	frexpf(float, int *);	
int	ilogbf(float) ;
float	ldexpf(float, int);
float	log10f(float);
float	log1pf(float);
float	log2f(float);
float	logf(float);
float	modff(float, float *);	

float	powf(float, float);
float	sqrtf(float);

float	ceilf(float);
float	fabsf(float) ;
float	floorf(float);
float	fmodf(float, float);
float	roundf(float);

float	erff(float);
float	erfcf(float);
float	hypotf(float, float);
float	lgammaf(float);
float	tgammaf(float);

float	acoshf(float);
float	asinhf(float);
float	atanhf(float);
float	cbrtf(float);
float	logbf(float);
float	copysignf(float, float) ;
long long llrintf(float);
long long llroundf(float);
long	lrintf(float);
long	lroundf(float);
float	nanf(const char *) ;
float	nearbyintf(float);
float	nextafterf(float, float);
float	remainderf(float, float);
float	remquof(float, float, int *);
float	rintf(float);
float	scalblnf(float, long);
float	scalbnf(float, int);
float	truncf(float);

float	fdimf(float, float);
float	fmaf(float, float, float);
float	fmaxf(float, float) ;
float	fminf(float, float) ;
#line 378 "C:\\Pin35\\extras\\crt\\include/math.h"





float	dremf(float, float);
int	finitef(float) ;
float	gammaf(float);
float	j0f(float);
float	j1f(float);
float	jnf(int, float);
float	scalbf(float, float);
float	y0f(float);
float	y1f(float);
float	ynf(int, float);






float	gammaf_r(float, int *);
float	lgammaf_r(float, int *);




float	significandf(float);
#line 407 "C:\\Pin35\\extras\\crt\\include/math.h"





long double	acoshl(long double);
long double	acosl(long double);
long double	asinhl(long double);
long double	asinl(long double);
long double	atan2l(long double, long double);
long double	atanhl(long double);
long double	atanl(long double);
long double	cbrtl(long double);
long double	ceill(long double);
long double	copysignl(long double, long double) ;
long double	coshl(long double);
long double	cosl(long double);
long double	erfcl(long double);
long double	erfl(long double);
long double	exp2l(long double);
long double	expl(long double);
long double	expm1l(long double);
long double	fabsl(long double) ;
long double	fdiml(long double, long double);
long double	floorl(long double);
long double	fmal(long double, long double, long double);
long double	fmaxl(long double, long double) ;
long double	fminl(long double, long double) ;
long double	fmodl(long double, long double);
long double	frexpl(long double value, int *); 
long double	hypotl(long double, long double);
int		ilogbl(long double) ;
long double	ldexpl(long double, int);
long double	lgammal(long double);
long long	llrintl(long double);
long long	llroundl(long double);
long double	log10l(long double);
long double	log1pl(long double);
long double	log2l(long double);
long double	logbl(long double);
long double	logl(long double);
long		lrintl(long double);
long		lroundl(long double);
long double	modfl(long double, long double *); 
long double	nanl(const char *) ;
long double	nearbyintl(long double);
long double	nextafterl(long double, long double);
double		nexttoward(double, long double);
float		nexttowardf(float, long double);
long double	nexttowardl(long double, long double);
long double	powl(long double, long double);
long double	remainderl(long double, long double);
long double	remquol(long double, long double, int *);
long double	rintl(long double);
long double	roundl(long double);
long double	scalblnl(long double, long);
long double	scalbnl(long double, int);
long double	sinhl(long double);
long double	sinl(long double);
long double	sqrtl(long double);
long double	tanhl(long double);
long double	tanl(long double);
long double	tgammal(long double);
long double	truncl(long double);

#line 473 "C:\\Pin35\\extras\\crt\\include/math.h"





#line 479 "C:\\Pin35\\extras\\crt\\include/math.h"




}

#line 486 "C:\\Pin35\\extras\\crt\\include/math.h"
#line 33 "C:\\Pin35\\extras\\stlport\\include\\math.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\math.h"




#line 39 "C:\\Pin35\\extras\\stlport\\include\\math.h"













#line 53 "C:\\Pin35\\extras\\stlport\\include\\math.h"

#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
#line 46 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"











#line 59 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"













































#line 105 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"

















































#line 155 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"



#line 159 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"

#line 161 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"





















#line 183 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"




































































#line 252 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"




















































#line 305 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"























#line 329 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
#line 330 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
#line 331 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"


















#line 351 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"




































#line 388 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"



























#line 416 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"






inline double abs(double __x)
{ return ::fabs(__x); }

inline float abs (float x) { return ::fabsf(x); }


#line 431 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"

inline float acos (float x) { return ::acosf(x); }
inline float asin (float x) { return ::asinf(x); }
inline float atan (float x) { return ::atanf(x); }
inline float atan2 (float x, float y) { return ::atan2f(x, y); }
inline float ceil (float x) { return ::ceilf(x); }
inline float cos (float x) { return ::cosf(x); }
inline float cosh (float x) { return ::coshf(x); }
inline float exp (float x) { return ::expf(x); }
inline float fabs (float x) { return ::fabsf(x); }
inline float floor (float x) { return ::floorf(x); }
inline float fmod (float x, float y) { return ::fmodf(x, y); }
inline float frexp (float x, int * y) { return ::frexpf(x, y); }
inline float ldexp (float x, int y) { return ::ldexpf(x, y); }
inline float log (float x) { return ::logf(x); }
inline float log10 (float x) { return ::log10f(x); }
inline float modf (float x, float * y) { return ::modff(x, y); }
inline float sin (float x) { return ::sinf(x); }
inline float sinh (float x) { return ::sinhf(x); }
inline float sqrt (float x) { return ::sqrtf(x); }
inline float tan (float x) { return ::tanf(x); }
inline float tanh (float x) { return ::tanhf(x); }
inline float pow (float x, float y) { return ::powf(x, y); }




inline float pow(float __x, int __y) { return ::powf(__x, static_cast<float>(__y)); }


#line 462 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"


#line 465 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
inline double pow(double __x, int __y) { return ::pow(__x, static_cast<double>(__y)); }














#line 481 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"








#line 490 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
#line 491 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"











#line 503 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"



#line 507 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"



#line 511 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
#line 512 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"









#line 522 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"





























#line 552 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
namespace std {
using ::abs;
using ::acos;
using ::asin;
using ::atan;
using ::atan2;
using ::ceil;
using ::cos;
using ::cosh;
using ::exp;
using ::fabs;
using ::floor;
using ::fmod;
using ::frexp;








using ::hypot;
#line 576 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"




#line 581 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
using ::ldexp;
using ::log;
using ::log10;
using ::modf;
using ::pow;


#line 589 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
using ::sin;
using ::sinh;
using ::sqrt;
using ::tan;
using ::tanh;
}



#line 599 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"
#line 600 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"

#line 602 "C:\\Pin35\\extras\\stlport\\include\\stl/_cmath.h"




#line 170 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
#line 171 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"



namespace std {
using ::abs;
using ::div;
}
#line 179 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"

#line 181 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdlib.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstring.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstring.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\string.h"





























#line 31 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 39 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/string.h"








































































































































































































































































































































#line 40 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\string.h"














#line 56 "C:\\Pin35\\extras\\stlport\\include\\string.h"








#line 65 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 66 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 67 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstring.h"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstring.h"


namespace std {
#line 1 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"
using ::size_t;









#line 12 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"
using ::memmove;
using ::memcpy;
#line 15 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"



using ::strcoll;
using ::strerror;
using ::strxfrm;
#line 22 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"



#line 26 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"
using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;


#line 34 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"

using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;


#line 45 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"


using ::strcpy;


#line 51 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"
using ::strcspn;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
#line 61 "C:\\Pin35\\extras\\stlport\\include\\using/cstring"
#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstring.h"
}
#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstring.h"

#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstring.h"
#line 40 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"









































#line 1 "C:\\Pin35\\extras\\stlport\\include\\climits"

























#line 27 "C:\\Pin35\\extras\\stlport\\include\\climits"





#line 33 "C:\\Pin35\\extras\\stlport\\include\\climits"






#line 40 "C:\\Pin35\\extras\\stlport\\include\\climits"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\limits.h"


















#line 20 "C:\\Pin35\\extras\\stlport\\include\\limits.h"

#line 22 "C:\\Pin35\\extras\\stlport\\include\\limits.h"



#line 26 "C:\\Pin35\\extras\\stlport\\include\\limits.h"



#line 30 "C:\\Pin35\\extras\\stlport\\include\\limits.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/limits.h"
































































































































#line 31 "C:\\Pin35\\extras\\stlport\\include\\limits.h"
#line 32 "C:\\Pin35\\extras\\stlport\\include\\limits.h"







#line 40 "C:\\Pin35\\extras\\stlport\\include\\limits.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\climits"
#line 42 "C:\\Pin35\\extras\\stlport\\include\\climits"
#line 43 "C:\\Pin35\\extras\\stlport\\include\\climits"




#line 48 "C:\\Pin35\\extras\\stlport\\include\\climits"

#line 50 "C:\\Pin35\\extras\\stlport\\include\\climits"




#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"



































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"






























































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"




















namespace std {

struct __true_type {};
struct __false_type {};


namespace priv {
using ::std::__true_type;
using ::std::__false_type;
}
#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"


template <int _Is>
struct __bool2type
{ typedef __true_type _Ret; };

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class __bool_type>
struct __type2bool { enum {_Ret = 1}; };

template<>
struct __type2bool<__true_type> { enum {_Ret = 1}; };

template<>
struct __type2bool<__false_type> { enum {_Ret = 0}; };


template <class _BoolType>
struct _Not { typedef __false_type _Ret; };

template<>
struct _Not<__false_type> { typedef __true_type _Ret; };


template <class _P1, class _P2>
struct _Land2 { typedef __false_type _Ret; };

template<>
struct _Land2<__true_type, __true_type> { typedef __true_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 { typedef __false_type _Ret; };

template<>
struct _Land3<__true_type, __true_type, __true_type> { typedef __true_type _Ret; };


template <class _P1, class _P2>
struct _Lor2 { typedef __true_type _Ret; };

template<>
struct _Lor2<__false_type, __false_type> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Lor3 { typedef __true_type _Ret; };

template<>
struct _Lor3<__false_type, __false_type, __false_type> { typedef __false_type _Ret; };





















#line 110 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"


template <bool _Cond, class _Tp1, class _Tp2>
struct __select { typedef _Tp1 _Ret; };

template <class _Tp1, class _Tp2>
struct __select<false, _Tp1, _Tp2> { typedef _Tp2 _Ret; };




#line 122 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"
































#line 155 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"








struct _NoVolatilePointerShim { _NoVolatilePointerShim(const void*); };
template <class _Tp>
char __cdecl _IsCopyableFun(bool, _NoVolatilePointerShim, _Tp const*, _Tp*); 
char* __cdecl _IsCopyableFun(bool, ...);       

template <class _Src, class _Dst>
struct _Copyable {
  static _Src* __null_src();
  static _Dst* __null_dst();
  enum { _Ret = (sizeof(_IsCopyableFun(false, __null_src(), __null_src(), __null_dst())) == sizeof(char)) };
  typedef typename __bool2type<_Ret>::_Ret _RetT;
};










#line 187 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"






#line 194 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"








template <class _Src, class _Dst>
struct _AreCopyable {
  enum { _Same = _Copyable<_Src, _Dst>::_Ret };
  typedef typename _Copyable<_Src, _Dst>::_RetT _Ret;
};

template <class _Tp1, class _Tp2>
struct _AreSameTypes {
  enum { _Same = 0 };
  typedef __false_type _Ret;
};


template <class _Tp>
struct _AreSameTypes<_Tp, _Tp> {
  enum { _Same = 1 };
  typedef __true_type _Ret;
};
#line 221 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"


template <class _Src, class _Dst>
struct _ConversionHelper {
  static char _Test(bool, _Dst);
  static char* _Test(bool, ...);
  static _Src _MakeSource();
};

template <class _Src, class _Dst>
struct _IsConvertible {
  typedef _ConversionHelper<_Src*, const volatile _Dst*> _H;
  enum { value = (sizeof(char) == sizeof(_H::_Test(false, _H::_MakeSource()))) };
  typedef typename __bool2type<value>::_Ret _Ret;
};
















































#line 285 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"







template <class _Src, class _Dst>
struct _IsCVConvertible {

  typedef _ConversionHelper<_Src, _Dst> _H;
  enum { value = (sizeof(char) == sizeof(_H::_Test(false, _H::_MakeSource()))) };




#line 302 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"
  typedef typename __bool2type<value>::_Ret _Ret;
};













#line 318 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"

}

#line 322 "C:\\Pin35\\extras\\stlport\\include\\stl/type_manips.h"
#line 64 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"







namespace std {






template <class _Tp> struct _IsIntegral
{ typedef __false_type _Ret; };


template<> struct _IsIntegral<bool>
{ typedef __true_type _Ret; };
#line 86 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template<> struct _IsIntegral<char>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<signed char>
{ typedef __true_type _Ret; };
#line 94 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template<> struct _IsIntegral<unsigned char>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<wchar_t>
{ typedef __true_type _Ret; };
#line 102 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template<> struct _IsIntegral<short>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned short>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<int>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned int>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<long>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned long>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<__int64>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned __int64>
{ typedef __true_type _Ret; };
#line 128 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template <class _Tp> struct _IsRational
{ typedef __false_type _Ret; };

template<> struct _IsRational<float>
{ typedef __true_type _Ret; };

template<> struct _IsRational<double>
{ typedef __true_type _Ret; };




#line 142 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"


template <class _Tp> struct __type_traits;
template <class _IsPOD> struct __type_traits_aux {
   typedef __false_type    has_trivial_default_constructor;
   typedef __false_type    has_trivial_copy_constructor;
   typedef __false_type    has_trivial_assignment_operator;
   typedef __false_type    has_trivial_destructor;
   typedef __false_type    is_POD_type;
};

template<>
struct __type_traits_aux<__false_type> {
   typedef __false_type    has_trivial_default_constructor;
   typedef __false_type    has_trivial_copy_constructor;
   typedef __false_type    has_trivial_assignment_operator;
   typedef __false_type    has_trivial_destructor;
   typedef __false_type    is_POD_type;
};

template<>
struct __type_traits_aux<__true_type> {
  typedef __true_type    has_trivial_default_constructor;
  typedef __true_type    has_trivial_copy_constructor;
  typedef __true_type    has_trivial_assignment_operator;
  typedef __true_type    has_trivial_destructor;
  typedef __true_type    is_POD_type;
};

template <class _Tp>
struct _IsRef {
  typedef __false_type _Ret;
};










































#line 218 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template <class _Tp>  struct _IsPtr {
  typedef __false_type _Ret;
};

template <class _Tp>
struct __type_traits {
   typedef __true_type     this_dummy_member_must_be_first;
                   





   















#line 249 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
   typedef typename __bool2type<__has_trivial_constructor(_Tp)>::_Ret has_trivial_default_constructor;
   typedef typename __bool2type<__has_trivial_copy(_Tp)>::_Ret has_trivial_copy_constructor;
   typedef typename __bool2type<__has_trivial_assign(_Tp)>::_Ret has_trivial_assignment_operator;
   typedef typename __bool2type<__has_trivial_destructor(_Tp)>::_Ret has_trivial_destructor;
   typedef typename __bool2type<__is_pod(_Tp)>::_Ret is_POD_type;
#line 255 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
};


template <class _Tp> struct _IsPtr<_Tp*>
{ typedef __true_type _Ret; };
template <class _Tp> struct _IsRef<_Tp&>
{ typedef __true_type _Ret; };

template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<__true_type>
{};
#line 266 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

#line 268 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"













#line 282 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"


template<> struct __type_traits< bool > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const bool > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile bool > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile bool > : __type_traits_aux<__true_type> {};
#line 286 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
template<> struct __type_traits< char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile char > : __type_traits_aux<__true_type> {};

template<> struct __type_traits< signed char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const signed char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile signed char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile signed char > : __type_traits_aux<__true_type> {};
#line 290 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
template<> struct __type_traits< unsigned char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned char > : __type_traits_aux<__true_type> {};

template<> struct __type_traits< wchar_t > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const wchar_t > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile wchar_t > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile wchar_t > : __type_traits_aux<__true_type> {};
#line 294 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template<> struct __type_traits< short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile short > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned short > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile int > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned int > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile long > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned long > : __type_traits_aux<__true_type> {};


template<> struct __type_traits< __int64 > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const __int64 > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile __int64 > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile __int64 > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned __int64 > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned __int64 > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned __int64 > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned __int64 > : __type_traits_aux<__true_type> {};
#line 306 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template<> struct __type_traits< float > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const float > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile float > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile float > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile double > : __type_traits_aux<__true_type> {};



#line 313 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"


template <class _ArePtrs, class _Src, class _Dst>
struct _IsCVConvertibleIf
{ typedef typename _IsCVConvertible<_Src, _Dst>::_Ret _Ret; };

template <class _Src, class _Dst>
struct _IsCVConvertibleIf<__false_type, _Src, _Dst>
{ typedef __false_type _Ret; };




























#line 351 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template <class _Src, class _Dst>
struct _TrivialNativeTypeCopy {
  typedef typename _IsPtr<_Src>::_Ret _Ptr1;
  typedef typename _IsPtr<_Dst>::_Ret _Ptr2;
  typedef typename _Land2<_Ptr1, _Ptr2>::_Ret _BothPtrs;
  typedef typename _IsCVConvertibleIf<_BothPtrs, _Src, _Dst>::_Ret _Convertible;
  typedef typename _Land2<_BothPtrs, _Convertible>::_Ret _Trivial1;

  typedef typename __bool2type<(sizeof(_Src) == sizeof(_Dst))>::_Ret _SameSize;


  typedef typename _IsIntegral<_Src>::_Ret _Int1;



#line 368 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
  typedef typename _IsIntegral<_Dst>::_Ret _Int2;
  typedef typename _Land2<_Int1, _Int2>::_Ret _BothInts;

  typedef typename _IsRational<_Src>::_Ret _Rat1;
  typedef typename _IsRational<_Dst>::_Ret _Rat2;
  typedef typename _Land2<_Rat1, _Rat2>::_Ret _BothRats;

  typedef typename _Lor2<_BothInts, _BothRats>::_Ret _BothNatives;

  typedef typename _Land2<_BothNatives, _SameSize>::_Ret _Trivial2;



#line 382 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
  typedef typename _Lor2<_Trivial1, _Trivial2>::_Ret _Ret;
};

template <class _Src, class _Dst>
struct _TrivialCopy {
  typedef typename _TrivialNativeTypeCopy<_Src, _Dst>::_Ret _NativeRet;

  typedef typename __type_traits<_Src>::has_trivial_assignment_operator _Tr1;



#line 394 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
  typedef typename _AreCopyable<_Src, _Dst>::_Ret _Tr2;
  typedef typename _Land2<_Tr1, _Tr2>::_Ret _UserRet;
  typedef typename _Lor2<_NativeRet, _UserRet>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Src, class _Dst>
struct _TrivialUCopy {
  typedef typename _TrivialNativeTypeCopy<_Src, _Dst>::_Ret _NativeRet;

  typedef typename __type_traits<_Src>::has_trivial_copy_constructor _Tr1;



#line 409 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
  typedef typename _AreCopyable<_Src, _Dst>::_Ret _Tr2;
  typedef typename _Land2<_Tr1, _Tr2>::_Ret _UserRet;
  typedef typename _Lor2<_NativeRet, _UserRet>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Tp>
struct _DefaultZeroValue {
  typedef typename _IsIntegral<_Tp>::_Ret _Tr1;
  typedef typename _IsRational<_Tp>::_Ret _Tr2;
  typedef typename _IsPtr<_Tp>::_Ret _Tr3;
  typedef typename _Lor3<_Tr1, _Tr2, _Tr3>::_Ret _Ret;
};

template <class _Tp>
struct _TrivialInit {

  typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Tr1;



#line 431 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
  typedef typename _DefaultZeroValue<_Tp>::_Ret _Tr2;
  typedef typename _Not<_Tr2>::_Ret _Tr3;
  typedef typename _Land2<_Tr1, _Tr3>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

#line 438 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template <class _Tp>
struct _IsPtrType {
  typedef typename _IsPtr<_Tp>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
struct _IsRefType {
  typedef typename _IsRef<_Tp>::_Ret _Type;
  static _Type _Ret() { return _Type();}
};

template <class _Tp>
struct __call_traits {







#line 461 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
  typedef const _Tp& const_param_type;
  typedef _Tp& param_type;
#line 464 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
};


template <class _Tp>
struct __call_traits<_Tp&> {
  typedef _Tp& param_type;
  typedef const _Tp& const_param_type;
};
template <class _Tp>
struct __call_traits<const _Tp&> {
  typedef _Tp& param_type;
  typedef const _Tp& const_param_type;
};
#line 478 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template <class _Tp1, class _Tp2>
struct _BothPtrType {
  typedef typename _IsPtr<_Tp1>::_Ret _IsPtr1;
  typedef typename _IsPtr<_Tp2>::_Ret _IsPtr2;

  typedef typename _Land2<_IsPtr1, _IsPtr2>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Tp1, class _Tp2, class _IsRef1, class _IsRef2>
struct _OKToSwap {
  typedef typename _AreSameTypes<_Tp1, _Tp2>::_Ret _Same;
  typedef typename _Land3<_Same, _IsRef1, _IsRef2>::_Ret _Type;
  static _Type _Answer() { return _Type(); }
};

template <class _Tp1, class _Tp2, class _IsRef1, class _IsRef2>
inline _OKToSwap<_Tp1, _Tp2, _IsRef1, _IsRef2>
_IsOKToSwap(_Tp1*, _Tp2*, const _IsRef1&, const _IsRef2&)
{ return _OKToSwap<_Tp1, _Tp2, _IsRef1, _IsRef2>(); }

template <class _Src, class _Dst>
inline _TrivialCopy<_Src, _Dst> _UseTrivialCopy(_Src*, _Dst*)
{ return _TrivialCopy<_Src, _Dst>(); }

template <class _Src, class _Dst>
inline _TrivialUCopy<_Src, _Dst> _UseTrivialUCopy(_Src*, _Dst*)
{ return _TrivialUCopy<_Src, _Dst>(); }


struct _NegativeAnswer {
  typedef __false_type _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialCopy(_Src*, const _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialCopy(_Src*, volatile _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialCopy(_Src*, const volatile _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialUCopy(_Src*, const _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialUCopy(_Src*, volatile _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialUCopy(_Src*, const volatile _Dst*)
{ return _NegativeAnswer(); }
#line 539 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template <class _Tp>
inline _TrivialInit<_Tp> _UseTrivialInit(_Tp*)
{ return _TrivialInit<_Tp>(); }

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Answer() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD(_Tp*)
{ return _IsPOD<_Tp>(); }

template <class _Tp>
struct _DefaultZeroValueQuestion {
  typedef typename _DefaultZeroValue<_Tp>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Tp>
inline _DefaultZeroValueQuestion<_Tp> _HasDefaultZeroValue(_Tp*)
{ return _DefaultZeroValueQuestion<_Tp>(); }







template <class _Tp>
struct __stlport_class
{ typedef _Tp _Type; };

template <class _Tp>
struct _IsSTLportClass {
  typedef typename _IsConvertible<_Tp, __stlport_class<_Tp> >::_Ret _Ret;


#line 580 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"
};









#line 591 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

template <class _Tp>
class _TpWithState : private _Tp {
  _TpWithState();
  int _state;
};



template <class _Tp>
struct _IsStateless {
  enum { _Is = sizeof(_TpWithState<_Tp>) == sizeof(int) };
  typedef typename __bool2type<_Is>::_Ret _Ret;
};

}




#line 616 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

#line 618 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"


#line 621 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"

#line 623 "C:\\Pin35\\extras\\stlport\\include\\stl/type_traits.h"




#line 37 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"























namespace std {









template <class _Tp>
class __move_source {
public:
  explicit __move_source (_Tp &_src) : _M_data(_src)
  {}

  _Tp& get() const
  { return _M_data; }
private:
  _Tp &_M_data;

  
  typedef __move_source<_Tp> _Self;
  _Self& operator = (_Self const&);
};


template <class _Tp>
struct __move_traits {
  






#line 63 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"
  typedef __false_type implemented;
#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"
  






#line 73 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"
  typedef typename __type_traits<_Tp>::has_trivial_destructor complete;
#line 75 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"
};

namespace priv {







template <class _Tp>
struct _MoveSourceTraits {
  typedef typename __move_traits<_Tp>::implemented _MvImpRet;


#line 91 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"
  enum {_MvImp = __type2bool<_MvImpRet>::_Ret};
  typedef typename __select<_MvImp,
#line 94 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"
                            __move_source<_Tp>,
                            _Tp const&>::_Ret _Type;
};


template <class _Tp>
inline typename _MoveSourceTraits<_Tp>::_Type
_AsMoveSource (_Tp &src) {
  typedef typename _MoveSourceTraits<_Tp>::_Type _SrcType;
  return _SrcType(src);
}


template <class _Tp>
struct __move_traits_aux {
  typedef typename __move_traits<_Tp>::implemented implemented;
  typedef typename __move_traits<_Tp>::complete complete;
};

template <class _Tp1, class _Tp2>
struct __move_traits_aux2 {
  typedef __move_traits<_Tp1> _MoveTraits1;
  typedef __move_traits<_Tp2> _MoveTraits2;

  typedef typename _Lor2<typename _MoveTraits1::implemented,
                         typename _MoveTraits2::implemented>::_Ret implemented;
  typedef typename _Land2<typename _MoveTraits1::complete,
                          typename _MoveTraits2::complete>::_Ret complete;
};





template <class _Tp>
struct __move_traits_help {
  typedef __true_type implemented;
  typedef typename __move_traits<_Tp>::complete complete;
};

template <class _Tp1, class _Tp2>
struct __move_traits_help1 {
  typedef __move_traits<_Tp1> _MoveTraits1;
  typedef __move_traits<_Tp2> _MoveTraits2;

  typedef typename _Lor2<typename _MoveTraits1::implemented,
                         typename _MoveTraits2::implemented>::_Ret implemented;
  typedef typename _Land2<typename _MoveTraits1::complete,
                          typename _MoveTraits2::complete>::_Ret complete;
};

template <class _Tp1, class _Tp2>
struct __move_traits_help2 {
  typedef __move_traits<_Tp1> _MoveTraits1;
  typedef __move_traits<_Tp2> _MoveTraits2;

  typedef __true_type implemented;
  typedef typename _Land2<typename _MoveTraits1::complete,
                          typename _MoveTraits2::complete>::_Ret complete;
};

}

}

#line 160 "C:\\Pin35\\extras\\stlport\\include\\stl/_move_construct_fwk.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"
#line 42 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"
#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"

namespace std {




#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"
template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;


#line 60 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"
  pair() : first(_T1()), second(_T2()) {}
#line 62 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"
  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}
#line 70 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"


  pair(__move_source<pair<_T1, _T2> > src) : first(::std::priv:: _AsMoveSource(src.get().first)),
                                             second(::std::priv:: _AsMoveSource(src.get().second))
  {}
#line 76 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"

  
};

template <class _T1, class _T2>
inline bool __cdecl operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return __x.first == __y.first && __x.second == __y.second; }

template <class _T1, class _T2>
inline bool __cdecl operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}


template <class _T1, class _T2>
inline bool __cdecl operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return !(__x == __y); }

template <class _T1, class _T2>
inline bool __cdecl operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return __y < __x; }

template <class _T1, class _T2>
inline bool __cdecl operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return !(__y < __x); }

template <class _T1, class _T2>
inline bool __cdecl operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return !(__x < __y); }
#line 107 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"


template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{ return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y)); }

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{ return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y); }

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2]) {
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}
#line 126 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"

template <class _T1, class _T2>
inline pair<_T1, _T2> __cdecl make_pair(_T1 __x, _T2 __y)
{ return pair<_T1, _T2>(__x, __y); }

}


namespace std { namespace rel_ops {

template <class _Tp>
inline bool __cdecl operator!=(const _Tp& __x, const _Tp& __y)
{ return !(__x == __y); }

template <class _Tp>
inline bool __cdecl operator>(const _Tp& __x, const _Tp& __y)
{ return __y < __x; }

template <class _Tp>
inline bool __cdecl operator<=(const _Tp& __x, const _Tp& __y)
{ return !(__y < __x); }

template <class _Tp>
inline bool __cdecl  operator>=(const _Tp& __x, const _Tp& __y)
{ return !(__x < __y); }

} }
#line 154 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"


namespace std {

template <class _T1, class _T2>
struct __type_traits<pair<_T1, _T2> > {
  typedef __type_traits<_T1> _T1Traits;
  typedef __type_traits<_T2> _T2Traits;
  typedef typename _Land2<typename _T1Traits::has_trivial_default_constructor,
                          typename _T2Traits::has_trivial_default_constructor>::_Ret has_trivial_default_constructor;
  typedef typename _Land2<typename _T1Traits::has_trivial_copy_constructor,
                          typename _T2Traits::has_trivial_copy_constructor>::_Ret has_trivial_copy_constructor;
  typedef typename _Land2<typename _T1Traits::has_trivial_assignment_operator,
                          typename _T2Traits::has_trivial_assignment_operator>::_Ret has_trivial_assignment_operator;
  typedef typename _Land2<typename _T1Traits::has_trivial_destructor,
                          typename _T2Traits::has_trivial_destructor>::_Ret has_trivial_destructor;
  typedef __false_type is_POD_type;
};


template <class _T1, class _T2>
struct __move_traits<pair<_T1, _T2> >
  : ::std::priv:: __move_traits_help1<_T1, _T2> {};
#line 178 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"

}
#line 181 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"

#line 183 "C:\\Pin35\\extras\\stlport\\include\\stl/_pair.h"




#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"














































#line 48 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"

namespace std {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category  iterator_category;
  typedef _Tp        value_type;
  typedef _Distance  difference_type;
  typedef _Pointer   pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag  iterator_category;

  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;
#line 75 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"
};








#line 85 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"





#line 92 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"

#line 94 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"






#line 101 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"
#line 102 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"











































#line 146 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
#line 150 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"
  typedef typename _Iterator::value_type        value_type;
  typedef typename _Iterator::difference_type   difference_type;
  typedef typename _Iterator::pointer           pointer;
  typedef typename _Iterator::reference         reference;
};





#line 161 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"




template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag  iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef const _Tp*                  pointer;
  typedef const _Tp&                  reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag  iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef _Tp*                        pointer;
  typedef _Tp&                        reference;
};










#line 193 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"

#line 195 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"

}
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ptrs_specialize.h"
















































































#line 83 "C:\\Pin35\\extras\\stlport\\include\\stl/_ptrs_specialize.h"
#line 84 "C:\\Pin35\\extras\\stlport\\include\\stl/_ptrs_specialize.h"
#line 198 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"
namespace std {





























































#line 261 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"






template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
































#line 309 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"
#line 310 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"

namespace priv {

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type __cdecl
__distance(const _InputIterator& __first, const _InputIterator& __last,
           const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}

























#line 350 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"

template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type __cdecl
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &)
{ return __last - __first; }

}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type __cdecl
distance(_InputIterator __first, _InputIterator __last)
{ return ::std::priv:: __distance(__first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }


template <class _InputIterator, class _Distance>
inline void __cdecl distance(const _InputIterator& __first,
                                const _InputIterator& __last, _Distance& __n)
{ __n += ::std::distance(__first, __last); }



template <class _InputIterator, class _Dist>
inline void  __cdecl _Distance(_InputIterator __first,
                                  _InputIterator __last, _Dist& __n)
{ __n += ::std::distance(__first, __last); }
#line 377 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"
#line 378 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"


template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp&  reference;
  typedef const _Tp*  pointer;
  typedef _Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_traits<_Tp> _NonConstTraits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_traits<_Tp> _NonConstTraits;
};





template <class _Tp>
struct _Nonconst_Const_traits;

template <class _Tp>
struct _Const_Const_traits {
  typedef _Tp value_type;
  typedef const _Tp&  reference;
  typedef const _Tp*  pointer;
  typedef _Const_Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_Const_traits<_Tp> _NonConstTraits;
};

template <class _Tp>
struct _Nonconst_Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Const_Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_Const_traits<_Tp> _NonConstTraits;
};



















































namespace priv {

template <class _InputIter, class _Distance>
inline void __cdecl
__advance(_InputIter& __i, _Distance __n, const input_iterator_tag &)
{ while (__n--) ++__i; }


template <class _InputIter, class _Distance>
inline void __cdecl
__advance(_InputIter& __i, _Distance __n, const output_iterator_tag &)
{ while (__n--) ++__i; }






#line 495 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"

template <class _BidirectionalIterator, class _Distance>
inline void __cdecl
__advance(_BidirectionalIterator& __i, _Distance __n,
          const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void __cdecl
__advance(_RandomAccessIterator& __i, _Distance __n,
          const random_access_iterator_tag &)
{ __i += __n; }

}

template <class _InputIterator, class _Distance>
inline void __cdecl advance(_InputIterator& __i, _Distance __n)
{ ::std::priv:: __advance(__i, __n, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }

}

#line 521 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator_base.h"





#line 55 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
#line 56 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"





namespace std {















#line 78 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"


template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {








#line 91 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;
#line 95 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
}

namespace priv {

template <class _ForwardIter1, class _ForwardIter2, class _Value>
inline void __iter_swap_aux_aux(_ForwardIter1& __i1, _ForwardIter2& __i2, _Value *) {
  _Value tmp = *__i1;
  *__i1 = *__i2;
  *__i2 = tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void __iter_swap_aux(_ForwardIter1& __i1, _ForwardIter2& __i2, const __true_type& ) {
  
   swap(*__i1, *__i2);
}

template <class _ForwardIter1, class _ForwardIter2>
inline void __iter_swap_aux(_ForwardIter1& __i1, _ForwardIter2& __i2, const __false_type& ) {
  ::std::priv:: __iter_swap_aux_aux( __i1, __i2, (typename ::std::iterator_traits< _ForwardIter1 >::value_type*)0 );
}

}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  ::std::priv:: __iter_swap_aux( __i1, __i2, _IsOKToSwap((typename ::std::iterator_traits< _ForwardIter1 >::value_type*)0, (typename ::std::iterator_traits< _ForwardIter2 >::value_type*)0,
                                                      ::std::_IsRefType< typename ::std::iterator_traits< _ForwardIter1 >::reference >::_Ret(),
                                                      ::std::_IsRefType< typename ::std::iterator_traits< _ForwardIter2 >::reference >::_Ret())._Answer());
}












#line 138 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) {  return  __a < __b ? __b : __a; }
#line 143 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
#line 144 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"




#line 149 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"


template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}










#line 171 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"










namespace priv {

template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result, const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}

















#line 208 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"

template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  size_t __n = (const char*)__last - (const char*)__first;
  return __n ? (void *)((char*)memmove(__result, __first, __n) + __n) : __result;
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*) {
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __false_type& ) {
  return ::std::priv:: __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __true_type& ) {
  
  
  return (_OutputIter)::std::priv:: __copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                              const __true_type& ) {
  return ::std::priv:: __copy_ptrs(__first, __last, __result,
                                _UseTrivialCopy((typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                                (typename ::std::iterator_traits< _OutputIter >::value_type*)0)._Answer());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                              const __false_type& ) {
  return ::std::priv:: __copy(__first, __last, __result,
                           typename ::std::iterator_traits< _InputIter >::iterator_category(),
                           (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}

}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
  
  return ::std::priv:: __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter>::_Answer());
}

namespace priv {

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last,
                                        _OutputIter __result, const __false_type& ) {
  return ::std::priv:: __copy_backward(__first, __last, __result,
                                    typename ::std::iterator_traits< _InputIter >::iterator_category(),
                                    (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last,
                                        _OutputIter __result, const __true_type& ) {
  return (_OutputIter)::std::priv:: __copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return ::std::priv:: __copy_backward(__first, __last, __result,
                                    typename ::std::iterator_traits< _InputIter >::iterator_category(),
                                    (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return ::std::priv:: __copy_backward_ptrs(__first, __last, __result,
                                         _UseTrivialCopy((typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                                         (typename ::std::iterator_traits< _OutputIter >::value_type*)0)._Answer());
}

}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
  
  return ::std::priv:: __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter>::_Answer() );
}



































#line 368 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"





namespace priv {

template <class _InputIter, class _Size, class _OutputIter>
inline ::std::pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result,
         const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return ::std::pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline ::std::pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count, _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return ::std::pair<_RAIter, _OutputIter>(__last, ::std::copy(__first, __last, __result));
}

}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
  
  return ::std::priv:: __copy_n(__first, __count, __result, typename ::std::iterator_traits< _InputIter >::iterator_category());
}
#line 404 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"



namespace priv {

template <class _ForwardIter, class _Tp>
inline
void __fill_fwd(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _ForwardIter, class _Tp, class _Distance>
inline void __fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                   const input_iterator_tag &, _Distance*) {
  ::std::priv:: __fill_fwd(__first, __last, __val);
}















#line 437 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"

template <class _RandomAccessIter, class _Tp, class _Distance>
inline
void __fill(_RandomAccessIter __first, _RandomAccessIter __last, const _Tp& __val,
            const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first ; __n > 0; ++__first, --__n)
    *__first = __val;
}

}

template <class _ForwardIter, class _Tp>
inline void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
  
  ::std::priv:: __fill(__first, __last, __val,
                    typename ::std::iterator_traits< _ForwardIter >::iterator_category(),
                    (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}


inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}
#line 469 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

namespace priv {

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter __fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
  
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}


template <class _Size>
inline unsigned char* __fill_n(unsigned char* __first, _Size __n,
                               const unsigned char& __val) {
  ::std::fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* __fill_n(signed char* __first, _Size __n,
                             const signed char& __val) {
  ::std::fill(__first, __first + __n, __val);
  return __first + __n;
}
#line 500 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
template <class _Size>
inline char* __fill_n(char* __first, _Size __n,
                      const char& __val) {
  ::std::fill(__first, __first + __n, __val);
  return __first + __n;
}
#line 507 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"

}

template <class _OutputIter, class _Size, class _Tp>
inline void fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
  
  ::std::priv:: __fill_n(__first, __n, __val);
}





template <class _InputIter1, class _InputIter2>
inline
::std::pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                   _InputIter1 __last1,
                                                   _InputIter2 __first2) {
  
  
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return ::std::pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
::std::pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                   _InputIter1 __last1,
                                                   _InputIter2 __first2,
                                                   _BinaryPredicate __binary_pred) {
  
  
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return ::std::pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
           _InputIter2 __first2) {
     
  
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
           _InputIter2 __first2, _BinaryPredicate __binary_pred) {
  
  
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2) {
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
  
  

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}













#line 613 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"

namespace priv {

template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2) {
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}











#line 643 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"

}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);

#line 652 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"


template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
  
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred  __predicate);

namespace priv {


template <class _InputIter, class _ForwardIter>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2);

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

}

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
  
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                           const _Tp& __val, _Compare1 __comp1, _Compare2 __comp2, _Distance*);

}

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"
































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"


































#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"

namespace std {

template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;

protected:
  


  ~unary_function() {}
#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;

protected:
  
  ~binary_function() {}
#line 62 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"
};

template <class _Tp>
struct equal_to : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>





              , public __stlport_class<less<_Tp> >
#line 78 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }



#line 84 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"
};


template <class _Tp>
struct __type_traits<less<_Tp> > {

  typedef typename _IsSTLportClass<less<_Tp> >::_Ret _STLportLess;



#line 95 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"
  typedef _STLportLess has_trivial_default_constructor;
  typedef _STLportLess has_trivial_copy_constructor;
  typedef _STLportLess has_trivial_assignment_operator;
  typedef _STLportLess has_trivial_destructor;
  typedef _STLportLess is_POD_type;
};
#line 102 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"

namespace priv {

template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

}

template <class _Tp>
struct plus : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

template <class _Tp>
struct minus : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

namespace priv {

template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

}

template <class _Tp>
struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

namespace priv {

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};


template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};









#line 174 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"

#line 176 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"

template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef  _Result  result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef  _Arg1   first_argument_type;
  typedef  _Arg2   second_argument_type;
  typedef  _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};


template <class _Tp> inline _Tp __identity_element(plus<_Tp>) {  return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

}

}

#line 214 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_base.h"




#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"

namespace std {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
  
  
  for ( ; __first1 != __last1 && __first2 != __last2
        ; ++__first1, ++__first2) {
    if (*__first1 < *__first2) {
      
      return true;
    }
    if (*__first2 < *__first1)
      return false;
  }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
  
  
  for ( ; __first1 != __last1 && __first2 != __last2
        ; ++__first1, ++__first2) {
    if (__comp(*__first1, *__first2)) {
      
#line 66 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"
      return true;
    }
    if (__comp(*__first2, *__first1))
      return false;
  }
  return __first1 == __last1 && __first2 != __last2;
}


namespace priv {

template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2) {
      
      return -1;
    }
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}

}

template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2) {
  
  
  return ::std::priv:: __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}
#line 108 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"

namespace priv {

template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &) {
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch (__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;
    
  case 0:
  default:
    return __last;
  }
}

inline char*
__find(char* __first, char* __last, char __val, const random_access_iterator_tag &) {
  void *res =  memchr(__first, __val, __last - __first);
  return res != 0 ? static_cast<char*>(res) : __last;
}
inline const char*
__find(const char* __first, const char* __last, char __val, const random_access_iterator_tag &) {
  const void *res =  memchr(__first, __val, __last - __first);
  return res != 0 ? static_cast<const char*>(res) : __last;
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &) {
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;
      
  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
                                    const _Tp& __val,
                                    const input_iterator_tag &) {
  while (__first != __last && !(*__first == __val)) ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                                       _Predicate __pred,
                                       const input_iterator_tag &) {
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
  
  return ::std::priv:: __find_if(__first, __last, __pred, typename ::std::iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val) {
  
  return ::std::priv:: __find(__first, __last, __val, typename ::std::iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred  __pred) {
  
  
  
  if (__first1 == __last1 || __first2 == __last2)
    return __first1;

  
  _ForwardIter2 __p1(__first2);

  if ( ++__p1 == __last2 ) {
    while (__first1 != __last1 && !__pred(*__first1, *__first2)) {
      ++__first1;
    }
    return __first1;
  }

  

  for ( ; ; ) { 
    while (__first1 != __last1 && !__pred(*__first1, *__first2)) {
      ++__first1;
    }
    if (__first1 == __last1) {
      return __last1;
    }
    _ForwardIter2 __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__pred(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }
    ++__first1;
  }
  return __first1;
}

namespace priv {
template <class _Tp>
struct _IsCharLikeType
{ typedef __false_type _Ret; };

template<> struct _IsCharLikeType<char>
{ typedef __true_type _Ret; };

template<> struct _IsCharLikeType<unsigned char>
{ typedef __true_type _Ret; };


template<> struct _IsCharLikeType<signed char>
{ typedef __true_type _Ret; };
#line 285 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"

template <class _Tp1, class _Tp2>
inline bool __stlp_eq(_Tp1 __val1, _Tp2 __val2)
{ return __val1 == __val2; }


template <class _Tp>
inline bool __stlp_eq(_Tp, _Tp)
{ return true; }
#line 295 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"

template <class _InputIter, class _ForwardIter, class _Tp2, class _Predicate>
inline _InputIter __find_first_of_aux2(_InputIter __first1, _InputIter __last1,
                                       _ForwardIter __first2, _ForwardIter __last2,
                                       _Tp2*, _Predicate __pred,
                                       const __true_type& ) {
  unsigned char __hints[(0xffU + 1) / 8];
  memset(__hints, 0, sizeof(__hints) / sizeof(unsigned char));
  for (; __first2 != __last2; ++__first2) {
    unsigned char __tmp = (unsigned char)*__first2;
    __hints[__tmp / 8] |= (1 << (__tmp % 8));
  }

  for (; __first1 != __last1; ++__first1) {
    _Tp2 __tmp = (_Tp2)*__first1;
    if (__stlp_eq(*__first1, __tmp) &&
        __pred((__hints[(unsigned char)__tmp / 8] & (1 << ((unsigned char)__tmp % 8))) != 0))
      break;
  }
  return __first1;
}

template <class _InputIter, class _ForwardIter, class _Tp2, class _Predicate>
inline _InputIter __find_first_of_aux2(_InputIter __first1, _InputIter __last1,
                                       _ForwardIter __first2, _ForwardIter __last2,
                                       _Tp2* , _Predicate ,
                                       const __false_type& ) {
  return ::std::priv:: __find_first_of(__first1, __last1, __first2, __last2,
                                    ::std::priv:: __equal_to((typename ::std::iterator_traits< _InputIter >::value_type*)0));
}

template <class _InputIter, class _ForwardIter, class _Tp1, class _Tp2>
inline _InputIter __find_first_of_aux1(_InputIter __first1, _InputIter __last1,
                                       _ForwardIter __first2, _ForwardIter __last2,
                                       _Tp1* __pt1, _Tp2* __pt2) {
  typedef typename ::std::_IsIntegral<_Tp1>::_Ret _IsIntegral;
  typedef typename ::std::priv:: _IsCharLikeType<_Tp2>::_Ret _IsCharLike;
  typedef typename ::std::_Land2<_IsIntegral, _IsCharLike>::_Ret _UseStrcspnLikeAlgo;
  return ::std::priv:: __find_first_of_aux2(__first1, __last1,
                                         __first2, __last2,
                                         __pt2, _Identity<bool>(), _UseStrcspnLikeAlgo());
}

template <class _InputIter, class _ForwardIter>
inline _InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                                  _ForwardIter __first2, _ForwardIter __last2) {
  return ::std::priv:: __find_first_of_aux1(__first1, __last1, __first2, __last2,
                                         (typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                         (typename ::std::iterator_traits< _ForwardIter >::value_type*)0);
}


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1) {
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter) {
      if (__comp(*__first1, *__iter)) {
        return __first1;
      }
    }
  }
  return __last1;
}







template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp) {
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    for (;;) {
      _ForwardIter1 __new_result = ::std::search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}

}





}
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"




































namespace std {








template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference> {
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;
  
  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }
#line 73 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"

  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const { return _Self(current - __n); }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const { return _Self(current + __n); }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool  __cdecl operator==(const reverse_iterator<_Iterator>& __x,
                                   const reverse_iterator<_Iterator>& __y)
{ return __x.base() == __y.base(); }

template <class _Iterator>
inline bool __cdecl operator<(const reverse_iterator<_Iterator>& __x,
                                 const reverse_iterator<_Iterator>& __y)
{ return __y.base() < __x.base(); }


template <class _Iterator>
inline bool __cdecl operator!=(const reverse_iterator<_Iterator>& __x,
                                  const reverse_iterator<_Iterator>& __y)
{ return !(__x == __y); }

template <class _Iterator>
inline bool __cdecl operator>(const reverse_iterator<_Iterator>& __x,
                                 const reverse_iterator<_Iterator>& __y)
{ return __y < __x; }

template <class _Iterator>
inline bool __cdecl operator<=(const reverse_iterator<_Iterator>& __x,
                                  const reverse_iterator<_Iterator>& __y)
{ return !(__y < __x); }

template <class _Iterator>
inline bool __cdecl operator>=(const reverse_iterator<_Iterator>& __x,
                                  const reverse_iterator<_Iterator>& __y)
{ return !(__x < __y); }
#line 143 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"


template<typename _IteratorL, typename _IteratorR>
inline bool __cdecl operator==(const reverse_iterator<_IteratorL>& __x,
                                  const reverse_iterator<_IteratorR>& __y)
{ return __x.base() == __y.base(); }

template<typename _IteratorL, typename _IteratorR>
inline bool __cdecl operator<(const reverse_iterator<_IteratorL>& __x,
                                 const reverse_iterator<_IteratorR>& __y)
{ return __y.base() < __x.base(); }

template<typename _IteratorL, typename _IteratorR>
inline bool __cdecl operator!=(const reverse_iterator<_IteratorL>& __x,
                                  const reverse_iterator<_IteratorR>& __y)
{ return !(__x == __y); }

template<typename _IteratorL, typename _IteratorR>
inline bool __cdecl operator>(const reverse_iterator<_IteratorL>& __x,
                                 const reverse_iterator<_IteratorR>& __y)
{ return __y < __x; }

template<typename _IteratorL, typename _IteratorR>
inline bool __cdecl operator<=(const reverse_iterator<_IteratorL>& __x,
                                  const reverse_iterator<_IteratorR>& __y)
{ return !(__y < __x); }

template<typename _IteratorL, typename _IteratorR>
inline bool __cdecl operator>=(const reverse_iterator<_IteratorL>& __x,
                                  const reverse_iterator<_IteratorR>& __y)
{ return !(__x < __y); }

template <class _Iterator>


#line 179 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"
inline typename reverse_iterator<_Iterator>::difference_type __cdecl
#line 181 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"
operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y)
{ return __y.base() - __x.base(); }

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>  __cdecl
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x)
{ return x.operator+(n); }
#line 190 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"

template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag, void, void, void, void> {
  typedef back_insert_iterator<_Container> _Self;
protected:
  
  _Container *container;
public:
  typedef _Container          container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}

  _Self& operator=(const _Self& __other) {
    container = __other.container;
    return *this;
  }
  _Self& operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  _Self& operator*() { return *this; }
  _Self& operator++() { return *this; }
  _Self  operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container>  __cdecl back_inserter(_Container& __x)
{ return back_insert_iterator<_Container>(__x); }

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag, void, void, void, void> {
  typedef front_insert_iterator<_Container> _Self;
protected:
  
  _Container *container;
public:
  typedef _Container          container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}

  _Self& operator=(const _Self& __other) {
    container = __other.container;
    return *this;
  }
  _Self& operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  _Self& operator*() { return *this; }
  _Self& operator++() { return *this; }
  _Self  operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container>  __cdecl front_inserter(_Container& __x)
{ return front_insert_iterator<_Container>(__x); }

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag, void, void, void, void> {
  typedef insert_iterator<_Container> _Self;
protected:
  
  _Container *container;
  typename _Container::iterator _M_iter;
public:
  typedef _Container          container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), _M_iter(__i) {}

  _Self& operator=(_Self const& __other) {
    container = __other.container;
    _M_iter = __other._M_iter;
    return *this;
  }
  _Self& operator=(const typename _Container::value_type& __val) {
    _M_iter = container->insert(_M_iter, __val);
    ++_M_iter;
    return *this;
  }
  _Self& operator*() { return *this; }
  _Self& operator++() { return *this; }
  _Self& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>  __cdecl
inserter(_Container& __x, _Iterator __i) {
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}



#line 291 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"

#line 293 "C:\\Pin35\\extras\\stlport\\include\\stl/_iterator.h"




#line 398 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"
namespace std {
#line 400 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"

namespace priv {

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp) {
  typedef ::std::reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef ::std::reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = ::std::search(_RevIter1(__last1), __rlast1,
                                          _RevIter2(__last2), __rlast2,
                                          __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    ::std::advance(__result, -::std::distance(__first2, __last2));
    return __result;
  }
}

}
#line 430 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp) {
  
  
  return ::std::priv:: __find_end(__first1, __last1, __first2, __last2,

                               typename ::std::iterator_traits< _ForwardIter1 >::iterator_category(),
                               typename ::std::iterator_traits< _ForwardIter2 >::iterator_category(),



#line 447 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"
                               __comp);
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                           _Compare1 __comp1, _Compare2 __comp2, _Distance*) {
  _Distance __len = ::std::distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    ::std::advance(__middle, __half);
    if (__comp1(*__middle, __val)) {
      
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}

}

#line 480 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.c"




#line 721 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"
#line 722 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"

#line 724 "C:\\Pin35\\extras\\stlport\\include\\stl/_algobase.h"





#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"



























#line 29 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"






#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"






#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"



#line 47 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"
#line 1 "C:\\Pin35\\extras\\libstdc++/include/new"




#line 1 "C:\\Pin35\\extras\\stlport\\include\\cstddef"



























#line 29 "C:\\Pin35\\extras\\stlport\\include\\cstddef"




#line 34 "C:\\Pin35\\extras\\stlport\\include\\cstddef"
#line 1 "C:\\Pin35\\extras\\libstdc++/include/cstddef"






































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 40 "C:\\Pin35\\extras\\libstdc++/include/cstddef"

extern "C++" {

namespace std {
using ::ptrdiff_t;
using ::size_t;
}  

}  

#line 51 "C:\\Pin35\\extras\\libstdc++/include/cstddef"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\cstddef"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\cstddef"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\cstddef"




#line 42 "C:\\Pin35\\extras\\stlport\\include\\cstddef"

#line 44 "C:\\Pin35\\extras\\stlport\\include\\cstddef"




#line 6 "C:\\Pin35\\extras\\libstdc++/include/new"

extern "C++" {

namespace std {
    struct nothrow_t {};
    extern const nothrow_t nothrow;
}

void* operator new(std::size_t);
void* operator new[](std::size_t);
void  operator delete(void*) throw();
void  operator delete[](void*) throw();
void  operator delete(void*, std::size_t) throw();
void  operator delete[](void*, std::size_t) throw();
void* operator new(std::size_t, const std::nothrow_t&);
void* operator new[](std::size_t, const std::nothrow_t&);
void  operator delete(void*, const std::nothrow_t&) throw();
void  operator delete[](void*, const std::nothrow_t&) throw();

inline void* operator new(std::size_t, void* p) { return p; }
inline void* operator new[](std::size_t, void* p) { return p; }


inline void  operator delete(void*, void*) throw() { }
inline void  operator delete[](void*, void*) throw() { }

}  

#line 35 "C:\\Pin35\\extras\\libstdc++/include/new"
#line 48 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"
#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"


#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"



#line 56 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"






























#line 87 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"






















#line 110 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"




#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"







#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


























#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


#line 35 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdio.h"


























































































































































































































































































































































































































































































#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 41 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"





#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"








#line 56 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"

#line 58 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"




#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"


namespace std {
using ::FILE;
using ::fpos_t;
using ::size_t;










using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;

using ::freopen;
#line 82 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;



 using ::getc;
 using ::putc;
#line 93 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
 using ::getchar;
 using ::putchar;
#line 96 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"

using ::gets;

using ::perror;
#line 101 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
using ::printf;
using ::puts;

using ::remove;
using ::rename;
using ::rewind;
using ::setbuf;
using ::tmpfile;
using ::tmpnam;
#line 111 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
using ::scanf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;


#line 123 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
#line 124 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
}
#line 126 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"

#line 128 "C:\\Pin35\\extras\\stlport\\include\\stl/_cstdio.h"
#line 115 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"
#line 116 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"



#line 120 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"
#line 121 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"



#line 125 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"

#line 127 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"

namespace std {




#line 134 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"
inline void* __cdecl __stl_new(size_t __n)   { return ::operator new(__n); }
inline void  __cdecl __stl_delete(void* __p) { ::operator delete(__p); }
#line 137 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"
}

#line 140 "C:\\Pin35\\extras\\stlport\\include\\stl/_new.h"






#line 48 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"


































#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"















#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"

namespace std {

template <class _Tp>
inline void __destroy_aux(_Tp* __pointer, const __false_type& )
{ __pointer->~_Tp(); }

template <class _Tp>
inline void __destroy_aux(_Tp*, const __true_type& ) {}

template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__pointer, _Trivial_destructor());


#line 69 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
}

template <class _Tp>
inline void _Destroy_Moved(_Tp* __pointer) {

  typedef typename __move_traits<_Tp>::complete _Trivial_destructor;
  __destroy_aux(__pointer, _Trivial_destructor());


#line 79 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"


#line 82 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
}




#line 88 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"

template <class _T1>
inline void _Construct_aux (_T1* __p, const __false_type&) {
  new(__p) _T1();
}

template <class _T1>
inline void _Construct_aux (_T1* __p, const __true_type&) {


#line 99 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
  
  
  *__p = _T1();
#line 103 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
}

template <class _T1>
inline void _Construct(_T1* __p) {


#line 110 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"


#line 113 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
  _Construct_aux (__p, _Is_POD(__p)._Answer());
#line 115 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
}

template <class _Tp>
inline void _Copy_Construct_aux(_Tp* __p, const _Tp& __val, const __false_type&) {
  new(__p) _Tp(__val);
}

template <class _Tp>
inline void _Copy_Construct_aux(_Tp* __p, const _Tp& __val, const __true_type&) {
  
  
  *__p = __val;
}

template <class _Tp>
inline void _Copy_Construct(_Tp* __p, const _Tp& __val) {


#line 134 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
  _Copy_Construct_aux(__p, __val, _Is_POD(__p)._Answer());
}

template <class _T1, class _T2>
inline void _Param_Construct_aux(_T1* __p, const _T2& __val, const __false_type&) {
  new(__p) _T1(__val);
}

template <class _T1, class _T2>
inline void _Param_Construct_aux(_T1* __p, const _T2& __val, const __true_type&) {
  
  
  *__p = _T1(__val);
}

template <class _T1, class _T2>
inline void _Param_Construct(_T1* __p, const _T2& __val) {


#line 154 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
  _Param_Construct_aux(__p, __val, _Is_POD(__p)._Answer());
}

template <class _T1, class _T2>
inline void _Move_Construct_Aux(_T1* __p, _T2& __val, const __false_type& ) {

  new(__p) _T1(::std::priv:: _AsMoveSource(__val));


#line 164 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
}

template <class _T1, class _T2>
inline void _Move_Construct_Aux(_T1* __p, _T2& __val, const __true_type& ) {
  
  
  *__p = _T1(__val);
}

template <class _T1, class _T2>
inline void _Move_Construct(_T1* __p, _T2& __val) {


#line 178 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
  _Move_Construct_Aux(__p, __val, _Is_POD(__p)._Answer());
}






#line 187 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"

template <class _ForwardIterator, class _Tp>
inline void
__destroy_range_aux(_ForwardIterator __first, _ForwardIterator __last, _Tp*, const __false_type& ) {
  for ( ; __first != __last; ++__first) {
    __destroy_aux(&(*__first), __false_type());


#line 196 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
  }
}

template <class _ForwardIterator, class _Tp>






#line 207 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"
inline void
__destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& ) {}
#line 210 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"

template <class _ForwardIterator, class _Tp>
inline void
__destroy_range(_ForwardIterator __first, _ForwardIterator __last, _Tp *__ptr) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy_Range(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy_range(__first, __last, (typename ::std::iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy_Range(char*, char*) {}

inline void _Destroy_Range(wchar_t*, wchar_t*) {}
inline void _Destroy_Range(const wchar_t*, const wchar_t*) {}
#line 228 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"


template <class _ForwardIterator, class _Tp>
inline void
__destroy_mv_srcs(_ForwardIterator __first, _ForwardIterator __last, _Tp *__ptr) {
  typedef typename __move_traits<_Tp>::complete _CompleteMove;
  __destroy_range_aux(__first, __last, __ptr, _CompleteMove());
}
#line 237 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"

template <class _ForwardIterator>
inline void _Destroy_Moved_Range(_ForwardIterator __first, _ForwardIterator __last)

{ __destroy_mv_srcs(__first, __last, (typename ::std::iterator_traits< _ForwardIterator >::value_type*)0); }


#line 245 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"



















#line 265 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"

#line 267 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"






template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Param_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { ::std::_Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) {  ::std::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { ::std::_Destroy_Range(__first, __last); }
#line 282 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"

}

#line 286 "C:\\Pin35\\extras\\stlport\\include\\stl/_construct.h"




#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
#line 53 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

namespace std {





typedef void (* __oom_handler_type)();
#line 62 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

class  __malloc_alloc {
public:
  
  typedef char value_type;
  static void* __cdecl allocate(size_t __n);
  static void __cdecl deallocate(void* __p, size_t );

  static __oom_handler_type __cdecl set_malloc_handler(__oom_handler_type __f);
#line 72 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
};



class  __new_alloc {
public:
  
  typedef char value_type;
  static void* __cdecl allocate(size_t __n) { return __stl_new(__n); }
  static void __cdecl deallocate(void* __p, size_t) { __stl_delete(__p); }
};








template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  }; 
  
  enum { __pad = 8, __magic = 0xdeba, __deleted_magic = 0xdebd,
         __shred_byte = 0xA3 };

  enum { __extra_before = 16, __extra_after = 8 };
  
  
  
  static size_t __cdecl __extra_before_chunk() {
    return (long)__extra_before / sizeof(value_type) +
      (size_t)((long)__extra_before % sizeof(value_type) > 0);
  }
  static size_t __cdecl __extra_after_chunk() {
    return (long)__extra_after / sizeof(value_type) +
      (size_t)((long)__extra_after % sizeof(value_type) > 0);
  }
public:
  __debug_alloc() {}
  ~__debug_alloc() {}
  static void* __cdecl allocate(size_t);
  static void __cdecl deallocate(void *, size_t);
};




#line 129 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
enum { _MAX_BYTES = 32 * sizeof(void*) };
#line 131 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"





class  __node_alloc {
  static void * __cdecl _M_allocate(size_t& __n);
  
  static void __cdecl _M_deallocate(void *__p, size_t __n);

public:
  
  typedef char value_type;
  
  static void* __cdecl allocate(size_t& __n)
  { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }
  
  static void __cdecl deallocate(void *__p, size_t __n)
  { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};



#line 155 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

#line 157 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"




#line 162 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"








#line 171 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

#line 173 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"




#line 178 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"






template <class _Tp, class _Allocator>
struct _Alloc_traits {
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other  allocator_type;
  static allocator_type create_allocator(const _Orig& __a)
  { return allocator_type(__a); }




#line 197 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
};









#line 208 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

#line 210 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
typedef __malloc_alloc __alloc_type;


#line 214 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"



#line 218 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
typedef __alloc_type __sgi_alloc;
#line 220 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"


typedef __sgi_alloc __single_client_alloc;
typedef __sgi_alloc __multithreaded_alloc;
#line 225 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
































template <class _Tp>
class allocator 



                : public __stlport_class<allocator<_Tp> >
{
public:
  typedef _Tp        value_type;
  typedef _Tp*       pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp&       reference;
  typedef const _Tp& const_reference;
  typedef size_t     size_type;
  typedef ptrdiff_t  difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
#line 277 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
  allocator()  {}

  template <class _Tp1> allocator(const allocator<_Tp1>&)  {}
#line 281 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
  allocator(const allocator<_Tp>&)  {}

  allocator(__move_source<allocator<_Tp> > src)  {}
#line 285 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
  ~allocator()  {}
  pointer address(reference __x) const {return &__x;}
  const_pointer address(const_reference __x) const { return &__x; }
  
  _Tp* allocate(size_type __n, const void* = 0) {
    if (__n > max_size()) {
      puts("out of memory\n"); abort();
    }
    if (__n != 0) {
      size_type __buf_size = __n * sizeof(value_type);
      _Tp* __ret = reinterpret_cast<_Tp*>(__sgi_alloc::allocate(__buf_size));


#line 299 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
      return __ret;
    }

    return 0;
  }
  
  void deallocate(pointer __p, size_type __n) {
    
    if (__p != 0) {


#line 311 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
      __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
    }
  }

  
  void deallocate(pointer __p) const {  if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
#line 318 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
  size_type max_size() const   { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const_reference __val) { ::std::_Copy_Construct(__p, __val); }
  void destroy(pointer __p) { ::std::_Destroy(__p); }







#line 329 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
  _Tp* _M_allocate(size_type __n, size_type& __allocated_n) {
    if (__n > max_size()) {
      puts("out of memory\n"); abort();
    }

    if (__n != 0) {
      size_type __buf_size = __n * sizeof(value_type);
      _Tp* __ret = reinterpret_cast<_Tp*>(__sgi_alloc::allocate(__buf_size));


#line 340 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
      __allocated_n = __buf_size / sizeof(value_type);
      return __ret;
    }

    return 0;
  }


#line 349 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
};

template<>
class  allocator<void> {
public:
  typedef size_t      size_type;
  typedef ptrdiff_t   difference_type;
  typedef void*       pointer;
  typedef const void* const_pointer;

  typedef void        value_type;
#line 361 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
#line 366 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
};

template <class _T1, class _T2>
inline bool __cdecl operator==(const allocator<_T1>&, const allocator<_T2>&) 
{ return true; }
template <class _T1, class _T2>
inline bool __cdecl operator!=(const allocator<_T1>&, const allocator<_T2>&) 
{ return false; }









#line 384 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

namespace priv {

template <class _Tp>
struct __alloc_type_traits {

  typedef typename _IsSTLportClass<allocator<_Tp> >::_Ret _STLportAlloc;



#line 395 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
  
  
  typedef _STLportAlloc has_trivial_default_constructor;
  typedef _STLportAlloc has_trivial_copy_constructor;
  typedef _STLportAlloc has_trivial_assignment_operator;
  typedef _STLportAlloc has_trivial_destructor;
  typedef _STLportAlloc is_POD_type;
};

}


template <class _Tp>
struct __type_traits<allocator<_Tp> > : ::std::priv:: __alloc_type_traits<_Tp> {};











#line 421 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"




#line 426 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"










#line 437 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"


template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type  __cdecl
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}









#line 455 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

namespace priv {


template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef typename _Base::size_type size_type;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;

  _STLP_alloc_proxy (const _MaybeReboundAlloc& __a, _Value __p) :
    _MaybeReboundAlloc(__a), _M_data(__p) {}


  _STLP_alloc_proxy (__move_source<_Self> src) :
    _Base(::std::priv:: _AsMoveSource(src.get()._M_base())),
    _M_data(::std::priv:: _AsMoveSource(src.get()._M_data)) {}

  _Base& _M_base()
  { return *this; }
#line 479 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

private:
  



  void _M_swap_alloc(_Self&, const __true_type& )
  {}

  void _M_swap_alloc(_Self& __x, const __false_type& ) {
    _MaybeReboundAlloc &__base_this = *this;
    _MaybeReboundAlloc &__base_x = __x;
    ::std::swap(__base_this, __base_x);
  }

public:
  void _M_swap_alloc(_Self& __x) {

    typedef typename _IsStateless<_MaybeReboundAlloc>::_Ret _StatelessAlloc;


#line 501 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
    _M_swap_alloc(__x, _StatelessAlloc());
  }

  



  void swap(_Self& __x) {
    _M_swap_alloc(__x);
    ::std::swap(_M_data, __x._M_data);
  }

  _Tp* allocate(size_type __n, size_type& __allocated_n) {

    typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;


#line 519 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
    return allocate(__n, __allocated_n, _STLportAlloc());
  }

  
  









#line 534 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"
  
  _Tp* allocate(size_type __n)
  { return _Base::allocate(__n); }
private:
  _Tp* allocate(size_type __n, size_type& __allocated_n, const __true_type& )
  { return _Base::_M_allocate(__n, __allocated_n); }
#line 541 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

  _Tp* allocate(size_type __n, size_type& __allocated_n, const __false_type& )
  { __allocated_n = __n; return allocate(__n); }
};









#line 555 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

}
}



#line 562 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"

#line 564 "C:\\Pin35\\extras\\stlport\\include\\stl/_alloc.h"





#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_fwd.h"






















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"





#line 7 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"

































#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"






#line 42 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"






















#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"






#line 31 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"















#line 47 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"














#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"


#line 68 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/wchar.h"






























#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 32 "C:\\Pin35\\extras\\crt\\include/wchar.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


























#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


#line 35 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdio.h"


























































































































































































































































































































































































































































































#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 41 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"





#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"








#line 56 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"

#line 58 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 33 "C:\\Pin35\\extras\\crt\\include/wchar.h"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"

#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdarg.h"















































#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"








#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 48 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 35 "C:\\Pin35\\extras\\crt\\include/wchar.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"








#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\crt\\include/wchar.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\time.h"


















#line 20 "C:\\Pin35\\extras\\stlport\\include\\time.h"

#line 22 "C:\\Pin35\\extras\\stlport\\include\\time.h"









#line 32 "C:\\Pin35\\extras\\stlport\\include\\time.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/time.h"































#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 33 "C:\\Pin35\\extras\\crt\\include/time.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/time.h"






























#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 32 "C:\\Pin35\\extras\\crt\\include\\sys/time.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/types.h"















































































































































































#line 33 "C:\\Pin35\\extras\\crt\\include\\sys/time.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/time.h"




















#line 1 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/types.h"











































#line 22 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/time.h"



struct timespec {
 __kernel_time_t tv_sec;
 long tv_nsec;

};
#line 31 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/time.h"
struct timeval {
 __kernel_time_t tv_sec;

 __kernel_suseconds_t tv_usec;
};
struct timezone {
 int tz_minuteswest;

 int tz_dsttime;
};




struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;

};
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;

};




















#line 76 "C:\\Pin35\\extras\\crt\\include\\kernel\\uapi\\linux/time.h"
#line 34 "C:\\Pin35\\extras\\crt\\include\\sys/time.h"

extern "C" {

extern int gettimeofday(struct timeval *, struct timezone *);
extern int settimeofday(const struct timeval *, const struct timezone *);

extern int getitimer(int, struct itimerval *);
extern int setitimer(int, const struct itimerval *, struct itimerval *);

extern int utimes(const char *, const struct timeval *);
































}

#line 79 "C:\\Pin35\\extras\\crt\\include\\sys/time.h"
#line 34 "C:\\Pin35\\extras\\crt\\include/time.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\xlocale.h"




































#line 35 "C:\\Pin35\\extras\\crt\\include/time.h"

extern "C" {



extern char* tzname[] ;
extern int daylight ;
extern long int timezone ;

struct sigevent;

struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long int tm_gmtoff;
  const char* tm_zone;
};



extern time_t time(time_t*) ;
extern int nanosleep(const struct timespec*, struct timespec*) ;

extern char* asctime(const struct tm*) ;
extern char* asctime_r(const struct tm*, char*) ;

extern double difftime(const time_t, const time_t) ;
extern time_t mktime(struct tm* const) ;

extern struct tm* localtime(const time_t* const) ;
extern struct tm* localtime_r(const time_t* const, struct tm*) ;

extern struct tm* gmtime(const time_t* const) ;
extern struct tm* gmtime_r(const time_t* const, struct tm*) ;

extern char* strptime(const char*, const char*, struct tm*) ;
extern size_t strftime(char* const, const size_t, const char* const, const struct tm* const) ;
extern size_t strftime_l(char *, size_t, const char *, const struct tm *, locale_t) ;

extern char* ctime(const time_t* const) ;
extern char* ctime_r(const time_t* const, char*) ;

extern void tzset(void) ;

extern clock_t clock(void) ;

extern int clock_getres(int, struct timespec*) ;
extern int clock_gettime(int, struct timespec*) ;

extern int timer_create(int, struct sigevent*, timer_t*) ;
extern int timer_delete(timer_t) ;
extern int timer_settime(timer_t, int, const struct itimerspec*, struct itimerspec*) ;
extern int timer_gettime(timer_t, struct itimerspec*) ;
extern int timer_getoverrun(timer_t) ;


extern time_t timelocal(struct tm* const) ;
extern time_t timegm(struct tm* const) ;

}

#line 104 "C:\\Pin35\\extras\\crt\\include/time.h"
#line 33 "C:\\Pin35\\extras\\stlport\\include\\time.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\time.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\time.h"









#line 45 "C:\\Pin35\\extras\\stlport\\include\\time.h"
#line 37 "C:\\Pin35\\extras\\crt\\include/wchar.h"

#line 1 "C:\\Pin35\\extras\\crt\\include\\machine/wchar_limits.h"










































#line 39 "C:\\Pin35\\extras\\crt\\include/wchar.h"

extern "C" {





#line 47 "C:\\Pin35\\extras\\crt\\include/wchar.h"
typedef unsigned short int char16_t;
typedef long int char32_t;
#line 50 "C:\\Pin35\\extras\\crt\\include/wchar.h"
#line 51 "C:\\Pin35\\extras\\crt\\include/wchar.h"

typedef signed int  wint_t;
typedef struct {
  uint8_t __seq[4];



} mbstate_t;

enum {
    WC_TYPE_INVALID = 0,
    WC_TYPE_ALNUM,
    WC_TYPE_ALPHA,
    WC_TYPE_BLANK,
    WC_TYPE_CNTRL,
    WC_TYPE_DIGIT,
    WC_TYPE_GRAPH,
    WC_TYPE_LOWER,
    WC_TYPE_PRINT,
    WC_TYPE_PUNCT,
    WC_TYPE_SPACE,
    WC_TYPE_UPPER,
    WC_TYPE_XDIGIT,
    WC_TYPE_MAX
};

typedef long wctype_t;



extern wint_t            btowc(int);
extern int               fwprintf(FILE *, const wchar_t *, ...);
extern int               fwscanf(FILE *, const wchar_t *, ...);
extern int               iswalnum(wint_t);
extern int               iswalpha(wint_t);
extern int               iswblank(wint_t);
extern int               iswcntrl(wint_t);
extern int               iswdigit(wint_t);
extern int               iswgraph(wint_t);
extern int               iswlower(wint_t);
extern int               iswprint(wint_t);
extern int               iswpunct(wint_t);
extern int               iswspace(wint_t);
extern int               iswupper(wint_t);
extern int               iswxdigit(wint_t);
extern int               iswctype(wint_t, wctype_t);
extern wint_t            fgetwc(FILE *);
extern wchar_t          *fgetws(wchar_t *, int, FILE *);
extern wint_t            fputwc(wchar_t, FILE *);
extern int               fputws(const wchar_t *, FILE *);
extern int               fwide(FILE *, int);
extern wint_t            getwc(FILE *);
extern wint_t            getwchar(void);
extern int               mbsinit(const mbstate_t *);
extern size_t            mbrlen(const char *, size_t, mbstate_t *);
extern size_t            mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
extern size_t mbsrtowcs(wchar_t*, const char**, size_t, mbstate_t*);
extern size_t mbsnrtowcs(wchar_t*, const char**, size_t, size_t, mbstate_t*);
extern size_t            mbstowcs(wchar_t *, const char *, size_t);
extern wint_t            putwc(wchar_t, FILE *);
extern wint_t            putwchar(wchar_t);
extern int               swprintf(wchar_t *, size_t, const wchar_t *, ...);
extern int               swscanf(const wchar_t *, const wchar_t *, ...);
extern wint_t            towlower(wint_t);
extern wint_t            towupper(wint_t);
extern wint_t            ungetwc(wint_t, FILE *);
extern int vfwprintf(FILE*, const wchar_t*, va_list);
extern int vfwscanf(FILE*, const wchar_t*, va_list);
extern int vswprintf(wchar_t*, size_t, const wchar_t*, va_list);
extern int vswscanf(const wchar_t*, const wchar_t*, va_list);
extern int vwprintf(const wchar_t*, va_list);
extern int vwscanf(const wchar_t*, va_list);
extern size_t            wcrtomb(char *, wchar_t, mbstate_t *);
extern int               wcscasecmp(const wchar_t *, const wchar_t *);
extern wchar_t          *wcscat(wchar_t *, const wchar_t *);
extern wchar_t          *wcschr(const wchar_t *, wchar_t);
extern int               wcscmp(const wchar_t *, const wchar_t *);
extern int               wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t          *wcscpy(wchar_t *, const wchar_t *);
extern size_t            wcscspn(const wchar_t *, const wchar_t *);
extern size_t            wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *) ;
extern size_t            wcslen(const wchar_t *);
extern int               wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t          *wcsncat(wchar_t *, const wchar_t *, size_t);
extern int               wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t          *wcsncpy(wchar_t *, const wchar_t *, size_t);
extern size_t wcsnrtombs(char*, const wchar_t**, size_t, size_t, mbstate_t*);
extern wchar_t          *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t          *wcsrchr(const wchar_t *, wchar_t);
extern size_t wcsrtombs(char*, const wchar_t**, size_t, mbstate_t*);
extern size_t            wcsspn(const wchar_t *, const wchar_t *);
extern wchar_t          *wcsstr(const wchar_t *, const wchar_t *);
extern double wcstod(const wchar_t*, wchar_t**);
extern float wcstof(const wchar_t*, wchar_t**);
extern wchar_t* wcstok(wchar_t*, const wchar_t*, wchar_t**);
extern long wcstol(const wchar_t*, wchar_t**, int);
extern long long wcstoll(const wchar_t*, wchar_t**, int);
extern long double wcstold(const wchar_t*, wchar_t**);
extern unsigned long wcstoul(const wchar_t*, wchar_t**, int);
extern unsigned long long wcstoull(const wchar_t*, wchar_t**, int);
extern int               wcswidth(const wchar_t *, size_t);
extern size_t            wcsxfrm(wchar_t *, const wchar_t *, size_t);
extern int               wctob(wint_t);
extern wctype_t          wctype(const char *);
extern int               wcwidth(wchar_t);
extern wchar_t          *wmemchr(const wchar_t *, wchar_t, size_t);
extern int               wmemcmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t          *wmemcpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t          *wmemmove(wchar_t *, const wchar_t *, size_t);
extern wchar_t          *wmemset(wchar_t *, wchar_t, size_t);
extern int               wprintf(const wchar_t *, ...);
extern int               wscanf(const wchar_t *, ...);

extern long long          wcstoll_l(const wchar_t *, wchar_t **, size_t, locale_t);
extern unsigned long long wcstoull_l(const wchar_t *, wchar_t **, size_t, locale_t);
extern long double        wcstold_l(const wchar_t *, wchar_t **, locale_t );

extern int    wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
extern size_t wcsxfrm_l(wchar_t *, const wchar_t *, size_t, locale_t);

extern size_t wcslcat(wchar_t*, const wchar_t*, size_t);
extern size_t wcslcpy(wchar_t*, const wchar_t*, size_t);

typedef void *wctrans_t;
extern wint_t towctrans(wint_t, wctrans_t);
extern wctrans_t wctrans(const char*);


FILE* open_wmemstream(wchar_t**, size_t*);
wchar_t* wcsdup(const wchar_t*);
size_t wcsnlen(const wchar_t*, size_t);
#line 183 "C:\\Pin35\\extras\\crt\\include/wchar.h"

}

#line 187 "C:\\Pin35\\extras\\crt\\include/wchar.h"
#line 69 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 70 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"


























#line 97 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 98 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"







#line 106 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"




#line 111 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_mbstate_t.h"




















#line 22 "C:\\Pin35\\extras\\stlport\\include\\stl/_mbstate_t.h"




#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_mbstate_t.h"














#line 42 "C:\\Pin35\\extras\\stlport\\include\\stl/_mbstate_t.h"

#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/_mbstate_t.h"
#line 114 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 115 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"


















#line 134 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"















#line 150 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"











#line 162 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 163 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"





#line 169 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"

namespace std {


#line 174 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"





#line 180 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::wint_t;
#line 182 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 183 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"

using ::size_t;


using ::mbstate_t;



using ::btowc;

using ::mbsinit;
#line 197 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 198 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"

using ::mbrlen;
using ::mbrtowc;
using ::mbsrtowcs;
using ::wcrtomb;
using ::wcsrtombs;
#line 206 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 207 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"

#line 209 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"




using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
#line 218 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"



using ::fwide;
#line 224 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::fwprintf;
using ::fwscanf;
using ::getwchar;
#line 228 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"



using ::getwc;
#line 233 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::ungetwc;

using ::putwc;
#line 237 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::putwchar;
#line 239 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"









#line 251 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::swprintf;
using ::vswprintf;
#line 254 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::swscanf;
using ::vfwprintf;
using ::vwprintf;



using ::wcsftime;
#line 263 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::wcstok;

#line 266 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"


using ::wcscoll;
using ::wcsxfrm;
#line 271 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::wcscat;
using ::wcsrchr;
using ::wcscmp;

using ::wcscpy;
using ::wcscspn;

using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcschr;

using ::wcsspn;


using ::wcstod;
using ::wcstol;
#line 291 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"


using ::wcsstr;
using ::wmemchr;



using ::wctob;
#line 300 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"

using ::wmemcmp;
using ::wmemmove;
#line 304 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::wprintf;
using ::wscanf;
#line 307 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"












#line 320 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"






#line 327 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
using ::wmemcpy;
using ::wmemset;
#line 330 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 331 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"

#line 333 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
}

#line 336 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"




#line 341 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"

#line 343 "C:\\Pin35\\extras\\stlport\\include\\stl/_cwchar.h"
#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"
#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"

namespace std {

template <class _Tp> class allocator;





#line 60 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"







#line 68 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"




#line 74 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"
typedef off_t streamoff;
#line 76 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"
#line 77 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"



#line 81 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"
typedef ptrdiff_t streamsize;
#line 83 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"
typedef char __static_assert[sizeof(streamsize)==sizeof(void*) ? 1 : -1] ;
typedef char __static_assert[sizeof(size_t)==sizeof(void*) ? 1 : -1] ;




template <class _StateT> class fpos {
public:                         
  fpos(streamoff __pos) : _M_pos(__pos), _M_st(_StateT()) {}
  fpos() : _M_pos(0), _M_st(_StateT()) {}

  operator streamoff() const { return _M_pos; }

  bool operator==(const fpos& __y) const
  { return _M_pos == __y._M_pos; }
  bool operator!=(const fpos& __y) const
  { return _M_pos != __y._M_pos; }
  bool operator==(const streamoff __off) const
  { return _M_pos == __off; }
  bool operator!=(const streamoff __off) const
  { return _M_pos != __off; }

  fpos& operator+=(streamoff __off) {
    _M_pos += __off;
    return *this;
  }
  fpos& operator-=(streamoff __off) {
    _M_pos -= __off;
    return *this;
  }

  fpos operator+(streamoff __off) {
    fpos __tmp(*this);
    __tmp += __off;
    return __tmp;
  }
  fpos operator-(streamoff __off) {
    fpos __tmp(*this);
    __tmp -= __off;
    return __tmp;
  }

public:                         
  _StateT state() const { return _M_st; }
  void state(_StateT __st) { _M_st = __st; }
private:
  streamoff _M_pos;
  _StateT _M_st;
};

typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;


template <class _CharT, class _IntT>
class __char_traits_base {
public:
  typedef _CharT char_type;
  typedef _IntT int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static void __cdecl assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }
  static bool __cdecl eq(const char_type& __c1, const char_type& __c2)
  { return __c1 == __c2; }
  static bool __cdecl lt(const char_type& __c1, const char_type& __c2)
  { return __c1 < __c2; }

  static int __cdecl compare(const char_type* __s1, const char_type* __s2, size_t __n) {
    for (size_t __i = 0; __i < __n; ++__i)
      if (!eq(__s1[__i], __s2[__i]))
        return __s1[__i] < __s2[__i] ? -1 : 1;
    return 0;
  }

  static size_t __cdecl length(const char_type* __s) {
    const char_type _NullChar = char_type();
    size_t __i(0);
    for (; !eq(__s[__i], _NullChar); ++__i) {}
    return __i;
  }

  static const char_type* __cdecl find(const char_type* __s, size_t __n, const char_type& __c) {
    for ( ; __n > 0 ; ++__s, --__n)
      if (eq(*__s, __c))
        return __s;
    return 0;
  }

  static char_type* __cdecl move(char_type* __s1, const char_type* __s2, size_t _Sz)
  { return (_Sz == 0 ? __s1 : (char_type*)memmove(__s1, __s2, _Sz * sizeof(char_type))); }

  static char_type* __cdecl copy(char_type* __s1, const char_type* __s2, size_t __n) {
    return (__n == 0 ? __s1 :
      (char_type*)memcpy(__s1, __s2, __n * sizeof(char_type)));
  }

  static char_type* __cdecl assign(char_type* __s, size_t __n, char_type __c) {
    for (size_t __i = 0; __i < __n; ++__i)
      __s[__i] = __c;
    return __s;
  }

  static int_type __cdecl not_eof(const int_type& __c)
  { return !eq_int_type(__c, eof()) ? __c : static_cast<int_type>(0); }

  static char_type __cdecl to_char_type(const int_type& __c)
  { return (char_type)__c; }

  static int_type __cdecl to_int_type(const char_type& __c)
  { return (int_type)__c; }

  static bool __cdecl eq_int_type(const int_type& __c1, const int_type& __c2)
  { return __c1 == __c2; }

  static int_type __cdecl eof()
  { return (int_type)-1; }
};






template <class _CharT>
class char_traits
  : public __char_traits_base<_CharT, _CharT> {};



template<>
class  char_traits<char>
  : public __char_traits_base<char, int>,
    public __stlport_class<char_traits<char> > {
public:
  typedef char char_type;
  typedef int int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static char __cdecl to_char_type(const int& __c)
  { return (char)(unsigned char)__c; }

  static int __cdecl to_int_type(const char& __c)
  { return (unsigned char)__c; }

  static int __cdecl compare(const char* __s1, const char* __s2, size_t __n)
  { return memcmp(__s1, __s2, __n); }

  static size_t __cdecl length(const char* __s)
  { return strlen(__s); }

  static void __cdecl assign(char& __c1, const char& __c2)
  { __c1 = __c2; }

  static char* __cdecl assign(char* __s, size_t __n, char __c) {
    memset(__s, __c, __n);
    return __s;
  }
};



template<>
class  char_traits<wchar_t>
  : public __char_traits_base<wchar_t, wint_t> {

public:

  static wchar_t* __cdecl move(wchar_t* __dest, const wchar_t* __src, size_t __n)
  { return wmemmove(__dest, __src, __n); }
#line 257 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"

  static wchar_t* __cdecl copy(wchar_t* __dest, const wchar_t* __src, size_t __n)
  { return wmemcpy(__dest, __src, __n); }


  static int __cdecl compare(const wchar_t* __s1, const wchar_t* __s2, size_t __n)
  { return wmemcmp(__s1, __s2, __n); }
#line 265 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"

  static wchar_t* __cdecl assign(wchar_t* __s, size_t __n, wchar_t __c)
  { return wmemset(__s, __c, __n); }

  static size_t __cdecl length(const wchar_t* __s)
  { return wcslen(__s); }

  static void __cdecl assign(wchar_t& __c1, const wchar_t& __c2)
  { __c1 = __c2; }
#line 275 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"
};
#line 277 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"

}

#line 281 "C:\\Pin35\\extras\\stlport\\include\\stl/char_traits.h"




#line 23 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"
#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"

namespace std {

class ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_istringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_ostringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;

template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

typedef basic_ios<char, char_traits<char> >    ios;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
#line 83 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"


class locale;
template <class _Facet>







#line 95 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"
inline const _Facet& use_facet(const locale&);
#line 97 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"

template <class _CharT> class ctype;
template <class _CharT> class ctype_byname;
template <class _CharT> class collate;
template <class _CharT> class collate_byname;

template<> class ctype<char>;
template<> class ctype_byname<char>;
template<> class collate<char>;
template<> class collate_byname<char>;


template<> class ctype<wchar_t>;
template<> class ctype_byname<wchar_t>;
template<> class collate<wchar_t>;
template<> class collate_byname<wchar_t>;
#line 114 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"




#line 119 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"

typedef basic_istream<char, char_traits<char> >  istream;
typedef basic_ostream<char, char_traits<char> >  ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_streambuf<char,char_traits<char> > streambuf;

typedef basic_stringbuf<char, char_traits<char>, allocator<char> >     stringbuf;
typedef basic_istringstream<char, char_traits<char>, allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>, allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>, allocator<char> >  stringstream;

typedef basic_filebuf<char, char_traits<char> >  filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> >  fstream;



typedef basic_streambuf<wchar_t, char_traits<wchar_t> > wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> >   wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> >   wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> >  wiostream;

typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >     wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >  wstringstream;

typedef basic_filebuf<wchar_t, char_traits<wchar_t> >  wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> >  wfstream;
#line 152 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"

}

#line 156 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"




#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_fwd.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_fwd.h"

namespace std {


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Alloc = allocator<_CharT> >
class basic_string;





#line 39 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_fwd.h"

typedef basic_string<char, char_traits<char>, allocator<char> > string;


typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;
#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_fwd.h"

namespace priv {



const char* __cdecl __get_c_string(const string& __str);

}

}

#line 57 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_fwd.h"




#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
#line 29 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"












































namespace std {

namespace priv {



template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __ucopy(_InputIter __first, _InputIter __last,
                           _OutputIter __result, _Distance*) {
  _OutputIter __cur = __result;
   {
    for ( ; __first != __last; ++__first, ++__cur)
      _Param_Construct(&*__cur, *__first);
    return __cur;
  }
  
  
}

template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __ucopy(_InputIter __first, _InputIter __last,
                           _OutputIter __result, const input_iterator_tag &, _Distance* __d)
{ return __ucopy(__first, __last, __result, __d); }











#line 80 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"

template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter __ucopy(_RandomAccessIter __first, _RandomAccessIter __last,
                           _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  _OutputIter __cur = __result;
   {
    for (_Distance __n = __last - __first; __n > 0; --__n) {
      _Param_Construct(&*__cur, *__first);
      ++__first;
      ++__cur;
    }
    return __cur;
  }
  
  
}


template <class _RandomAccessIter, class _OutputIter>
inline _OutputIter __ucopy(_RandomAccessIter __first, _RandomAccessIter __last, _OutputIter __result)
{ return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

inline void*
__ucopy_trivial(const void* __first, const void* __last, void* __result) {
  
  return (__last == __first) ? __result :
    ((char*)memcpy(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                                const __false_type& )
{ return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                                const __true_type& ) {
  
  
  return (_OutputIter)__ucopy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __true_type& ) {
  return __ucopy_ptrs(__first, __last, __result,
                      _UseTrivialUCopy((typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                       (typename ::std::iterator_traits< _OutputIter >::value_type*)0)._Answer());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __false_type& ) {
  return __ucopy(__first, __last, __result,
                 typename ::std::iterator_traits< _InputIter >::iterator_category(),
                 (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}

}

template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)
{ return ::std::priv:: __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result)
{ return  (char*)::std::priv:: __ucopy_trivial(__first, __last, __result); }


inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result)
{ return  (wchar_t*)::std::priv:: __ucopy_trivial (__first, __last, __result); }
#line 155 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"


namespace priv {

template <class _InputIter, class _Size, class _ForwardIter>
inline
pair<_InputIter, _ForwardIter>
__ucopy_n(_InputIter __first, _Size __count, _ForwardIter __result,
          const input_iterator_tag &) {
  _ForwardIter __cur = __result;
   {
    for ( ; __count > 0 ; --__count, ++__first, ++__cur)
      _Param_Construct(&*__cur, *__first);
    return pair<_InputIter, _ForwardIter>(__first, __cur);
  }
  
  
}















#line 189 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"

template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__ucopy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result,
                       const random_access_iterator_tag &) {
  _RandomAccessIter __last = __first + __count;
  return pair<_RandomAccessIter, _ForwardIter>(__last, uninitialized_copy(__first, __last, __result));
}


template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
__ucopy_n(_InputIter __first, _Size __count, _ForwardIter __result)
{ return ::std::priv:: __ucopy_n(__first, __count, __result, typename ::std::iterator_traits< _InputIter >::iterator_category()); }



}

template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count, _ForwardIter __result)
{ return ::std::priv:: __ucopy_n(__first, __count, __result); }

namespace priv {

#line 216 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"

template <class _ForwardIter, class _Tp, class _Distance>
inline void __ufill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x, _Distance*) {
  _ForwardIter __cur = __first;
   {
    for ( ; __cur != __last; ++__cur)
      _Param_Construct(&*__cur, __x);
  }
  
}

template <class _ForwardIter, class _Tp, class _Distance>
inline void __ufill(_ForwardIter __first, _ForwardIter __last,
                    const _Tp& __x, const input_iterator_tag &, _Distance* __d)
{ __ufill(__first, __last, __x, __d); }











#line 243 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"

template <class _ForwardIter, class _Tp, class _Distance>
inline void __ufill(_ForwardIter __first, _ForwardIter __last,
                    const _Tp& __x, const random_access_iterator_tag &, _Distance*) {
  _ForwardIter __cur = __first;
   {
    for (_Distance __n = __last - __first; __n > 0; --__n, ++__cur)
      _Param_Construct(&*__cur, __x);
  }
  
}

}

template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last,  const _Tp& __x) {
  ::std::priv:: __ufill(__first, __last, __x,
                     typename ::std::iterator_traits< _ForwardIter >::iterator_category(),
                     (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}


inline void uninitialized_fill(unsigned char* __first, unsigned char* __last,
                               const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void uninitialized_fill(signed char* __first, signed char* __last,
                               const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}
#line 277 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"
inline void uninitialized_fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

namespace priv {

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __ufill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  _ForwardIter __cur = __first;
   {
    for ( ; __n > 0; --__n, ++__cur)
      _Param_Construct(&*__cur, __x);
  }
  
  return __cur;
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __ufill_n(_ForwardIter __first, _Size __n, const _Tp& __x,
                              const input_iterator_tag &)
{ return __ufill_n(__first, __n, __x); }











#line 311 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  _ForwardIter __last = __first + __n;
  __ufill(__first, __last, __x, random_access_iterator_tag(), (ptrdiff_t*)0);
  return __last;
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __ufill_n(_ForwardIter __first, _Size __n, const _Tp& __x,
                              const random_access_iterator_tag &)
{ return __uninitialized_fill_n(__first, __n, __x); }





template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux_aux(_ForwardIter __first, _Size __n, const _Tp& __val,
                                    const __false_type& )
{ return __uninitialized_fill_n(__first, __n, __val); }

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux_aux(_ForwardIter __first, _Size __n, const _Tp& ,
                                    const __true_type& ) {
  memset((unsigned char*)__first, 0, __n * sizeof(_Tp));
  return __first + __n;
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux(_ForwardIter __first, _Size __n, const _Tp&,
                                const __true_type& )
{ return __first + __n; }

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux(_ForwardIter __first, _Size __n, const _Tp& __val,
                                const __false_type& )
{ return __uinit_aux_aux(__first, __n, __val, _HasDefaultZeroValue(__first)._Answer()); }

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uninitialized_init(_ForwardIter __first, _Size __n, const _Tp& __val)
{ return __uinit_aux(__first, __n, __val, _UseTrivialInit(__first)._Answer()); }

}

template <class _ForwardIter, class _Size, class _Tp>
inline void
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)
{ ::std::priv:: __ufill_n(__first, __n, __x, typename ::std::iterator_traits< _ForwardIter >::iterator_category()); }









namespace priv {

template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result) {
  _ForwardIter __new_result = uninitialized_copy(__first1, __last1, __result);
   {
    return uninitialized_copy(__first2, __last2, __new_result);
  }
  
  
}




template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
                          _InputIter __first, _InputIter __last) {
  uninitialized_fill(__result, __mid, __x);
   {
    return uninitialized_copy(__first, __last, __mid);
  }
  
  
}




template <class _Iter, class _Tp>
inline void
__uninitialized_copy_fill(_Iter __first1, _Iter __last1, _Iter __first2, _Iter __last2,
                          const _Tp& __x) {
  _Iter __mid2 = uninitialized_copy(__first1, __last1, __first2);
   {
    uninitialized_fill(__mid2, __last2, __x);
  }
  
}




template <class _InputIter, class _ForwardIter, class _TrivialUCpy>
inline _ForwardIter
__uninitialized_move(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     _TrivialUCpy __trivial_ucpy, const __false_type& )
{ return __ucopy_ptrs(__first, __last, __result, __trivial_ucpy); }

template <class _InputIter, class _ForwardIter, class _TrivialUCpy>
inline
_ForwardIter
__uninitialized_move(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     _TrivialUCpy , const __true_type& ) {
  
  for (ptrdiff_t __n = __last - __first ; __n > 0; --__n) {
    _Move_Construct(&*__result, *__first);
    ++__first; ++__result;
  }
  return __result;
}

}

}

#line 440 "C:\\Pin35\\extras\\stlport\\include\\stl/_uninitialized.h"




#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"



#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"









#line 59 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"



















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"



































namespace std {

namespace priv {

template <class _Tp, class _Alloc>
class _String_base {
    typedef _String_base<_Tp, _Alloc> _Self;
protected:
  
public:
  
  enum {_DEFAULT_SIZE = 4 * sizeof( void * )};
  
  typedef _Alloc allocator_type;
  typedef _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _AllocProxy;
  typedef size_t size_type;
private:

  union _Buffers {
    _Tp*  _M_end_of_storage;
    _Tp   _M_static_buf[_DEFAULT_SIZE];
  } _M_buffers;


#line 61 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"
protected:

  bool _M_using_static_buf() const
  { return (_M_start_of_storage._M_data == _M_buffers._M_static_buf); }
  _Tp const* _M_Start() const { return _M_start_of_storage._M_data; }
  _Tp* _M_Start() { return _M_start_of_storage._M_data; }
  _Tp const* _M_End() const
  { return _M_using_static_buf() ? _M_buffers._M_static_buf + _DEFAULT_SIZE : _M_buffers._M_end_of_storage; }
  _Tp* _M_End()
  { return _M_using_static_buf() ? _M_buffers._M_static_buf + _DEFAULT_SIZE : _M_buffers._M_end_of_storage; }
  size_type _M_capacity() const
  { return _M_using_static_buf() ? static_cast<size_type>(_DEFAULT_SIZE) : _M_buffers._M_end_of_storage - _M_start_of_storage._M_data; }
  size_type _M_rest() const
  { return  _M_using_static_buf() ? _DEFAULT_SIZE - (_M_finish - _M_buffers._M_static_buf) : _M_buffers._M_end_of_storage - _M_finish; }









#line 85 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"

  _Tp*    _M_finish;
  _AllocProxy _M_start_of_storage;

  _Tp const* _M_Finish() const {return _M_finish;}
  _Tp* _M_Finish() {return _M_finish;}

  
  void _M_allocate_block(size_t __n = _DEFAULT_SIZE);
  void _M_deallocate_block() {

    if (!_M_using_static_buf() && (_M_start_of_storage._M_data != 0))
      _M_start_of_storage.deallocate(_M_start_of_storage._M_data, _M_buffers._M_end_of_storage - _M_start_of_storage._M_data);



#line 102 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"
  }

  size_t max_size() const {
    const size_type __string_max_size = size_type(-1) / sizeof(_Tp);
    typename allocator_type::size_type __alloc_max_size = _M_start_of_storage.max_size();
    return (min)(__alloc_max_size, __string_max_size) - 1;
  }

  _String_base(const allocator_type& __a)

    : _M_finish(_M_buffers._M_static_buf), _M_start_of_storage(__a, _M_buffers._M_static_buf)


#line 116 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"
    {}

  _String_base(const allocator_type& __a, size_t __n)

    : _M_finish(_M_buffers._M_static_buf), _M_start_of_storage(__a, _M_buffers._M_static_buf) {


#line 124 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"
      _M_allocate_block(__n);
    }


  void _M_move_src (_Self &src) {
    if (src._M_using_static_buf()) {
      _M_buffers = src._M_buffers;
      _M_finish = _M_buffers._M_static_buf + (src._M_finish - src._M_start_of_storage._M_data);
      _M_start_of_storage._M_data = _M_buffers._M_static_buf;
    }
    else {
      _M_start_of_storage._M_data = src._M_start_of_storage._M_data;
      _M_finish = src._M_finish;
      _M_buffers._M_end_of_storage = src._M_buffers._M_end_of_storage;
      src._M_start_of_storage._M_data = 0;
    }
  }
#line 142 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"


  _String_base(__move_source<_Self> src)

    : _M_start_of_storage(__move_source<_AllocProxy>(src.get()._M_start_of_storage)) {
      _M_move_src(src.get());




#line 153 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"
    }
#line 155 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"

  ~_String_base() { _M_deallocate_block(); }

  void _M_reset(_Tp *__start, _Tp *__finish, _Tp *__end_of_storage) {

    _M_buffers._M_end_of_storage = __end_of_storage;


#line 164 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"
    _M_finish = __finish;
    _M_start_of_storage._M_data = __start;
  }

  void _M_swap(_Self &__s) {

    if (_M_using_static_buf()) {
      if (__s._M_using_static_buf()) {
        ::std::swap(_M_buffers, __s._M_buffers);
        _Tp *__tmp = _M_finish;
        _M_finish = _M_start_of_storage._M_data + (__s._M_finish - __s._M_start_of_storage._M_data);
        __s._M_finish = __s._M_buffers._M_static_buf + (__tmp - _M_start_of_storage._M_data);
        
        _M_start_of_storage.swap(__s._M_start_of_storage);
        _M_start_of_storage._M_data = _M_buffers._M_static_buf;
        __s._M_start_of_storage._M_data = __s._M_buffers._M_static_buf;
      } else {
        __s._M_swap(*this);
        return;
      }
    }
    else if (__s._M_using_static_buf()) {
      _Tp *__tmp = _M_start_of_storage._M_data;
      _Tp *__tmp_finish = _M_finish;
      _Tp *__tmp_end_data = _M_buffers._M_end_of_storage;
      _M_buffers = __s._M_buffers;
      
      _M_start_of_storage.swap(__s._M_start_of_storage);
      _M_start_of_storage._M_data = _M_buffers._M_static_buf;
      _M_finish = _M_buffers._M_static_buf + (__s._M_finish - __s._M_buffers._M_static_buf);
      __s._M_buffers._M_end_of_storage = __tmp_end_data;
      __s._M_start_of_storage._M_data = __tmp;
      __s._M_finish = __tmp_finish;
    }
    else {
      ::std::swap(_M_buffers._M_end_of_storage, __s._M_buffers._M_end_of_storage);
      _M_start_of_storage.swap(__s._M_start_of_storage);
      ::std::swap(_M_finish, __s._M_finish);
    }




#line 208 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"
  }

  void  _M_throw_length_error() const;
  void  _M_throw_out_of_range() const;
};






#line 220 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"

}

}

#line 226 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_base.h"






#line 79 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

namespace std {

















namespace priv {
struct _String_reserve_t {};
}



#line 105 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

#line 107 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"



#line 111 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"



#line 115 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

#line 117 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

#line 119 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

template <class _CharT, class _Traits, class _Alloc>
class basic_string : private ::std::priv:: _String_base<_CharT,_Alloc>


#line 125 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
{
private:                        
  typedef ::std::priv:: _String_base<_CharT,_Alloc> _Base;
  typedef basic_string<_CharT, _Traits, _Alloc> _Self;

public:
  typedef _CharT value_type;
  typedef _Traits traits_type;

  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename _Base::size_type size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef const value_type* const_iterator;
  typedef value_type*       iterator;

  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_npos.h"





















#line 23 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_npos.h"


#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_npos.h"
  static const size_t npos = ~(size_t)0;
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_npos.h"
#line 148 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

  typedef ::std::priv:: _String_reserve_t _Reserve_t;

public:                         
  typedef typename _Base::allocator_type allocator_type;

  allocator_type get_allocator() const
  { return (const allocator_type&)this->_M_start_of_storage; }


  explicit basic_string(const allocator_type& __a = allocator_type())





#line 165 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
      : ::std::priv:: _String_base<_CharT,_Alloc>(__a, _Base::_DEFAULT_SIZE)
  { _M_terminate_string(); }


  basic_string(_Reserve_t, size_t __n,
               const allocator_type& __a = allocator_type())





#line 177 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a, __n + 1)
  { _M_terminate_string(); }

  basic_string(const _Self&);


  basic_string(const _Self& __s, size_type __pos, size_type __n = npos,
               const allocator_type& __a = allocator_type())


















#line 204 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    else
      _M_range_initialize(__s._M_Start() + __pos,
                          __s._M_Start() + __pos + (min) (__n, __s.size() - __pos));
  }


  basic_string(const _CharT* __s, size_type __n,
               const allocator_type& __a = allocator_type())







#line 223 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
      
      _M_range_initialize(__s, __s + __n);
    }


  basic_string(const _CharT* __s,
               const allocator_type& __a = allocator_type());



#line 235 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"


  basic_string(size_type __n, _CharT __c,
               const allocator_type& __a = allocator_type())







#line 247 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a, __n + 1) {
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_Start(), __n, __c);
    _M_terminate_string();
  }


  basic_string(__move_source<_Self> src)
    : ::std::priv:: _String_base<_CharT,_Alloc>(__move_source<_Base>(src.get())) {}
#line 256 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

  
  

  template <class _InputIterator>
  basic_string(_InputIterator __f, _InputIterator __l,
               const allocator_type & __a = allocator_type())
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_initialize_dispatch(__f, __l, _Integral());
  }







#line 275 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
























#line 300 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

private:
  size_type _M_compute_next_size(size_type __n) {
    const size_type __size = size();
    if (__n > max_size() - __size)
      this->_M_throw_length_error();
    size_type __len = __size + (max)(__n, __size) + 1;
    if (__len > max_size() || __len < __size)
      __len = max_size(); 
    return __len;
  }

  template <class _InputIter>
  void _M_range_initialize(_InputIter __f, _InputIter __l,
                           const input_iterator_tag &__tag) {
    this->_M_allocate_block();
    _M_construct_null(this->_M_Finish());
    _M_appendT(__f, __l, __tag);
  }

  template <class _ForwardIter>
  void _M_range_initialize(_ForwardIter __f, _ForwardIter __l,
                           const forward_iterator_tag &) {
    difference_type __n = ::std::distance(__f, __l);
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_copy(__f, __l, this->_M_Start());
    this->_M_terminate_string();
  }

  template <class _InputIter>
  void _M_range_initializeT(_InputIter __f, _InputIter __l) {
    _M_range_initialize(__f, __l, typename ::std::iterator_traits< _InputIter >::iterator_category());
  }

  template <class _Integer>
  void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type& ) {
    this->_M_allocate_block(__n + 1);
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_Start(), __n, __x);
    this->_M_terminate_string();
  }

  template <class _InputIter>
  void _M_initialize_dispatch(_InputIter __f, _InputIter __l, const __false_type& ) {
    _M_range_initializeT(__f, __l);
  }

public:
  _Self& operator=(const _Self& __s) {
    if (&__s != this)
      _M_assign(__s._M_Start(), __s._M_Finish());
    return *this;
  }

  _Self& operator=(const _CharT* __s) {
    
    return _M_assign(__s, __s + traits_type::length(__s));
  }

  _Self& operator=(_CharT __c)
  { return assign(static_cast<size_type>(1), __c); }

private:
  static _CharT __cdecl _M_null()
  { return _CharT(); }

private:                     
                                   
  void _M_construct_null(_CharT* __p) const
  { ::std::_Construct(__p); }
  void _M_terminate_string()
  { _M_construct_null(this->_M_Finish()); }
  bool _M_inside(const _CharT* __s) const {
    
    return (__s >= this->_M_Start()) && (__s < this->_M_Finish());
  }

  void _M_range_initialize(const _CharT* __f, const _CharT* __l) {
     
    ptrdiff_t __n = __l - __f;
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_copy(__f, __l, this->_M_Start());
    _M_terminate_string();
  }

public:                         
  iterator begin()             { return this->_M_Start(); }
  iterator end()               { return this->_M_Finish(); }
  const_iterator begin() const { return this->_M_Start(); }
  const_iterator end()   const { return this->_M_Finish(); }

  reverse_iterator rbegin()
  { return reverse_iterator(this->_M_Finish()); }
  reverse_iterator rend()
  { return reverse_iterator(this->_M_Start()); }
  const_reverse_iterator rbegin() const
  { return const_reverse_iterator(this->_M_Finish()); }
  const_reverse_iterator rend()   const
  { return const_reverse_iterator(this->_M_Start()); }

public:                         
  size_type size() const     { return this->_M_Finish() - this->_M_Start(); }
  size_type length() const   { return size(); }
  size_type max_size() const { return _Base::max_size(); }

  void resize(size_type __n, _CharT __c) {
    if (__n <= size())
      erase(begin() + __n, end());
    else
      append(__n - size(), __c);
  }

  void resize(size_type __n) { resize(__n, _M_null()); }

private:
  void _M_reserve(size_type);
public:
  void reserve(size_type = 0);

  size_type capacity() const
  { return this->_M_capacity() - 1; }

  void clear() {
    if (!empty()) {
      _Traits::assign(*(this->_M_Start()), _M_null());
      this->_M_finish = this->_M_Start();
    }
  }

  bool empty() const { return this->_M_Start() == this->_M_Finish(); }

public:                         

  const_reference operator[](size_type __n) const
  { return *(this->_M_Start() + __n); }
  reference operator[](size_type __n)
  { return *(this->_M_Start() + __n); }

  const_reference at(size_type __n) const {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_Start() + __n);
  }

  reference at(size_type __n) {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_Start() + __n);
  }

public:                         

  _Self& operator+=(const _Self& __s) { return append(__s); }
  _Self& operator+=(const _CharT* __s) {  return append(__s); }
  _Self& operator+=(_CharT __c) { push_back(__c); return *this; }

private:
  _Self& _M_append(const _CharT* __first, const _CharT* __last);


  template <class _InputIter>
  _Self& _M_appendT(_InputIter __first, _InputIter __last,
                    const input_iterator_tag &) {
    for ( ; __first != __last ; ++__first)
      push_back(*__first);
    return *this;
  }

  template <class _ForwardIter>
  _Self& _M_appendT(_ForwardIter __first, _ForwardIter __last,
                    const forward_iterator_tag &) {
    if (__first != __last) {
      size_type __n = static_cast<size_type>(::std::distance(__first, __last));
      if (__n >= this->_M_rest()) {
        size_type __len = _M_compute_next_size(__n);
        pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
        pointer __new_finish = uninitialized_copy(this->_M_Start(), this->_M_Finish(), __new_start);
        __new_finish = uninitialized_copy(__first, __last, __new_finish);
        _M_construct_null(__new_finish);
        this->_M_deallocate_block();
        this->_M_reset(__new_start, __new_finish, __new_start + __len);
      }
      else {
        _Traits::assign(*this->_M_finish, *__first++);
        uninitialized_copy(__first, __last, this->_M_Finish() + 1);
        _M_construct_null(this->_M_Finish() + __n);
        this->_M_finish += __n;
      }
    }
    return *this;
  }

  template <class _Integer>
  _Self& _M_append_dispatch(_Integer __n, _Integer __x, const __true_type& )
  { return append((size_type) __n, (_CharT) __x); }

  template <class _InputIter>
  _Self& _M_append_dispatch(_InputIter __f, _InputIter __l, const __false_type& )
  { return _M_appendT(__f, __l, typename ::std::iterator_traits< _InputIter >::iterator_category()); }

public:
  
  
  template <class _InputIter>
  _Self& append(_InputIter __first, _InputIter __last) {
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    return _M_append_dispatch(__first, __last, _Integral());
  }






#line 514 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

public:
  _Self& append(const _Self& __s)
  { return _M_append(__s._M_Start(), __s._M_Finish()); }

  _Self& append(const _Self& __s,
                size_type __pos, size_type __n) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return _M_append(__s._M_Start() + __pos,
                     __s._M_Start() + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& append(const _CharT* __s, size_type __n)
  {  return _M_append(__s, __s+__n); }
  _Self& append(const _CharT* __s)
  {  return _M_append(__s, __s + traits_type::length(__s)); }
  _Self& append(size_type __n, _CharT __c);

public:
  void push_back(_CharT __c) {
    if (this->_M_rest() == 1 )
      _M_reserve(_M_compute_next_size(1));
    _M_construct_null(this->_M_Finish() + 1);
    _Traits::assign(*(this->_M_Finish()), __c);
    ++this->_M_finish;
  }

  char back() const
  {
      return at(length() - 1);
  }

  char front() const
  {
      return at(0);
  }

  void pop_back() {
    _Traits::assign(*(this->_M_Finish() - 1), _M_null());
    --this->_M_finish;
  }

public:                         
  _Self& assign(const _Self& __s)
  { return _M_assign(__s._M_Start(), __s._M_Finish()); }

  _Self& assign(const _Self& __s,
                size_type __pos, size_type __n) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return _M_assign(__s._M_Start() + __pos,
                     __s._M_Start() + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& assign(const _CharT* __s, size_type __n)
  {  return _M_assign(__s, __s + __n); }

  _Self& assign(const _CharT* __s)
  {  return _M_assign(__s, __s + _Traits::length(__s)); }

  _Self& assign(size_type __n, _CharT __c);

private:
  _Self& _M_assign(const _CharT* __f, const _CharT* __l);


  
  template <class _Integer>
  _Self& _M_assign_dispatch(_Integer __n, _Integer __x, const __true_type& )
  { return assign((size_type) __n, (_CharT) __x); }

  template <class _InputIter>
  _Self& _M_assign_dispatch(_InputIter __f, _InputIter __l, const __false_type& ) {
    pointer __cur = this->_M_Start();
    while (__f != __l && __cur != this->_M_Finish()) {
      _Traits::assign(*__cur, *__f);
      ++__f;
      ++__cur;
    }
    if (__f == __l)
      erase(__cur, this->end());
    else
      _M_appendT(__f, __l, typename ::std::iterator_traits< _InputIter >::iterator_category());
    return *this;
  }

public:
  
  
  template <class _InputIter>
  _Self& assign(_InputIter __first, _InputIter __last) {
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    return _M_assign_dispatch(__first, __last, _Integral());
  }






#line 616 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

public:                         
  _Self& insert(size_type __pos, const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (__s.size() > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(begin() + __pos, __s._M_Start(), __s._M_Finish(), &__s == this);
    return *this;
  }

  _Self& insert(size_type __pos, const _Self& __s,
                size_type __beg, size_type __n) {
    if (__pos > size() || __beg > __s.size())
      this->_M_throw_out_of_range();
    size_type __len = (min) (__n, __s.size() - __beg);
    if (__len > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(begin() + __pos,
              __s._M_Start() + __beg, __s._M_Start() + __beg + __len, &__s == this);
    return *this;
  }
  _Self& insert(size_type __pos, const _CharT* __s, size_type __n) {
    
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (__n > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(begin() + __pos, __s, __s + __n, _M_inside(__s));
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s) {
    
    if (__pos > size())
      this->_M_throw_out_of_range();
    size_type __len = _Traits::length(__s);
    if (__len > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(this->_M_Start() + __pos, __s, __s + __len, _M_inside(__s));
    return *this;
  }

  _Self& insert(size_type __pos, size_type __n, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (__n > max_size() - size())
      this->_M_throw_length_error();
    insert(begin() + __pos, __n, __c);
    return *this;
  }

  iterator insert(iterator __p, _CharT __c) {
    
    if (__p == end()) {
      push_back(__c);
      return this->_M_Finish() - 1;
    }
    else
      return _M_insert_aux(__p, __c);
  }

  void insert(iterator __p, size_t __n, _CharT __c);

private:  
  void _M_insert(iterator __p, const _CharT* __first, const _CharT* __last, bool __self_ref);

  pointer _M_insert_aux(pointer, _CharT);

  void _M_copy(const _CharT* __f, const _CharT* __l, _CharT* __res) {
     
    
    _Traits::copy(__res, __f, __l - __f);
  }

  void _M_move(const _CharT* __f, const _CharT* __l, _CharT* __res) {
     
    _Traits::move(__res, __f, __l - __f);
  }



  template <class _ForwardIter>
  void _M_insert_overflow(iterator __pos, _ForwardIter __first, _ForwardIter __last,
                          size_type __n) {
    size_type __len = _M_compute_next_size(__n);
    pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
    pointer __new_finish = uninitialized_copy(this->_M_Start(), __pos, __new_start);
    __new_finish = uninitialized_copy(__first, __last, __new_finish);
    __new_finish = uninitialized_copy(__pos, this->_M_Finish(), __new_finish);
    _M_construct_null(__new_finish);
    this->_M_deallocate_block();
    this->_M_reset(__new_start, __new_finish, __new_start + __len);
  }

  template <class _InputIter>
  void _M_insertT(iterator __p, _InputIter __first, _InputIter __last,
                  const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __p = insert(__p, *__first);
      ++__p;
    }
  }

  template <class _ForwardIter>
  void _M_insertT(iterator __pos, _ForwardIter __first, _ForwardIter __last,
                  const forward_iterator_tag &) {
    if (__first != __last) {
      size_type __n = ::std::distance(__first, __last);
      if (__n < this->_M_rest()) {
        const size_type __elems_after = this->_M_finish - __pos;
        if (__elems_after >= __n) {
          uninitialized_copy((this->_M_Finish() - __n) + 1, this->_M_Finish() + 1, this->_M_Finish() + 1);
          this->_M_finish += __n;
          _Traits::move(__pos + __n, __pos, (__elems_after - __n) + 1);
          _M_copyT(__first, __last, __pos);
        }
        else {
          pointer __old_finish = this->_M_Finish();
          _ForwardIter __mid = __first;
          ::std::advance(__mid, __elems_after + 1);
          ::std::uninitialized_copy(__mid, __last, this->_M_Finish() + 1);
          this->_M_finish += __n - __elems_after;
          uninitialized_copy(__pos, __old_finish + 1, this->_M_Finish());
          this->_M_finish += __elems_after;
          _M_copyT(__first, __mid, __pos);
        }
      }
      else {
        _M_insert_overflow(__pos, __first, __last, __n);
      }
    }
  }

  template <class _Integer>
  void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,
                          const __true_type& )
  { insert(__p, (size_type) __n, (_CharT) __x); }

  template <class _InputIter>
  void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,
                          const __false_type& ) {
    
    
    const _Self __self(__first, __last, get_allocator());
    _M_insertT(__p, __self.begin(), __self.end(), forward_iterator_tag());
  }

  template <class _InputIterator>
  void _M_copyT(_InputIterator __first, _InputIterator __last, pointer __result) {
    
    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }


  void _M_copyT(const _CharT* __f, const _CharT* __l, _CharT* __res) {
     
    
    _Traits::copy(__res, __f, __l - __f);
  }
#line 778 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
public:
  
  
  template <class _InputIter>
  void insert(iterator __p, _InputIter __first, _InputIter __last) {
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    _M_insert_dispatch(__p, __first, __last, _Integral());
  }
#line 787 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
#line 788 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"


public:
  void insert(iterator __p, const _CharT* __f, const _CharT* __l) {
     
    _M_insert(__p, __f, __l, _M_inside(__f));
  }
#line 796 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

public:                         
  _Self& erase(size_type __pos = 0, size_type __n = npos) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    erase(begin() + __pos, begin() + __pos + (min) (__n, size() - __pos));
    return *this;
  }

  iterator erase(iterator __pos) {
    
    _Traits::move(__pos, __pos + 1, this->_M_Finish() - __pos);
    --this->_M_finish;
    return __pos;
  }

  iterator erase(iterator __first, iterator __last) {
    if (__first != __last) {
      
      traits_type::move(__first, __last, (this->_M_Finish() - __last) + 1);
      this->_M_finish = this->_M_Finish() - (__last - __first);
    }
    return __first;
  }

public:                         
                                
  _Self& replace(size_type __pos, size_type __n, const _Self& __s) {
    const size_type __size = size();
    if (__pos > __size)
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, __size - __pos);
    if (__s.size() > max_size() - (__size - __len))
      this->_M_throw_length_error();
    return _M_replace(begin() + __pos, begin() + __pos + __len,
                      __s._M_Start(), __s._M_Finish(), &__s == this);
  }

  _Self& replace(size_type __pos1, size_type __n1, const _Self& __s,
                 size_type __pos2, size_type __n2) {
    const size_type __size1 = size();
    const size_type __size2 = __s.size();
    if (__pos1 > __size1 || __pos2 > __size2)
      this->_M_throw_out_of_range();
    const size_type __len1 = (min) (__n1, __size1 - __pos1);
    const size_type __len2 = (min) (__n2, __size2 - __pos2);
    if (__len2 > max_size() - (__size1 - __len1))
      this->_M_throw_length_error();
    return _M_replace(begin() + __pos1, begin() + __pos1 + __len1,
                      __s._M_Start() + __pos2, __s._M_Start() + __pos2 + __len2, &__s == this);
  }

  _Self& replace(size_type __pos, size_type __n1,
                 const _CharT* __s, size_type __n2) {
    
    const size_type __size = size();
    if (__pos > __size)
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, __size - __pos);
    if (__n2 > max_size() - (__size - __len))
      this->_M_throw_length_error();
    return _M_replace(begin() + __pos, begin() + __pos + __len,
                      __s, __s + __n2, _M_inside(__s));
  }

  _Self& replace(size_type __pos, size_type __n1, const _CharT* __s) {
    
    return replace(__pos, __n1, __s, _Traits::length(__s));
  }

  _Self& replace(size_type __pos, size_type __n1,
                 size_type __n2, _CharT __c) {
    const size_type __size = size();
    if (__pos > __size)
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, __size - __pos);
    if (__n2 > max_size() - (__size - __len))
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len, __n2, __c);
  }

  _Self& replace(iterator __first, iterator __last, const _Self& __s) {
    
    return _M_replace(__first, __last, __s._M_Start(), __s._M_Finish(), &__s == this);
  }

  _Self& replace(iterator __first, iterator __last,
                 const _CharT* __s, size_type __n) {
    
    
    return _M_replace(__first, __last, __s, __s + __n, _M_inside(__s));
  }

  _Self& replace(iterator __first, iterator __last,
                 const _CharT* __s) {
    
    
    return _M_replace(__first, __last, __s, __s + _Traits::length(__s), _M_inside(__s));
  }

  _Self& replace(iterator __first, iterator __last, size_type __n, _CharT __c);

private:                        
  _Self& _M_replace(iterator __first, iterator __last,
                    const _CharT* __f, const _CharT* __l, bool __self_ref);


  template <class _Integer>
  _Self& _M_replace_dispatch(iterator __first, iterator __last,
                             _Integer __n, _Integer __x, const __true_type& ) {
     
    return replace(__first, __last, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter>
  _Self& _M_replace_dispatch(iterator __first, iterator __last,
                             _InputIter __f, _InputIter __l, const __false_type& ) {
     
    
    const _Self __self(__f, __l, get_allocator());
    return _M_replace(__first, __last, __self._M_Start(), __self._M_Finish(), false);
  }

public:
  
  
  template <class _InputIter>
  _Self& replace(iterator __first, iterator __last,
                 _InputIter __f, _InputIter __l) {
    
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    return _M_replace_dispatch(__first, __last, __f, __l,  _Integral());
  }
#line 930 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"


public:
  _Self& replace(iterator __first, iterator __last,
                 const _CharT* __f, const _CharT* __l) {
    
     
    return _M_replace(__first, __last, __f, __l, _M_inside(__f));
  }
#line 940 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

public:                         

  size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
    
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    _Traits::copy(__s, this->_M_Start() + __pos, __len);
    return __len;
  }

  void swap(_Self& __s) { this->_M_swap(__s); }


#line 956 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

public:                         

  const _CharT* c_str() const { return this->_M_Start(); }
  const _CharT* data()  const { return this->_M_Start(); }

public: 
  size_type find(const _Self& __s, size_type __pos = 0) const
  { return find(__s._M_Start(), __pos, __s.size()); }

  size_type find(const _CharT* __s, size_type __pos = 0) const
  {  return find(__s, __pos, _Traits::length(__s)); }

  size_type find(const _CharT* __s, size_type __pos, size_type __n) const;

  
  size_type find(_CharT __c) const { return find(__c, 0); }
  size_type find(_CharT __c, size_type __pos ) const;

public: 
  size_type rfind(const _Self& __s, size_type __pos = npos) const
  { return rfind(__s._M_Start(), __pos, __s.size()); }

  size_type rfind(const _CharT* __s, size_type __pos = npos) const
  {  return rfind(__s, __pos, _Traits::length(__s)); }

  size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;
  size_type rfind(_CharT __c, size_type __pos = npos) const;

public: 
  size_type find_first_of(const _Self& __s, size_type __pos = 0) const
  { return find_first_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_first_of(const _CharT* __s, size_type __pos = 0) const
  {  return find_first_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_first_of(_CharT __c, size_type __pos = 0) const
  { return find(__c, __pos); }

public: 
  size_type find_last_of(const _Self& __s, size_type __pos = npos) const
  { return find_last_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_last_of(const _CharT* __s, size_type __pos = npos) const
  {  return find_last_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_last_of(_CharT __c, size_type __pos = npos) const
  { return rfind(__c, __pos); }

public: 
  size_type find_first_not_of(const _Self& __s, size_type __pos = 0) const
  { return find_first_not_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const
  {  return find_first_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;

public: 
  size_type find_last_not_of(const _Self& __s, size_type __pos = npos) const
  { return find_last_not_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const
  {  return find_last_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;

public: 
  _Self substr(size_type __pos = 0, size_type __n = npos) const
  { return _Self(*this, __pos, __n, get_allocator()); }

public: 
  int compare(const _Self& __s) const
  { return _M_compare(this->_M_Start(), this->_M_Finish(), __s._M_Start(), __s._M_Finish()); }

  int compare(size_type __pos1, size_type __n1, const _Self& __s) const {
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_Start(), __s._M_Finish());
  }

  int compare(size_type __pos1, size_type __n1, const _Self& __s,
              size_type __pos2, size_type __n2) const {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_Start() + __pos2,
                      __s._M_Start() + __pos2 + (min) (__n2, __s.size() - __pos2));
  }

  int compare(const _CharT* __s) const {
    
    return _M_compare(this->_M_Start(), this->_M_Finish(), __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
    
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const {
    
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + __n2);
  }

public: 
  static int __cdecl _M_compare(const _CharT* __f1, const _CharT* __l1,
                                   const _CharT* __f2, const _CharT* __l2) {
    const ptrdiff_t __n1 = __l1 - __f1;
    const ptrdiff_t __n2 = __l2 - __f2;
    const int cmp = _Traits::compare(__f1, __f2, (min) (__n1, __n2));
    return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));
  }




#line 1093 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
};






#line 1101 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"






#line 1108 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"




#line 1113 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

}



#line 1119 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"



#line 1123 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

namespace std {





template <class _CharT, class _Traits, class _Alloc>
inline void __cdecl
swap(basic_string<_CharT,_Traits,_Alloc>& __x,
     basic_string<_CharT,_Traits,_Alloc>& __y)
{ __x.swap(__y); }







#line 1143 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"


template <class _CharT, class _Traits, class _Alloc>
struct __move_traits<basic_string<_CharT, _Traits, _Alloc> > {
  typedef __true_type implemented;
  
  typedef typename __move_traits<_Alloc>::complete complete;
};







#line 1159 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

namespace priv {

template <class _CharT, class _Traits, class _Alloc>
void __cdecl _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                               _CharT* __buf, size_t __n);





#line 1171 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

inline const char* __cdecl
__get_c_string(const string& __str) { return __str.c_str(); }

}

}

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"


















namespace std {





#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc> __cdecl
operator+(const basic_string<_CharT,_Traits,_Alloc>& __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;



#line 37 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  _Str __result(_Reserve_t(), __s.size() + __y.size(), __s.get_allocator());
#line 39 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  __result.append(__s);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc> __cdecl
operator+(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);


#line 55 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  _Str __result(_Reserve_t(), __n + __y.size(), __y.get_allocator());
#line 57 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  __result.append(__s, __s + __n);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc> __cdecl
operator+(_CharT __c,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;


#line 71 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  _Str __result(_Reserve_t(), 1 + __y.size(), __y.get_allocator());
#line 73 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  __result.push_back(__c);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc> __cdecl
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
  
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);


#line 89 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  _Str __result(_Reserve_t(), __x.size() + __n, __x.get_allocator());
#line 91 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  __result.append(__x);
  __result.append(__s, __s + __n);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc> __cdecl
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT __c) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;


#line 105 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  _Str __result(_Reserve_t(), __x.size() + 1, __x.get_allocator());
#line 107 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"
  __result.append(__x);
  __result.push_back(__c);
  return __result;
}










































































































































































#line 282 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"



template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __x.size() == __y.size() && _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;
}















#line 307 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"


template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator==(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  
  size_t __n = _Traits::length(__s);
  return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;
}

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
  
  size_t __n = _Traits::length(__s);
  return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;
}



















#line 346 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"



template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
                                                          __y.begin(), __y.end()) < 0;
}

















#line 374 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator<(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__s, __s + __n,
                                                          __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
  
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
                                                          __s, __s + __n) < 0;
}





















#line 416 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"







template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return !(__x == __y); }

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return __y < __x; }

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return !(__y < __x); }

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return !(__x < __y); }













#line 460 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

#line 462 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator!=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  
  return !(__s == __y);
}

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
  
  return !(__x == __s);
}

















#line 496 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator>(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  
  return __y < __s;
}

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
  
  return __s < __x;
}

















#line 530 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator<=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  
  return !(__y < __s);
}

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
  
  return !(__s < __x);
}

















#line 564 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator>=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  
  return !(__s < __y);
}

template <class _CharT, class _Traits, class _Alloc>
inline bool __cdecl
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
  
  return !(__x < __s);
}

















#line 598 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

}

#line 602 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_operators.h"

#line 1180 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctraits_fns.h"



























namespace std {

namespace priv {

template <class _Traits>
struct _Eq_traits
  : public binary_function<typename _Traits::char_type,
                           typename _Traits::char_type,
                           bool> {
  bool operator()(const typename _Traits::char_type& __x,
                  const typename _Traits::char_type& __y) const
  { return _Traits::eq(__x, __y); }
};

template <class _Traits>
struct _Eq_char_bound
  : public unary_function<typename _Traits::char_type, bool> {
  typename _Traits::char_type __val;
  _Eq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
  { return _Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Neq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Neq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
  { return !_Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Eq_int_bound
  : public unary_function<typename _Traits::char_type, bool> {
  typename _Traits::int_type __val;

  _Eq_int_bound(typename _Traits::int_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
  { return _Traits::eq_int_type(_Traits::to_int_type(__x), __val); }
};











#line 82 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctraits_fns.h"

}

}

#line 88 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctraits_fns.h"




#line 33 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_function.h"








































namespace std {

template <class _Tp>
struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

template <class _Tp>
struct greater : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

template <class _Tp>
struct greater_equal : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

template <class _Tp>
struct less_equal : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

template <class _Tp>
struct divides : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

template <class _Tp>
struct modulus : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

template <class _Tp>
struct negate : public unary_function<_Tp, _Tp> {
  _Tp operator()(const _Tp& __x) const { return -__x; }
};

template <class _Tp>
struct logical_and : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

template <class _Tp>
struct logical_or : public binary_function<_Tp, _Tp,bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

template <class _Tp>
struct logical_not : public unary_function<_Tp, bool> {
  bool operator()(const _Tp& __x) const { return !__x; }
};



template <class _Tp> inline _Tp identity_element(plus<_Tp>) {  return _Tp(0); }
template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) { return _Tp(1); }
#line 98 "C:\\Pin35\\extras\\stlport\\include\\stl/_function.h"































#line 130 "C:\\Pin35\\extras\\stlport\\include\\stl/_function.h"



#line 134 "C:\\Pin35\\extras\\stlport\\include\\stl/_function.h"

template <class _Predicate>
class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool> {
  typedef unary_function<typename _Predicate::argument_type, bool> _Base;
public:
  typedef typename _Base::argument_type argument_type;
private:
  typedef typename __call_traits<argument_type>::const_param_type _ArgParamType;
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(_ArgParamType __x) const {
    return !_M_pred(__x);
  }
};

template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred) {
  return unary_negate<_Predicate>(__pred);
}

template <class _Predicate>
class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool> {
  typedef binary_function<typename _Predicate::first_argument_type,
                          typename _Predicate::second_argument_type,
                          bool> _Base;
public:
  typedef typename _Base::first_argument_type first_argument_type;
  typedef typename _Base::second_argument_type second_argument_type;
private:
  typedef typename __call_traits<first_argument_type>::const_param_type _FstArgParamType;
  typedef typename __call_traits<second_argument_type>::const_param_type _SndArgParamType;
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(_FstArgParamType __x, _SndArgParamType __y) const {
    return !_M_pred(__x, __y);
  }
};

template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred) {
  return binary_negate<_Predicate>(__pred);
}

template <class _Operation>
class binder1st :
    public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type > {
  typedef unary_function<typename _Operation::second_argument_type,
                         typename _Operation::result_type > _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::param_type _ArgParamType;
  typedef typename __call_traits<argument_type>::const_param_type _ConstArgParamType;
  typedef typename __call_traits<typename _Operation::first_argument_type>::const_param_type _ValueParamType;
protected:
  
  _Operation op;
  typename _Operation::first_argument_type _M_value;
public:
  binder1st(const _Operation& __x, _ValueParamType __y)
    : op(__x), _M_value(__y) {}

  result_type operator()(_ConstArgParamType __x) const
  { return op(_M_value, __x); }
  
  result_type operator()(_ArgParamType __x) const
  { return op(_M_value, __x); }
};

template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x) {
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}

template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
  typedef unary_function<typename _Operation::first_argument_type,
                         typename _Operation::result_type> _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::param_type _ArgParamType;
  typedef typename __call_traits<argument_type>::const_param_type _ConstArgParamType;
  typedef typename __call_traits<typename _Operation::second_argument_type>::const_param_type _ValueParamType;
protected:
  
  _Operation op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x, _ValueParamType __y)
      : op(__x), value(__y) {}

  result_type operator()(_ConstArgParamType __x) const
  { return op(__x, value); }
  
  result_type operator()(_ArgParamType __x) const
  { return op(__x, value); }
};

template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x) {
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}




template <class _Operation1, class _Operation2>
class unary_compose :
  public unary_function<typename _Operation2::argument_type,
                        typename _Operation1::result_type> {
  typedef unary_function<typename _Operation2::argument_type,
                         typename _Operation1::result_type> _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::const_param_type _ArgParamType;
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
public:
  unary_compose(const _Operation1& __x, const _Operation2& __y)
    : _M_fn1(__x), _M_fn2(__y) {}

  result_type operator()(_ArgParamType __x) const {
    return _M_fn1(_M_fn2(__x));
  }
};

template <class _Operation1, class _Operation2>
inline unary_compose<_Operation1,_Operation2>
compose1(const _Operation1& __fn1, const _Operation2& __fn2) {
  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
}

template <class _Operation1, class _Operation2, class _Operation3>
class binary_compose :
    public unary_function<typename _Operation2::argument_type,
                          typename _Operation1::result_type> {
  typedef unary_function<typename _Operation2::argument_type,
                         typename _Operation1::result_type> _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::const_param_type _ArgParamType;
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
  _Operation3 _M_fn3;
public:
  binary_compose(const _Operation1& __x, const _Operation2& __y,
                 const _Operation3& __z)
    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }

  result_type operator()(_ArgParamType __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }
};

template <class _Operation1, class _Operation2, class _Operation3>
inline binary_compose<_Operation1, _Operation2, _Operation3>
compose2(const _Operation1& __fn1, const _Operation2& __fn2,
         const _Operation3& __fn3) {
  return binary_compose<_Operation1,_Operation2,_Operation3>(__fn1, __fn2, __fn3);
}


template <class _Tp> struct identity : public ::std::priv:: _Identity<_Tp> {};

template <class _Pair> struct select1st : public ::std::priv:: _Select1st<_Pair> {};
template <class _Pair> struct select2nd : public ::std::priv:: _Select2nd<_Pair> {};

template <class _Arg1, class _Arg2>
struct project1st : public ::std::priv:: _Project1st<_Arg1, _Arg2> {};

template <class _Arg1, class _Arg2>
struct project2nd : public ::std::priv:: _Project2nd<_Arg1, _Arg2> {};






namespace priv {

template <class _Result>
struct _Constant_void_fun {
  typedef _Result result_type;
  result_type _M_val;

  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()() const { return _M_val; }
};

}

template <class _Result>
struct constant_void_fun : public ::std::priv:: _Constant_void_fun<_Result> {
  constant_void_fun(const _Result& __v)
    : ::std::priv:: _Constant_void_fun<_Result>(__v) {}
};

template <class _Result, class _Argument = _Result >
struct constant_unary_fun : public ::std::priv:: _Constant_unary_fun<_Result, _Argument> {
  constant_unary_fun(const _Result& __v)
    : ::std::priv:: _Constant_unary_fun<_Result, _Argument>(__v) {}
};

template <class _Result, class _Arg1 = _Result, class _Arg2 = _Arg1 >
struct constant_binary_fun
  : public ::std::priv:: _Constant_binary_fun<_Result, _Arg1, _Arg2> {
  constant_binary_fun(const _Result& __v)
    : ::std::priv:: _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
};

template <class _Result>
inline constant_void_fun<_Result> constant0(const _Result& __val) {
  return constant_void_fun<_Result>(__val);
}

template <class _Result>
inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val) {
  return constant_unary_fun<_Result,_Result>(__val);
}

template <class _Result>
inline constant_binary_fun<_Result,_Result,_Result>
constant2(const _Result& __val) {
  return constant_binary_fun<_Result,_Result,_Result>(__val);
}



class subtractive_rng : public unary_function<unsigned long, unsigned long> {
private:
  unsigned long _M_table[55];
  unsigned long _M_index1;
  unsigned long _M_index2;
public:
  unsigned long operator()(unsigned long __limit) {
    _M_index1 = (_M_index1 + 1) % 55;
    _M_index2 = (_M_index2 + 1) % 55;
    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
    return _M_table[_M_index1] % __limit;
  }

  void _M_initialize(unsigned long __seed) {
    unsigned long __k = 1;
    _M_table[54] = __seed;
    unsigned long __i;
    for (__i = 0; __i < 54; __i++) {
        unsigned long __ii = (21 * (__i + 1) % 55) - 1;
        _M_table[__ii] = __k;
        __k = __seed - __k;
        __seed = _M_table[__ii];
    }
    for (int __loop = 0; __loop < 4; __loop++) {
        for (__i = 0; __i < 55; __i++)
            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
    }
    _M_index1 = 0;
    _M_index2 = 31;
  }

  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }
  subtractive_rng() { _M_initialize(161803398ul); }
};

#line 424 "C:\\Pin35\\extras\\stlport\\include\\stl/_function.h"

}

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_adaptors.h"

























































namespace std {





















































































































































































































































































































































































































































#line 497 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_adaptors.h"

template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};

template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};










































































































#line 709 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_adaptors.h"

#line 711 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_adaptors.h"







template <class _Result, class _Tp>
inline mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)()) { return mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)() const)  { return const_mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)())  { return mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)() const)  { return const_mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }




template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

#line 770 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_adaptors.h"

#line 772 "C:\\Pin35\\extras\\stlport\\include\\stl/_function_adaptors.h"

template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg))
{ return pointer_to_unary_function<_Arg, _Result>(__f); }

template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2))
{ return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f); }

}
#line 428 "C:\\Pin35\\extras\\stlport\\include\\stl/_function.h"

#line 430 "C:\\Pin35\\extras\\stlport\\include\\stl/_function.h"




#line 37 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"



#line 42 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"





#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

namespace std {

namespace priv {


template <class _Traits>
struct _Not_within_traits : public unary_function<typename _Traits::char_type, bool> {
  typedef typename _Traits::char_type _CharT;
  const _CharT* _M_first;
  const _CharT* _M_last;

  _Not_within_traits(const _CharT* __f, const _CharT* __l)
    : _M_first(__f), _M_last(__l) {}

  bool operator()(const _CharT& __x) const {
    return find_if(_M_first, _M_last,
                   ::std::priv:: _Eq_char_bound<_Traits>(__x)) == _M_last;
  }
};

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_of_aux(_InputIter __first1, _InputIter __last1,
                                          const _CharT* __first2, const _CharT* __last2,
                                          _Traits*, const __true_type& )
{ return __find_first_of(__first1, __last1, __first2, __last2); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_of_aux(_InputIter __first1, _InputIter __last1,
                                          const _CharT* __first2, const _CharT* __last2,
                                          _Traits*, const __false_type& )
{ return __find_first_of(__first1, __last1, __first2, __last2, ::std::priv:: _Eq_traits<_Traits>()); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_of(_InputIter __first1, _InputIter __last1,
                                      const _CharT* __first2, const _CharT* __last2,
                                      _Traits* __traits) {

  typedef typename _IsSTLportClass<_Traits>::_Ret _STLportTraits;



#line 95 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"
  return __str_find_first_of_aux(__first1, __last1, __first2, __last2, __traits, _STLportTraits());
}

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux3(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits* , const __true_type& __useStrcspnLikeAlgo)
{ return __find_first_of_aux2(__first1, __last1, __first2, __last2, __first2, not1(_Identity<bool>()), __useStrcspnLikeAlgo); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux3(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits* , const __false_type& )
{ return ::std::find_if(__first1, __last1, ::std::priv:: _Not_within_traits<_Traits>(__first2, __last2)); }

template <class _InputIter, class _CharT, class _Tp, class _Traits>
inline _InputIter __str_find_first_not_of_aux2(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Tp* __pt, _Traits* __traits) {
  typedef typename _IsIntegral<_Tp>::_Ret _IsIntegral;
  typedef typename _IsCharLikeType<_CharT>::_Ret _IsCharLike;
  typedef typename _Land2<_IsIntegral, _IsCharLike>::_Ret _UseStrcspnLikeAlgo;
  return __str_find_first_not_of_aux3(__first1, __last1, __first2, __last2, __traits, _UseStrcspnLikeAlgo());
}

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux1(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits* __traits, const __true_type& )
{ return __str_find_first_not_of_aux2(__first1, __last1, __first2, __last2,
                                      (typename ::std::iterator_traits< _InputIter >::value_type*)0, __traits); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux1(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits*, const __false_type& )
{ return ::std::find_if(__first1, __last1, ::std::priv:: _Not_within_traits<_Traits>(__first2, __last2)); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of(_InputIter __first1, _InputIter __last1,
                                          const _CharT* __first2, const _CharT* __last2,
                                          _Traits* __traits) {

  typedef typename _IsSTLportClass<_Traits>::_Ret _STLportTraits;



#line 143 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"
  return __str_find_first_not_of_aux1(__first1, __last1, __first2, __last2, __traits, _STLportTraits());
}





}
#line 152 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"





template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {
  if (__res_arg > max_size())
    this->_M_throw_length_error();

  size_type __n = (max)(__res_arg, size()) + 1;
  if (__n < this->_M_capacity())
    return;

  _M_reserve(__n);
}

template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::_M_reserve(size_type __n) {
  pointer __new_start = this->_M_start_of_storage.allocate(__n, __n);
  pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), this->_M_Finish(), __new_start);
  _M_construct_null(__new_finish);
  this->_M_deallocate_block();
  this->_M_reset(__new_start, __new_finish, __new_start + __n);
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {
  if (__n > 0) {
    if (__n > max_size() - size())
      this->_M_throw_length_error();
    if (__n >= this->_M_rest())
      _M_reserve(_M_compute_next_size(__n));
    ::std::priv:: __uninitialized_fill_n(this->_M_finish + 1, __n - 1, __c);
    _M_construct_null(this->_M_finish + __n);
    _Traits::assign(*end(), __c);
    this->_M_finish += __n;
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT, _Traits, _Alloc>&
basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT* __first, const _CharT* __last) {
  if (__first != __last) {
    size_type __n = static_cast<size_type>(__last - __first);
    if (__n >= this->_M_rest()) {
      size_type __len = _M_compute_next_size(__n);
      pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
      pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), this->_M_Finish(), __new_start);
      __new_finish = ::std::priv:: __ucopy(__first, __last, __new_finish);
      _M_construct_null(__new_finish);
      this->_M_deallocate_block();
      this->_M_reset(__new_start, __new_finish, __new_start + __len);
    }
    else {
      const _CharT* __f1 = __first;
      ++__f1;
      ::std::priv:: __ucopy(__f1, __last, this->_M_finish + 1);
      _M_construct_null(this->_M_finish + __n);
      _Traits::assign(*end(), *__first);
      this->_M_finish += __n;
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {
  if (__n <= size()) {
    _Traits::assign(this->_M_Start(), __n, __c);
    erase(begin() + __n, end());
  }
  else {
    if (__n < capacity()) {
      _Traits::assign(this->_M_Start(), size(), __c);
      append(__n - size(), __c);
    }
    else {
      _Self __str(__n, __c);
      this->swap(__str);
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::_M_assign(const _CharT* __f, const _CharT* __l) {
  ptrdiff_t __n = __l - __f;
  if (static_cast<size_type>(__n) <= size()) {
    _Traits::move(this->_M_Start(), __f, __n);
    erase(begin() + __n, end());
  }
  else {
    _Traits::move(this->_M_Start(), __f, size());
    _M_append(__f + size(), __l);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
_CharT* basic_string<_CharT,_Traits,_Alloc> ::_M_insert_aux(_CharT* __p,
                                                            _CharT __c) {
  pointer __new_pos = __p;
  if (this->_M_rest() > 1 ) {
    _M_construct_null(this->_M_finish + 1);
    _Traits::move(__p + 1, __p, this->_M_finish - __p);
    _Traits::assign(*__p, __c);
    ++this->_M_finish;
  }
  else {
    size_type __len = _M_compute_next_size(1);
    pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
    __new_pos = ::std::priv:: __ucopy(this->_M_Start(), __p, __new_start);
    _Traits::assign(*__new_pos, __c);
    pointer __new_finish = __new_pos + 1;
    __new_finish = ::std::priv:: __ucopy(__p, this->_M_finish, __new_finish);
    _M_construct_null(__new_finish);
    this->_M_deallocate_block();
    this->_M_reset(__new_start, __new_finish, __new_start + __len);
  }
  return __new_pos;
}

template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::insert(iterator __pos,
                                                 size_t __n, _CharT __c) {
  if (__n != 0) {
    if (this->_M_rest() > __n) {
      const size_type __elems_after = this->_M_finish - __pos;
      pointer __old_finish = this->_M_finish;
      if (__elems_after >= __n) {
        ::std::priv:: __ucopy((this->_M_finish - __n) + 1, this->_M_finish + 1, this->_M_finish + 1);
        this->_M_finish += __n;
        _Traits::move(__pos + __n, __pos, (__elems_after - __n) + 1);
        _Traits::assign(__pos, __n, __c);
      }
      else {
        ::std::priv:: __uninitialized_fill_n(this->_M_finish + 1, __n - __elems_after - 1, __c);
        this->_M_finish += __n - __elems_after;
        ::std::priv:: __ucopy(__pos, __old_finish + 1, this->_M_finish);
        this->_M_finish += __elems_after;
        _Traits::assign(__pos, __elems_after + 1, __c);
      }
    }
    else {
      size_type __len = _M_compute_next_size(__n);
      pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
      pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), __pos, __new_start);
      __new_finish = ::std::priv:: __uninitialized_fill_n(__new_finish, __n, __c);
      __new_finish = ::std::priv:: __ucopy(__pos, this->_M_finish, __new_finish);
      _M_construct_null(__new_finish);
      this->_M_deallocate_block();
      this->_M_reset(__new_start, __new_finish, __new_start + __len);
    }
  }
}

template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::_M_insert(iterator __pos,
                                                    const _CharT* __first, const _CharT* __last,
                                                    bool __self_ref) {
  
  if (__first != __last) {
    const size_t __n = __last - __first;
    if (this->_M_rest() > __n) {
      const size_t __elems_after = this->_M_finish - __pos;
      pointer __old_finish = this->_M_finish;
      if (__elems_after >= __n) {
        ::std::priv:: __ucopy((this->_M_finish - __n) + 1, this->_M_finish + 1, this->_M_finish + 1);
        this->_M_finish += __n;
        _Traits::move(__pos + __n, __pos, (__elems_after - __n) + 1);
        if (!__self_ref || __last < __pos) {
          _M_copy(__first, __last, __pos);
        }
        else {
          
          if (__first >= __pos) {
            
            __first += __n;
            __last += __n;
            _M_copy(__first, __last, __pos);
          }
          else {
            
            _M_move(__first, __last, __pos);
          }
        }
      }
      else {
        const_iterator __mid = __first;
        __mid += __elems_after + 1;
        ::std::priv:: __ucopy(__mid, __last, this->_M_finish + 1);
        this->_M_finish += __n - __elems_after;
        ::std::priv:: __ucopy(__pos, __old_finish + 1, this->_M_finish);
        this->_M_finish += __elems_after;
        if (!__self_ref)
          _M_copy(__first, __mid, __pos);
        else
          _M_move(__first, __mid, __pos);
      }
    }
    else {
      size_type __len = _M_compute_next_size(__n);
      pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
      pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), __pos, __new_start);
      __new_finish = ::std::priv:: __ucopy(__first, __last, __new_finish);
      __new_finish = ::std::priv:: __ucopy(__pos, this->_M_finish, __new_finish);
      _M_construct_null(__new_finish);
      this->_M_deallocate_block();
      this->_M_reset(__new_start, __new_finish, __new_start + __len);
    }
  }
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc> ::replace(iterator __first, iterator __last,
                                              size_type __n, _CharT __c) {
  size_type __len = (size_type)(__last - __first);

  if (__len >= __n) {
    _Traits::assign(__first, __n, __c);
    erase(__first + __n, __last);
  }
  else {
    _Traits::assign(__first, __len, __c);
    insert(__last, __n - __len, __c);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc> ::_M_replace(iterator __first, iterator __last,
                                                 const _CharT* __f, const _CharT* __l,
                                                 bool __self_ref) {
  const ptrdiff_t       __n = __l - __f;
  const difference_type __len = __last - __first;
  if (__len >= __n) {
    if (!__self_ref || __l < __first || __f >= __last)
      _M_copy(__f, __l, __first);
    else
      _M_move(__f, __l, __first);
    erase(__first + __n, __last);
  } else if (!__self_ref || (__f >= __last) || (__l <= __first)) { 
    const_iterator __m = __f + __len;
    _M_copy(__f, __m, __first);
    _M_insert(__last, __m, __l, __self_ref );
  } else if (__f < __first) { 
    const_iterator __m = __f + __len;
    
    const difference_type __off_dest = __first - this->begin();
    const difference_type __off_src = __f - this->begin();
    _M_insert(__last, __m, __l, true);
    _Traits::move(begin() + __off_dest, begin() + __off_src, __len);
  } else {
    const_iterator __m = __f + __len;
    _Traits::move(__first, __f, __len);
    _M_insert(__last, __m, __l, true);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::find( const _CharT* __s, size_type __pos,
                                                         size_type __n) const
{
  const size_t __len = size();
  if (__pos >= __len || __pos + __n > __len) {
    if ( __n == 0 && __pos <= __len ) { 
      return __pos;
    }
    return npos;
  }

  const_pointer __result =
    ::std::search(this->_M_Start() + __pos, this->_M_Finish(),
                      __s, __s + __n, ::std::priv:: _Eq_traits<_Traits>());
  return __result != this->_M_Finish() ? __result - this->_M_Start() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::find(_CharT __c, size_type __pos) const
{
  if (__pos >= size()) { 
    return npos;
  }

  const_pointer __result =
    ::std::find_if(this->_M_Start() + __pos, this->_M_Finish(),
                       ::std::priv:: _Eq_char_bound<_Traits>(__c));
  return __result != this->_M_Finish() ? __result - this->_M_Start() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::rfind(const _CharT* __s, size_type __pos,
                                                         size_type __n) const
{
  const size_type __len = size();
  if ( __len < __n ) {
    return npos;
  }
  const_pointer __last = this->_M_Start() + (min)( __len - __n, __pos) + __n;
  if ( __n == 0 ) { 
    return __last - this->_M_Start();
  }
  const_pointer __result = ::std::find_end(this->_M_Start(), __last,
                                               __s, __s + __n, ::std::priv:: _Eq_traits<_Traits>());
  return __result != __last ? __result - this->_M_Start() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::rfind(_CharT __c, size_type __pos) const
{
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const_reverse_iterator __rresult =
    ::std::find_if(const_reverse_iterator(__last), rend(),
                       ::std::priv:: _Eq_char_bound<_Traits>(__c));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_of(const _CharT* __s, size_type __pos,
                                                    size_type __n) const {
  if (__pos >= size()) 
    return npos;
  else {
    const_iterator __result = ::std::priv:: __str_find_first_of(begin() + __pos, end(),
                                                             __s, __s + __n,
                                                             static_cast<_Traits*>(0));
    return __result != end() ? __result - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc>
 typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_of(const _CharT* __s, size_type __pos,
                                                   size_type __n) const
{
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const const_reverse_iterator __rresult =
    ::std::priv:: __str_find_first_of(const_reverse_iterator(__last), rend(),
                                   __s, __s + __n,
                                   static_cast<_Traits*>(0));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(const _CharT* __s, size_type __pos,
                                                        size_type __n) const {
  typedef typename _Traits::char_type _CharType;
  if (__pos >= size()) 
    return npos;
  else {
    const_pointer __result = ::std::priv:: __str_find_first_not_of(this->_M_Start() + __pos, this->_M_Finish(),
                                                                static_cast<const _CharType*>(__s),
                                                                static_cast<const _CharType*>(__s) + __n,
                                                                static_cast<_Traits*>(0));
    return __result != this->_M_finish ? __result - this->_M_Start() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const {
  if (1 > size())
    return npos;
  else {
    const_pointer __result = ::std::find_if(this->_M_Start() + __pos, this->_M_Finish(),
                                                ::std::priv:: _Neq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_Start() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc>::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const_reverse_iterator __rlast = const_reverse_iterator(__last);
  const_reverse_iterator __rresult =
    ::std::priv:: __str_find_first_not_of(__rlast, rend(),
                                       static_cast<const _CharType*>(__s),
                                       static_cast<const _CharType*>(__s) + __n,
                                       static_cast<_Traits*>(0));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, size_type __pos) const
{
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const_reverse_iterator __rlast = const_reverse_iterator(__last);
  const_reverse_iterator __rresult =
    ::std::find_if(__rlast, rend(),
                       ::std::priv:: _Neq_char_bound<_Traits>(__c));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}


namespace priv {
#line 576 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

template <class _CharT, class _Traits, class _Alloc>
void __cdecl _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                               _CharT* __buf, size_t __n) {
  if (__n > 0) {
    __n = (min) (__n - 1, __s.size());
    ::std::copy(__s.begin(), __s.begin() + __n, __buf);
    __buf[__n] = _CharT();
  }
}

}

}

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_range_errors.h"

























#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_range_errors.h"




#line 33 "C:\\Pin35\\extras\\stlport\\include\\stl/_range_errors.h"

namespace std {
void   __cdecl __stl_throw_runtime_error(const char* __msg);
void   __cdecl __stl_throw_range_error(const char* __msg);
void   __cdecl __stl_throw_out_of_range(const char* __msg);
void   __cdecl __stl_throw_length_error(const char* __msg);
void   __cdecl __stl_throw_invalid_argument(const char* __msg);
void   __cdecl __stl_throw_overflow_error(const char* __msg);








#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/_range_errors.h"
}



#line 55 "C:\\Pin35\\extras\\stlport\\include\\stl/_range_errors.h"

#line 57 "C:\\Pin35\\extras\\stlport\\include\\stl/_range_errors.h"




#line 592 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

namespace std {

namespace priv {


template <class _Tp, class _Alloc>
void _String_base<_Tp,_Alloc>::_M_throw_length_error() const
{ __stl_throw_length_error("basic_string"); }

template <class _Tp, class _Alloc>
void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const
{ __stl_throw_out_of_range("basic_string"); }

template <class _Tp, class _Alloc>
void _String_base<_Tp, _Alloc>::_M_allocate_block(size_t __n) {
  if ((__n <= (max_size() + 1)) && (__n > 0)) {

    if (__n > _DEFAULT_SIZE) {
      this->_M_start_of_storage._M_data = _M_start_of_storage.allocate(__n, __n);
      this->_M_finish = this->_M_start_of_storage._M_data;
      this->_M_buffers._M_end_of_storage = this->_M_start_of_storage._M_data + __n;
    }




#line 620 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"
  } else {
    this->_M_throw_length_error();
  }
}


}
#line 628 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"








#line 637 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT* __s,
                                                    const allocator_type& __a)
  : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
  
  _M_range_initialize(__s, __s + traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT, _Traits, _Alloc>::basic_string(const basic_string<_CharT, _Traits, _Alloc> & __s)
  : ::std::priv:: _String_base<_CharT,_Alloc>(__s.get_allocator())
{ _M_range_initialize(__s._M_Start(), __s._M_Finish()); }




#line 655 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"




#line 660 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

}





#line 668 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"

#line 670 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.c"




#line 1184 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"
#line 1185 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"

#line 1187 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"







#line 30 "C:\\Pin35\\extras\\stlport\\include\\string"
#line 31 "C:\\Pin35\\extras\\stlport\\include\\string"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_hash.h"






















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_hash_fun.h"





































namespace std {

template <class _Key> struct hash { };

namespace priv {

inline size_t __stl_hash_string(const char* __s) {
  
  unsigned long __h = 0;
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}

}

template<>
struct hash<char*> {
  size_t operator()(const char* __s) const {
    
    return ::std::priv:: __stl_hash_string(__s);
  }
};

template<>
struct hash<const char*> {
  size_t operator()(const char* __s) const {
    
    return ::std::priv:: __stl_hash_string(__s);
  }
};

template<> struct hash<char> {
  size_t operator()(char __x) const { return __x; }
};
template<> struct hash<unsigned char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<signed char> {
  size_t operator()(unsigned char __x) const { return __x; }
};
#line 82 "C:\\Pin35\\extras\\stlport\\include\\stl/_hash_fun.h"
template<> struct hash<short> {
  size_t operator()(short __x) const { return __x; }
};
template<> struct hash<unsigned short> {
  size_t operator()(unsigned short __x) const { return __x; }
};
template<> struct hash<int> {
  size_t operator()(int __x) const { return __x; }
};





#line 97 "C:\\Pin35\\extras\\stlport\\include\\stl/_hash_fun.h"






template<> struct hash<size_t> {
  size_t operator()(size_t __x) const { return __x; }
};
#line 107 "C:\\Pin35\\extras\\stlport\\include\\stl/_hash_fun.h"

template<> struct hash<long> {
  size_t operator()(long __x) const { return __x; }
};
template<> struct hash<unsigned long> {
  size_t operator()(unsigned long __x) const { return __x; }
};


template<> struct hash<__int64> {
  size_t operator()(__int64 x) const { return (size_t)x; }
};
template<> struct hash<unsigned __int64> {
  size_t operator()(unsigned __int64 x) const { return (size_t)x; }
};
#line 123 "C:\\Pin35\\extras\\stlport\\include\\stl/_hash_fun.h"

template<>
struct hash<void *>
{
    union __vp {
        size_t s;
        void  *p;
    };

    size_t operator()(void *__x) const
      {
        __vp vp;
        vp.p = __x;
        return vp.s;
      }
};

}

#line 143 "C:\\Pin35\\extras\\stlport\\include\\stl/_hash_fun.h"




#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_hash.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_hash.h"





namespace std {

template <class _CharT, class _Traits, class _Alloc>
inline size_t
__stl_string_hash(const basic_string<_CharT,_Traits,_Alloc>& __s) {
  unsigned long __h = 0;
  size_t __len = __s.size();
  const _CharT* __data = __s.data();
  for ( size_t __i = 0; __i < __len; ++__i)
    __h = (__h << 2) + __h + __data[__i];
  return size_t(__h);
}


template <class _CharT, class _Traits, class _Alloc>
struct hash<basic_string<_CharT,_Traits,_Alloc> > {
  size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const
    { return __stl_string_hash(__s); }
};

















#line 68 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_hash.h"

}

#line 72 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_hash.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\string"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\string"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"






















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"






















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"





















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"
























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"



































































































































#line 133 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"




















#line 154 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"

#line 156 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"


namespace std {


class  exception {
public:

  exception() ;
  virtual ~exception() ;
  virtual const char* what() const ;




#line 172 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"
};


class  bad_exception : public exception {
public:

  bad_exception() ;
  ~bad_exception() ;
  const char* what() const ;




#line 186 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"
};


class __Named_exception;
}
#line 192 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"

#line 194 "C:\\Pin35\\extras\\stlport\\include\\stl/_exception.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"















#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"

namespace std {













#line 60 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"






#line 67 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"


class  __Named_exception : public exception {
public:
  __Named_exception(const string& __str);
  __Named_exception(const __Named_exception&);
  __Named_exception& operator = (const __Named_exception&);

  const char* what() const ;
  ~__Named_exception() ;

private:
  enum { _S_bufsize = 256 };
  char _M_static_name[_S_bufsize];
  char *_M_name;
};




#line 88 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"




#line 93 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"

}

#line 97 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"
#line 98 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"

#line 100 "C:\\Pin35\\extras\\stlport\\include\\stl/_stdexcept_base.h"
#line 23 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"
#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"


































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"










































#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"




































#line 81 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\os-apis/mutex.h"




































































































































































































































































































#line 82 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\os-apis/pin-tls.h"

















































































































































































#line 83 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
typedef size_t __stl_atomic_t;















































































































































#line 228 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"









#line 238 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"




#line 243 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

#line 245 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

#line 247 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
#line 248 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

namespace std {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };
  
  static unsigned __max;
  static unsigned __last;
  static void __cdecl _M_do_lock(volatile __stl_atomic_t* __lock);
  static void __cdecl _S_nsec_sleep(int __log_nsec, unsigned int& __iteration);
};
#line 264 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"















struct  _STLP_mutex_base {



#line 284 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"































#line 316 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  OS_MUTEX_TYPE _M_lock;
  inline void _M_initialize() { OS_MutexInit( &_M_lock ); }
  inline void _M_destroy() { OS_MutexDestroy( &_M_lock ); }

  
  
  

  
  

  
  

  inline void _M_acquire_lock() { OS_MutexLock( &_M_lock ); }
  inline void _M_release_lock() { OS_MutexUnlock( &_M_lock ); }





















































































#line 418 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"





#line 424 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
};




class  _STLP_mutex : public _STLP_mutex_base {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};







struct  _STLP_auto_lock {
  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
  { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock()
  { _M_lock._M_release_lock(); }

private:
  _STLP_mutex_base& _M_lock;
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};







class  _Refcount_Base {
  


#line 467 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  volatile __stl_atomic_t _M_ref_count;



  _STLP_mutex _M_mutex;
#line 475 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

  public:
  
  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}


#line 482 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

  




#line 489 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

  __stl_atomic_t _M_incr() {
    _STLP_auto_lock l(_M_mutex);
    return ++_M_ref_count;
  }
  __stl_atomic_t _M_decr() {
    _STLP_auto_lock l(_M_mutex);
    return --_M_ref_count;
  }
#line 499 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"



#line 503 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
};













template <int __use_ptr_atomic_swap>
class _Atomic_swap_struct {
public:


  static _STLP_mutex_base _S_swap_lock;
#line 527 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

  static __stl_atomic_t _S_swap(volatile __stl_atomic_t* __p, __stl_atomic_t __q) {



#line 533 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  _S_swap_lock._M_acquire_lock();
  __stl_atomic_t __result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;


#line 541 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"





#line 547 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  }

  static void* _S_swap_ptr(void* volatile* __p, void* __q) {



#line 554 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"




#line 559 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  _S_swap_lock._M_acquire_lock();
  void *__result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;


#line 567 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"





#line 573 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  }
};

template<>
class _Atomic_swap_struct<0> {
public:


  static _STLP_mutex_base _S_swap_lock;
#line 586 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

  static __stl_atomic_t _S_swap(volatile __stl_atomic_t* __p, __stl_atomic_t __q) {



#line 592 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  



  _S_swap_lock._M_acquire_lock();
  __stl_atomic_t __result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;


#line 604 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"





#line 610 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  }

  static void* _S_swap_ptr(void* volatile* __p, void* __q) {



#line 617 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"




#line 622 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  _S_swap_lock._M_acquire_lock();
  void *__result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;


#line 630 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"





#line 636 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
  }
};




#line 643 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

inline __stl_atomic_t __cdecl _Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  const int __use_ptr_atomic_swap = sizeof(__stl_atomic_t) == sizeof(void*);
  return _Atomic_swap_struct<__use_ptr_atomic_swap>::_S_swap(__p, __q);
}

inline void* __cdecl _Atomic_swap_ptr(void* volatile* __p, void* __q) {
  const int __use_ptr_atomic_swap = sizeof(__stl_atomic_t) == sizeof(void*);
  return _Atomic_swap_struct<__use_ptr_atomic_swap>::_S_swap_ptr(__p, __q);
}



#line 657 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"







































#line 697 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.c"



































































































































































#line 165 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.c"
#line 166 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.c"




#line 702 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"
#line 703 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"

#line 705 "C:\\Pin35\\extras\\stlport\\include\\stl/_threads.h"




#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"





#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string.h"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"




#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_iosfwd.h"































































































































































#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"

namespace std {



#line 12 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
template <class _CharT, class _InputIter = istreambuf_iterator<_CharT, char_traits<_CharT> > >
#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
class money_get;



#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
template <class _CharT, class _OutputIter = ostreambuf_iterator<_CharT, char_traits<_CharT> > >
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
class money_put;



#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
template <class _CharT, class _InputIter = istreambuf_iterator<_CharT, char_traits<_CharT> > >
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
class num_get;



#line 33 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
template <class _CharT, class _OutputIter = ostreambuf_iterator<_CharT, char_traits<_CharT> > >
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
class num_put;



#line 40 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
template <class _Ch, class _InIt = istreambuf_iterator<_Ch, char_traits<_Ch> > >
#line 42 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
class time_get;



#line 47 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
template <class _Ch, class _OutIt = ostreambuf_iterator<_Ch, char_traits<_Ch> > >
#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
class time_put;

}

#line 54 "C:\\Pin35\\extras\\stlport\\include\\stl/_facets_fwd.h"
#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"

namespace std {

class _Locale_impl;        
class locale;

template <class _CharT, class _Traits, class _Alloc>
bool __locale_do_operator_call(const locale& __loc,
                               const basic_string<_CharT, _Traits, _Alloc>& __x,
                               const basic_string<_CharT, _Traits, _Alloc>& __y);

 _Locale_impl * __cdecl _get_Locale_impl( _Locale_impl *locimpl );
 _Locale_impl * __cdecl _copy_Nameless_Locale_impl( _Locale_impl *locimpl );

namespace priv {

template <class _Facet>
bool _HasFacet(const locale& __loc, const _Facet* __facet) ;

template <class _Facet>
_Facet* _UseFacet(const locale& __loc, const _Facet* __facet);

template <class _Facet>
void _InsertFacet(locale& __loc, _Facet* __facet);

}



#line 76 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"

class  locale {
public:
  
  class  facet : protected _Refcount_Base {
  protected:
    



    explicit facet(size_t __init_count = 0) : _Refcount_Base( __init_count == 0 ? 0 : 1 ) {}
    virtual ~facet();
    friend class locale;
    friend class _Locale_impl;
    friend facet * __cdecl _get_facet( facet * );
    friend void __cdecl _release_facet( facet *& );

  private:                        
    facet(const facet& ) ;
    void operator=(const facet&);
  };



#line 101 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
  class
#line 103 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
   id {
  public:
    size_t _M_index;
    static size_t _S_max;
  };

  typedef int category;
  static const category none = 0x000;
  static const category collate = 0x010;
  static const category ctype = 0x020;
  static const category monetary = 0x040;
  static const category numeric = 0x100;
  static const category time = 0x200;
  static const category messages = 0x400;
  static const category all = collate | ctype | monetary | numeric | time | messages;

  
  locale() ;
  locale(const locale&) ;
  explicit locale(const char *);
  locale(const locale&, const char*, category);


  template <class _Facet>
  locale(const locale& __loc, _Facet* __f) {
    if ( __f != 0 ) {
      this->_M_impl = _get_Locale_impl( _copy_Nameless_Locale_impl( __loc._M_impl ) );
      ::std::priv:: _InsertFacet(*this, __f);
    } else {
      this->_M_impl = _get_Locale_impl( __loc._M_impl );
    }
  }
#line 136 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"

protected:
  
  locale(_Locale_impl*);

public:
  locale(const locale&, const locale&, category);
  const locale& operator=(const locale&) ;



#line 148 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
   ~locale() ;

public:

  template <class _Facet>
  locale combine(const locale& __loc) const {
    _Facet *__facet = 0;
    if (!::std::priv:: _HasFacet(__loc, __facet))
      _M_throw_on_combine_error(__loc.name());

    return locale(*this, ::std::priv:: _UseFacet(__loc, __facet));
  }
#line 162 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"

  
  string name() const;

  bool operator==(const locale&) const;
  bool operator!=(const locale&) const;






#line 175 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
  template <class _CharT, class _Traits, class _Alloc>
  bool operator()(const basic_string<_CharT, _Traits, _Alloc>& __x,
                  const basic_string<_CharT, _Traits, _Alloc>& __y) const
  { return __locale_do_operator_call(*this, __x, __y); }
#line 180 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"

  

  static locale __cdecl global(const locale&);


#line 187 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
  static const locale& __cdecl classic();


  facet* _M_get_facet(const id&) const;
  
  facet* _M_use_facet(const id&) const;
  static void  __cdecl _M_throw_on_combine_error(const string& name);
  static void  __cdecl _M_throw_on_null_name();
  static void  __cdecl _M_throw_on_creation_failure(int __err_code,
                                                                            const char* name, const char* facet);


  void _M_insert(facet* __f, id& __id);

  
  friend class _Locale_impl;

protected:                        
  _Locale_impl* _M_impl;
  _Locale_impl* _M_get_impl() const { return _M_impl; }
};









































































#line 283 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"




template <class _Facet>
inline const _Facet&



use_facet(const locale& __loc)
#line 294 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
{
  _Facet *__facet = 0;
  return *(::std::priv:: _UseFacet(__loc, __facet));
}

template <class _Facet>






inline bool has_facet(const locale& __loc) 
#line 308 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"
{
  _Facet *__facet = 0;
  return ::std::priv:: _HasFacet(__loc, __facet);
}





namespace priv {







template <class _Facet>
inline locale::id& _GetFacetId(const _Facet*)
{ return _Facet::id; }

 locale::id& __cdecl _GetFacetId(const money_get<char, istreambuf_iterator<char, char_traits<char> > >*);
 locale::id& __cdecl _GetFacetId(const money_put<char, ostreambuf_iterator<char, char_traits<char> > >*);
 locale::id& __cdecl _GetFacetId(const num_get<char, istreambuf_iterator<char, char_traits<char> > >*);
 locale::id& __cdecl _GetFacetId(const num_put<char, ostreambuf_iterator<char, char_traits<char> > >*);
 locale::id& __cdecl _GetFacetId(const time_get<char, istreambuf_iterator<char, char_traits<char> > >*);
 locale::id& __cdecl _GetFacetId(const time_put<char, ostreambuf_iterator<char, char_traits<char> > >*);


 locale::id& __cdecl _GetFacetId(const money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
 locale::id& __cdecl _GetFacetId(const money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
 locale::id& __cdecl _GetFacetId(const num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
 locale::id& __cdecl _GetFacetId(const num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
 locale::id& __cdecl _GetFacetId(const time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
 locale::id& __cdecl _GetFacetId(const time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
#line 344 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"

template <class _Facet>
inline bool _HasFacet(const locale& __loc, const _Facet* __facet) 
{ return (__loc._M_get_facet(_GetFacetId(__facet)) != 0); }

template <class _Facet>
inline _Facet* _UseFacet(const locale& __loc, const _Facet* __facet)
{ return static_cast<_Facet*>(__loc._M_use_facet(_GetFacetId(__facet))); }

template <class _Facet>
inline void _InsertFacet(locale& __loc, _Facet* __facet)
{ __loc._M_insert(__facet, _GetFacetId(__facet)); }

}

}

#line 362 "C:\\Pin35\\extras\\stlport\\include\\stl/_locale.h"





#line 31 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"
#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"





namespace std {










class  ios_base {
public:

  class  failure : public __Named_exception {
  public:
    explicit failure(const string&);
    virtual ~failure() ;
  };

  typedef int fmtflags;
  typedef int iostate;
  typedef int openmode;
  typedef int seekdir;


  typedef fmtflags fmt_flags;
#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"

  
  static const int left = 0x0001;
  static const int right = 0x0002;
  static const int internal = 0x0004;
  static const int dec = 0x0008;
  static const int hex = 0x0010;
  static const int oct = 0x0020;
  static const int fixed = 0x0040;
  static const int scientific = 0x0080;
  static const int boolalpha = 0x0100;
  static const int showbase = 0x0200;
  static const int showpoint = 0x0400;
  static const int showpos = 0x0800;
  static const int skipws = 0x1000;
  static const int unitbuf = 0x2000;
  static const int uppercase = 0x4000;
  static const int adjustfield = left | right | internal;
  static const int basefield = dec | hex | oct;
  static const int floatfield = scientific | fixed;

  
  static const int goodbit = 0x00;
  static const int badbit = 0x01;
  static const int eofbit = 0x02;
  static const int failbit = 0x04;

  
  static const int __default_mode = 0x0; 
  static const int app = 0x01;
  static const int ate = 0x02;
  static const int binary = 0x04;
  static const int in = 0x08;
  static const int out = 0x10;
  static const int trunc = 0x20;

  
  static const int beg = 0x01;
  static const int cur = 0x02;
  static const int end = 0x04;

public:                         
  fmtflags flags() const { return _M_fmtflags; }
  fmtflags flags(fmtflags __flags) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags = __flags;
    return __tmp;
  }

  fmtflags setf(fmtflags __flag) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags |= __flag;
    return __tmp;
  }
  fmtflags setf(fmtflags __flag, fmtflags __mask) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags &= ~__mask;
    _M_fmtflags |= __flag & __mask;
    return __tmp;
  }
  void unsetf(fmtflags __mask) { _M_fmtflags &= ~__mask; }

  streamsize precision() const { return _M_precision; }
  streamsize precision(streamsize __newprecision) {
    streamsize __tmp = _M_precision;
    _M_precision = __newprecision;
    return __tmp;
  }

  streamsize width() const { return _M_width; }
  streamsize width(streamsize __newwidth) {
    streamsize __tmp = _M_width;
    _M_width = __newwidth;
    return __tmp;
  }

public:                         
  locale imbue(const locale&);
  locale getloc() const { return _M_locale; }

public:                         
  static int __cdecl xalloc();
  long&  iword(int __index);
  void*& pword(int __index);

public:                         
  virtual ~ios_base();

public:                         
  enum event { erase_event, imbue_event, copyfmt_event };
  typedef void (*event_callback)(event, ios_base&, int __index);
  void register_callback(event_callback __fn, int __index);

public:                         
                                
                                
  static bool __cdecl sync_with_stdio(bool __sync = true);

public:                         
                                
                                
                                
  operator void*() const { return !fail() ? (void*) const_cast<ios_base*>(this) : (void*) 0; }
  bool operator!() const { return fail(); }

  iostate rdstate() const { return _M_iostate; }

  bool good() const { return _M_iostate == 0; }
  bool eof() const { return (_M_iostate & eofbit) != 0; }
  bool fail() const { return (_M_iostate & (failbit | badbit)) != 0; }
  bool bad() const { return (_M_iostate & badbit) != 0; }

protected:                      

  
  
  
  
  void _M_copy_state(const ios_base& __x);

  void _M_setstate_nothrow(iostate __state) { _M_iostate |= __state; }
  void _M_clear_nothrow(iostate __state) { _M_iostate = __state; }
  iostate _M_get_exception_mask() const { return _M_exception_mask; }
  void _M_set_exception_mask(iostate __mask) { _M_exception_mask = __mask; }
  void _M_check_exception_mask() {
    if (_M_iostate & _M_exception_mask)
      _M_throw_failure();
  }

  void _M_invoke_callbacks(event);
  void  _M_throw_failure();

  ios_base();                   

protected:                        
  static void __cdecl _S_initialize();
  static void __cdecl _S_uninitialize();
  static bool _S_is_synced;

private:                        
                                
  ios_base(const ios_base&);
  void operator=(const ios_base&);

private:                        

  fmtflags _M_fmtflags;         
  iostate _M_iostate;
  openmode _M_openmode;
  seekdir _M_seekdir;
  iostate _M_exception_mask;

  streamsize _M_precision;
  streamsize _M_width;

  locale _M_locale;

  pair<event_callback, int>* _M_callbacks;
  size_t _M_num_callbacks;      
  size_t _M_callback_index;     
                                

  long* _M_iwords;              
  size_t _M_num_iwords;         

  void** _M_pwords;
  size_t _M_num_pwords;

public:
  
  
  
  
  
  class  Init
  {
    public:
      Init();
      ~Init();
    private:
      static long _S_count;
      friend class ios_base;
  };

  friend class Init;

public:

  
  typedef iostate  io_state;
  typedef openmode open_mode;
  typedef seekdir  seek_dir;
  typedef ::std::streamoff  streamoff;
  typedef ::std::streampos  streampos;
#line 260 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"
};






inline ios_base& __cdecl boolalpha(ios_base& __s)
  { __s.setf(ios_base::boolalpha); return __s;}

inline ios_base& __cdecl noboolalpha(ios_base& __s)
  { __s.unsetf(ios_base::boolalpha); return __s;}

inline ios_base& __cdecl showbase(ios_base& __s)
  { __s.setf(ios_base::showbase); return __s;}

inline ios_base& __cdecl noshowbase(ios_base& __s)
  { __s.unsetf(ios_base::showbase); return __s;}

inline ios_base& __cdecl showpoint(ios_base& __s)
  { __s.setf(ios_base::showpoint); return __s;}

inline ios_base& __cdecl noshowpoint(ios_base& __s)
  { __s.unsetf(ios_base::showpoint); return __s;}

inline ios_base& __cdecl showpos(ios_base& __s)
  { __s.setf(ios_base::showpos); return __s;}

inline ios_base& __cdecl noshowpos(ios_base& __s)
  { __s.unsetf(ios_base::showpos); return __s;}

inline ios_base& __cdecl skipws(ios_base& __s)
  { __s.setf(ios_base::skipws); return __s;}

inline ios_base& __cdecl noskipws(ios_base& __s)
  { __s.unsetf(ios_base::skipws); return __s;}

inline ios_base& __cdecl uppercase(ios_base& __s)
  { __s.setf(ios_base::uppercase); return __s;}

inline ios_base& __cdecl nouppercase(ios_base& __s)
  { __s.unsetf(ios_base::uppercase); return __s;}

inline ios_base& __cdecl unitbuf(ios_base& __s)
  { __s.setf(ios_base::unitbuf); return __s;}

inline ios_base& __cdecl nounitbuf(ios_base& __s)
  { __s.unsetf(ios_base::unitbuf); return __s;}



inline ios_base& __cdecl internal(ios_base& __s)
  { __s.setf(ios_base::internal, ios_base::adjustfield); return __s; }

inline ios_base& __cdecl left(ios_base& __s)
  { __s.setf(ios_base::left, ios_base::adjustfield); return __s; }

inline ios_base& __cdecl right(ios_base& __s)
  { __s.setf(ios_base::right, ios_base::adjustfield); return __s; }


inline ios_base& __cdecl dec(ios_base& __s)
  { __s.setf(ios_base::dec, ios_base::basefield); return __s; }

inline ios_base& __cdecl hex(ios_base& __s)
  { __s.setf(ios_base::hex, ios_base::basefield); return __s; }

inline ios_base& __cdecl oct(ios_base& __s)
  { __s.setf(ios_base::oct, ios_base::basefield); return __s; }



inline ios_base& __cdecl fixed(ios_base& __s)
  { __s.setf(ios_base::fixed, ios_base::floatfield); return __s; }

inline ios_base& __cdecl scientific(ios_base& __s)
  { __s.setf(ios_base::scientific, ios_base::floatfield); return __s; }

}

#line 341 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios_base.h"





#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctype.h"

























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/c_locale.h"











































































#line 77 "C:\\Pin35\\extras\\stlport\\include\\stl/c_locale.h"

#line 79 "C:\\Pin35\\extras\\stlport\\include\\stl/c_locale.h"









struct _Locale_ctype;
struct _Locale_codecvt;
struct _Locale_numeric;
struct _Locale_time;
struct _Locale_collate;
struct _Locale_monetary;
struct _Locale_messages;




















#line 116 "C:\\Pin35\\extras\\stlport\\include\\stl/c_locale.h"













#line 130 "C:\\Pin35\\extras\\stlport\\include\\stl/c_locale.h"

#line 132 "C:\\Pin35\\extras\\stlport\\include\\stl/c_locale.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctype.h"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctype.h"









namespace std {

class  ctype_base {
public:
  enum mask {
    space   = 0x0001,
    print   = 0x0002,
    cntrl   = 0x0004,
    upper   = 0x0008,
    lower   = 0x0010,
    alpha   = 0x0020,
    digit   = 0x0040,
    punct   = 0x0080,
    xdigit  = 0x0100,
    alnum   = alpha | digit,
    graph   = alnum | punct
  };
};



template <class charT> class ctype {};
template <class charT> class ctype_byname {};



template<>
class  ctype<char> : public locale::facet, public ctype_base {


    typedef ctype<wchar_t> _Wctype;
    friend _Wctype;


#line 72 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctype.h"
#line 73 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctype.h"
public:

  typedef char char_type;

  explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
  bool is(mask __m, char __c) const
  { return ((*(_M_ctype_table+(unsigned char)__c)) & __m) != 0; }

  const char* is(const char* __low, const char* __high, mask* __vec) const {
    for (const char* __p = __low;__p != __high; ++__p, ++__vec) {
      *__vec = _M_ctype_table[(unsigned char)*__p];
    }
    return __high;
  }

  const char* scan_is(mask __m, const char* __low, const char* __high) const;
  const char* scan_not(mask __m, const char* __low, const char* __high) const;

  char        (toupper)(char __c) const { return do_toupper(__c); }
  const char* (toupper)(char* __low, const char* __high) const {
    return do_toupper(__low, __high);
  }

  char        (tolower)(char __c) const { return do_tolower(__c); }
  const char* (tolower)(char* __low, const char* __high) const {
    return do_tolower(__low, __high);
  }

  char        widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high, char* __to) const {
    return do_widen(__low, __high, __to);
  }

  char        narrow(char __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }
  const char* narrow(const char* __low, const char* __high,
                     char __dfault, char* __to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static  locale::id id;
  static const size_t table_size = 256;

protected:
  const mask* table() const  { return _M_ctype_table; }
  static const mask* __cdecl classic_table() ;

  ~ctype();

  virtual char        do_toupper(char __c) const;
  virtual char        do_tolower(char __c) const;
  virtual const char* do_toupper(char* __low, const char* __high) const;
  virtual const char* do_tolower(char* __low, const char* __high) const;
  virtual char        do_widen(char __c) const;
  virtual const char* do_widen(const char* __low, const char* __high,
                               char* __to) const;
  virtual char        do_narrow(char __c, char  ) const;
  virtual const char* do_narrow(const char* __low, const char* __high,
                                char , char* __to) const;
private:
  struct _Is_mask {
    mask __m;
    _Is_mask(mask __x): __m(__x) {}
   bool operator()(char __c) {return (__m & (unsigned char) __c) != 0;}
  };

protected:
  const mask* _M_ctype_table;
private:
  bool _M_delete;
};

template<>
class  ctype_byname<char>: public ctype<char> {
  friend class _Locale_impl;
public:
  explicit ctype_byname(const char*, size_t = 0);
  ~ctype_byname();

  virtual char        do_toupper(char __c) const;
  virtual char        do_tolower(char __c) const;

  virtual const char* do_toupper(char*, const char*) const;
  virtual const char* do_tolower(char*, const char*) const;

private:
  ctype_byname(_Locale_ctype* __ctype)
    : _M_ctype(__ctype)
  { _M_init(); }

  void _M_init();

  
  typedef ctype_byname<char> _Self;
  ctype_byname(_Self const&);
  _Self& operator = (_Self const&);

  mask _M_byname_table[table_size];
  _Locale_ctype* _M_ctype;
};


template<>
class  ctype<wchar_t> : public locale::facet, public ctype_base {
public:
  typedef wchar_t char_type;

  explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  bool is(mask __m, wchar_t __c) const
    { return do_is(__m, __c); }

  const wchar_t* is(const wchar_t* __low, const wchar_t* __high,
                    mask* __vec) const
    { return do_is(__low, __high, __vec); }

  const wchar_t* scan_is(mask __m,
                         const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_is(__m, __low, __high); }

  const wchar_t* scan_not (mask __m,
                           const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_not(__m, __low, __high); }

  wchar_t (toupper)(wchar_t __c) const { return do_toupper(__c); }
  const wchar_t* (toupper)(wchar_t* __low, const wchar_t* __high) const
    { return do_toupper(__low, __high); }

  wchar_t (tolower)(wchar_t __c) const { return do_tolower(__c); }
  const wchar_t* (tolower)(wchar_t* __low, const wchar_t* __high) const
    { return do_tolower(__low, __high); }

  wchar_t widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high,
                    wchar_t* __to) const
    { return do_widen(__low, __high, __to); }

  char narrow(wchar_t __c, char __dfault) const
    { return do_narrow(__c, __dfault); }
  const wchar_t* narrow(const wchar_t* __low, const wchar_t* __high,
                        char __dfault, char* __to) const
    { return do_narrow(__low, __high, __dfault, __to); }

  static  locale::id id;

protected:
  ~ctype();

  virtual bool           do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_widen(char c) const;
  virtual const char* do_widen(const char*, const char*, wchar_t*) const;
  virtual char  do_narrow(wchar_t __c, char __dfault) const;
  virtual const wchar_t* do_narrow(const wchar_t*, const wchar_t*,
                                   char, char*) const;
};

template<>
class  ctype_byname<wchar_t>: public ctype<wchar_t> {
  friend class _Locale_impl;
public:
  explicit ctype_byname(const char* __name, size_t __refs = 0);

protected:
  ~ctype_byname();

  virtual bool           do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;

private:
  ctype_byname(_Locale_ctype* __ctype)
    : _M_ctype(__ctype) {}

  
  typedef ctype_byname<wchar_t> _Self;
  ctype_byname(_Self const&);
  _Self& operator = (_Self const&);

  _Locale_ctype* _M_ctype;
};

#line 272 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctype.h"

}

#line 276 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctype.h"





#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"
#line 29 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_numpunct.h"





































namespace std {




template <class _CharT> class numpunct {};
template <class _CharT> class numpunct_byname {};
template <class _Ch, class _InIt> class num_get;

template<>
class  numpunct<char> : public locale::facet {
public:
  typedef char               char_type;
  typedef string             string_type;

  explicit numpunct(size_t __refs = 0)
    : locale::facet(__refs) {}

  char decimal_point() const { return do_decimal_point(); }
  char thousands_sep() const { return do_thousands_sep(); }
  string grouping() const { return do_grouping(); }
  string truename() const { return do_truename(); }
  string falsename() const { return do_falsename(); }

  static  locale::id id;

protected:
  ~numpunct();

  virtual char do_decimal_point() const;
  virtual char do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string do_truename() const;
  virtual string do_falsename()  const;
};



template<>
class  numpunct<wchar_t> : public locale::facet {
public:
  typedef wchar_t               char_type;
  typedef wstring               string_type;

  explicit numpunct(size_t __refs = 0)
    : locale::facet(__refs) {}

  wchar_t decimal_point() const { return do_decimal_point(); }
  wchar_t thousands_sep() const { return do_thousands_sep(); }
  string grouping() const { return do_grouping(); }
  wstring truename() const { return do_truename(); }
  wstring falsename() const { return do_falsename(); }

  static  locale::id id;

protected:
  ~numpunct();

  virtual wchar_t do_decimal_point() const;
  virtual wchar_t do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual wstring do_truename() const;
  virtual wstring do_falsename()  const;
};

#line 104 "C:\\Pin35\\extras\\stlport\\include\\stl/_numpunct.h"

template<>
class  numpunct_byname<char> : public numpunct<char> {
  friend class _Locale_impl;
public:
  typedef char                char_type;
  typedef string              string_type;

  explicit numpunct_byname(const char* __name, size_t __refs = 0);

protected:

  ~numpunct_byname();

  virtual char   do_decimal_point() const;
  virtual char   do_thousands_sep() const;
  virtual string do_grouping()      const;
  virtual string do_truename()      const;
  virtual string do_falsename()     const;

private:
  numpunct_byname(_Locale_numeric *__numeric)
    : _M_numeric(__numeric) {}

  
  typedef numpunct_byname<char> _Self;
  numpunct_byname(_Self const&);
  _Self& operator = (_Self const&);

  _Locale_numeric* _M_numeric;
};


template<>
class  numpunct_byname<wchar_t>: public numpunct<wchar_t> {
  friend class _Locale_impl;
public:
  typedef wchar_t               char_type;
  typedef wstring               string_type;

  explicit numpunct_byname(const char* __name, size_t __refs = 0);

protected:
  ~numpunct_byname();

  virtual wchar_t   do_decimal_point() const;
  virtual wchar_t   do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual wstring do_truename() const;
  virtual wstring do_falsename() const;

private:
  numpunct_byname(_Locale_numeric *__numeric)
    : _M_numeric(__numeric) {}

  
  typedef numpunct_byname<wchar_t> _Self;
  numpunct_byname(_Self const&);
  _Self& operator = (_Self const&);

  _Locale_numeric* _M_numeric;
};

#line 168 "C:\\Pin35\\extras\\stlport\\include\\stl/_numpunct.h"

}

#line 172 "C:\\Pin35\\extras\\stlport\\include\\stl/_numpunct.h"





#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"
#line 33 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"

namespace std {












template <class _CharT, class _Traits>
class basic_ios : public ios_base {
  friend class ios_base;
public:                         
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;

public:                         
  explicit basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf);
  virtual ~basic_ios() {}

public:                         
  basic_ostream<_CharT, _Traits>* tie() const {
    return _M_tied_ostream;
  }
  basic_ostream<_CharT, _Traits>*
  tie(basic_ostream<char_type, traits_type>* __new_tied_ostream) {
    basic_ostream<char_type, traits_type>* __tmp = _M_tied_ostream;
    _M_tied_ostream = __new_tied_ostream;
    return __tmp;
  }

  basic_streambuf<_CharT, _Traits>* rdbuf() const
    { return _M_streambuf; }

  basic_streambuf<_CharT, _Traits>*
  rdbuf(basic_streambuf<char_type, traits_type>*);

  
  basic_ios<_CharT, _Traits>& copyfmt(const basic_ios<_CharT, _Traits>& __x);

  char_type fill() const { return _M_fill; }
  char_type fill(char_type __fill) {
    char_type __tmp(_M_fill);
    _M_fill = __fill;
    return __tmp;
  }

public:                         
                                

  void clear(iostate __state = goodbit) {
    _M_clear_nothrow(this->rdbuf() ? __state : iostate(__state|ios_base::badbit));
    _M_check_exception_mask();
  }
  void setstate(iostate __state) { this->clear(rdstate() | __state); }

  iostate exceptions() const { return this->_M_get_exception_mask(); }
  void exceptions(iostate __mask) {
    this->_M_set_exception_mask(__mask);
    this->clear(this->rdstate());
  }

public:                         
  locale imbue(const locale&);

  inline char narrow(_CharT, char) const ;
  inline _CharT widen(char) const;

  
  static bool __cdecl _S_eof(int_type __c) {
    const int_type __eof = _Traits::eof();
    return _Traits::eq_int_type(__c, __eof);
  }

protected:
  
  const ctype<char_type>* _M_cached_ctype;

public:
  
  const ctype<char_type>* _M_ctype_facet() const { return _M_cached_ctype; }

protected:
  basic_ios();

  void init(basic_streambuf<_CharT, _Traits>* __streambuf);

public:

  
  
  void _M_handle_exception(ios_base::iostate __flag);

private:                        
  char_type _M_fill;            

  basic_streambuf<_CharT, _Traits>* _M_streambuf;
  basic_ostream<_CharT, _Traits>*   _M_tied_ostream;

};


template <class _CharT, class _Traits>
inline char
basic_ios<_CharT, _Traits>::narrow(_CharT __c, char __default) const
{ return _M_ctype_facet()->narrow(__c, __default); }

template <class _CharT, class _Traits>
inline _CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{ return _M_ctype_facet()->widen(__c); }


template<>
inline char
basic_ios<char, char_traits<char> >::narrow(char __c, char) const
{
  return __c;
}

template<>
inline char
basic_ios<char, char_traits<char> >::widen(char __c) const
{
  return __c;
}
#line 168 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"






#line 175 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.c"

























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"
























namespace std {





















template <class _CharT, class _Traits>
class basic_streambuf {
  friend class basic_istream<_CharT, _Traits>;
  friend class basic_ostream<_CharT, _Traits>;

public:                         
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;

private:                        

  char_type* _M_gbegin;         
  char_type* _M_gnext;          
  char_type* _M_gend;           

  char_type* _M_pbegin;         
  char_type* _M_pnext;          
  char_type* _M_pend;           

  locale _M_locale;             

public:                         
  virtual ~basic_streambuf();

protected:                      
  basic_streambuf()






#line 83 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"
  ;
#line 85 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"

protected:                      
  char_type* eback() const { return _M_gbegin; } 
  char_type* gptr()  const { return _M_gnext; }  
  char_type* egptr() const { return _M_gend; }   

  void gbump(int __n) { _M_gnext += __n; }
  void setg(char_type* __gbegin, char_type* __gnext, char_type* __gend) {
    _M_gbegin = __gbegin;
    _M_gnext  = __gnext;
    _M_gend   = __gend;
  }

public:
  
  
  
  char_type* _M_eback() const { return eback(); }
  char_type* _M_gptr()  const { return gptr(); }
  char_type* _M_egptr() const { return egptr(); }
  void _M_gbump(int __n)      { gbump(__n); }
  void _M_setg(char_type* __gbegin, char_type* __gnext, char_type* __gend)
  { this->setg(__gbegin, __gnext, __gend); }

protected:                      

  char_type* pbase() const { return _M_pbegin; } 
  char_type* pptr()  const { return _M_pnext; }  
  char_type* epptr() const { return _M_pend; }   

  void pbump(int __n) { _M_pnext += __n; }
  void setp(char_type* __pbegin, char_type* __pend) {
    _M_pbegin = __pbegin;
    _M_pnext  = __pbegin;
    _M_pend   = __pend;
  }

protected:                      

  virtual basic_streambuf<_CharT, _Traits>* setbuf(char_type*, streamsize);

  
  
  virtual pos_type seekoff(off_type, ios_base::seekdir,
                           ios_base::openmode = ios_base::in | ios_base::out);

  
  
  virtual pos_type
  seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out);

  
  
  virtual int sync();


public:                         
  basic_streambuf<_CharT, _Traits>* pubsetbuf(char_type* __s, streamsize __n)
  { return this->setbuf(__s, __n); }

  pos_type pubseekoff(off_type __offset, ios_base::seekdir __way,
                      ios_base::openmode __mod = ios_base::in | ios_base::out)
  { return this->seekoff(__offset, __way, __mod); }

  pos_type pubseekpos(pos_type __sp,
                      ios_base::openmode __mod = ios_base::in | ios_base::out)
  { return this->seekpos(__sp, __mod); }

  int pubsync() { return this->sync(); }

protected:                      
                                
  
  
  
  
  virtual streamsize showmanyc();

  
  
  virtual streamsize xsgetn(char_type* __s, streamsize __n);

  
  
  
  virtual int_type underflow();

  
  
  virtual int_type uflow();

  
  
  
  virtual int_type pbackfail(int_type = traits_type::eof());

protected:                      
                                

  
  
  virtual streamsize xsputn(const char_type* __s, streamsize __n);

  
  
  virtual streamsize _M_xsputnc(char_type __c, streamsize __n);

  
  
  virtual int_type overflow(int_type = traits_type::eof());

public:                         
  
  int_type sputc(char_type __c) {
    return ((_M_pnext < _M_pend) ? _Traits::to_int_type(*_M_pnext++ = __c)
      : this->overflow(_Traits::to_int_type(__c)));
  }

  
  streamsize sputn(const char_type* __s, streamsize __n)
  { return this->xsputn(__s, __n); }

  
  streamsize _M_sputnc(char_type __c, streamsize __n)
  { return this->_M_xsputnc(__c, __n); }

private:                        
  int_type _M_snextc_aux();

public:                         
  streamsize in_avail() {
    return (_M_gnext < _M_gend) ? (_M_gend - _M_gnext) : this->showmanyc();
  }

  
  int_type snextc() {
  return ( _M_gend - _M_gnext > 1 ?
             _Traits::to_int_type(*++_M_gnext) :
             this->_M_snextc_aux());
  }

  
  int_type sbumpc() {
    return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext++)
      : this->uflow();
  }

  
  int_type sgetc() {
    return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext)
      : this->underflow();
  }

  streamsize sgetn(char_type* __s, streamsize __n)
  { return this->xsgetn(__s, __n); }

  int_type sputbackc(char_type __c) {
    return ((_M_gbegin < _M_gnext) && _Traits::eq(__c, *(_M_gnext - 1)))
      ? _Traits::to_int_type(*--_M_gnext)
      : this->pbackfail(_Traits::to_int_type(__c));
  }

  int_type sungetc() {
    return (_M_gbegin < _M_gnext)
      ? _Traits::to_int_type(*--_M_gnext)
      : this->pbackfail();
  }

protected:                      

  
  
  
  
  virtual void imbue(const locale&);

public:                         
  locale pubimbue(const locale&);
  locale getloc() const { return _M_locale; }


  void stossc() { this->sbumpc(); }
#line 268 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"
};






#line 276 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.c"
























namespace std {




template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
  : _M_gbegin(0), _M_gnext(0), _M_gend(0),
    _M_pbegin(0), _M_pnext(0), _M_pend(0),
    _M_locale() {
  
}
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.c"

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{}

template <class _CharT, class _Traits>
locale
basic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc) {
  this->imbue(__loc);
  locale __tmp = _M_locale;
  _M_locale = __loc;
  return __tmp;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(_CharT* __s, streamsize __n) {
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_gnext < _M_gend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_gend - _M_gnext),
                              static_cast<size_t>(__n - __result));
      _Traits::copy(__s, _M_gnext, __chunk);
      __result += __chunk;
      __s += __chunk;
      _M_gnext += __chunk;
    }
    else {
      int_type __c = this->sbumpc();
      if (!_Traits::eq_int_type(__c, __eof)) {
        *__s = _Traits::to_char_type(__c);
        ++__result;
        ++__s;
      }
      else
        break;
    }
  }

  return __result;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const _CharT* __s, streamsize __n)
{
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_pnext < _M_pend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_pend - _M_pnext),
                           static_cast<size_t>(__n - __result));
      _Traits::copy(_M_pnext, __s, __chunk);
      __result += __chunk;
      __s += __chunk;
      _M_pnext += __chunk;
    }

    else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(*__s)),
                                   __eof)) {
      ++__result;
      ++__s;
    }
    else
      break;
  }
  return __result;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::_M_xsputnc(_CharT __c, streamsize __n)
{
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_pnext < _M_pend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_pend - _M_pnext),
                           static_cast<size_t>(__n - __result));
      _Traits::assign(_M_pnext, __chunk, __c);
      __result += __chunk;
      _M_pnext += __chunk;
    }

    else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(__c)),
                                   __eof))
      ++__result;
    else
      break;
  }
  return __result;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::_M_snextc_aux()
{
  int_type __eof = _Traits::eof();
  if (_M_gend == _M_gnext)
    return _Traits::eq_int_type(this->uflow(), __eof) ? __eof : this->sgetc();
  else {
    _M_gnext = _M_gend;
    return this->underflow();
  }
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type) {
 return _Traits::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type) {
  return _Traits::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow() {
    return ( _Traits::eq_int_type(this->underflow(),_Traits::eof()) ?
             _Traits::eof() :
             _Traits::to_int_type(*_M_gnext++));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{ return _Traits::eof(); }

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{ return 0; }

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&) {}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync() { return 0; }

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{ return pos_type(-1); }

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{ return pos_type(-1); }

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>:: setbuf(char_type*, streamsize)
{ return this; }

}

#line 205 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.c"




#line 281 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"
#line 282 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"

#line 284 "C:\\Pin35\\extras\\stlport\\include\\stl/_streambuf.h"




#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.c"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.c"





namespace std {




template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>
  ::basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf)
    : ios_base(), _M_cached_ctype(0),
      _M_fill(_CharT()), _M_streambuf(0), _M_tied_ostream(0) {
  basic_ios<_CharT, _Traits>::init(__streambuf);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __buf) {
  basic_streambuf<_CharT, _Traits>* __tmp = _M_streambuf;
  _M_streambuf = __buf;
  this->clear();
  return __tmp;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits>& __x) {
  _M_invoke_callbacks(erase_event);
  _M_copy_state(__x);           
  _M_cached_ctype = __x._M_cached_ctype;
  _M_fill = __x._M_fill;
  _M_tied_ostream = __x._M_tied_ostream;
  _M_invoke_callbacks(copyfmt_event);
  this->_M_set_exception_mask(__x.exceptions());
  return *this;
}

template <class _CharT, class _Traits>
locale basic_ios<_CharT, _Traits>::imbue(const locale& __loc) {
  locale __tmp = ios_base::imbue(__loc);
   {
    if (_M_streambuf)
      _M_streambuf->pubimbue(__loc);

    
    _M_cached_ctype = &use_facet<ctype<char_type> >(__loc);
  }
  if (false) {
    __tmp = ios_base::imbue(__tmp);
    _M_handle_exception(ios_base::failbit);
  }
  return __tmp;
}





template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::basic_ios()
  : ios_base(),
    _M_fill(_CharT()), _M_streambuf(0), _M_tied_ostream(0)
{}

template <class _CharT, class _Traits>
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
{
  this->rdbuf(__sb);
  this->imbue(locale());
  this->tie(0);
  this->_M_set_exception_mask(ios_base::goodbit);
  this->_M_clear_nothrow(__sb != 0 ? ios_base::goodbit : ios_base::badbit);
  ios_base::flags(ios_base::skipws | ios_base::dec);
  ios_base::width(0);
  ios_base::precision(6);
  this->fill(widen(' '));
  
  
}


template <class _CharT, class _Traits>
void basic_ios<_CharT, _Traits>::_M_handle_exception(ios_base::iostate __flag)
{
  this->_M_setstate_nothrow(__flag);
  if (this->_M_get_exception_mask() & __flag)
    abort();
}

}

#line 124 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.c"




#line 180 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"
#line 181 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"

#line 183 "C:\\Pin35\\extras\\stlport\\include\\stl/_ios.h"





#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostreambuf_iterator.h"





























namespace std {

namespace priv {

template<class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* __cdecl __get_ostreambuf(basic_ostream<_CharT, _Traits>&);

}


template <class _CharT, class _Traits>
class ostreambuf_iterator :
  public iterator<output_iterator_tag, void, void, void, void> {
public:
  typedef _CharT                           char_type;
  typedef _Traits                          traits_type;
  typedef typename _Traits::int_type       int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_ostream<_CharT, _Traits>   ostream_type;

  typedef output_iterator_tag              iterator_category;
  typedef void                             value_type;
  typedef void                             difference_type;
  typedef void                             pointer;
  typedef void                             reference;

public:
  ostreambuf_iterator(streambuf_type* __buf)  : _M_buf(__buf), _M_ok(__buf!=0) {}
  
  inline ostreambuf_iterator(ostream_type& __o) ;

  ostreambuf_iterator<_CharT, _Traits>& operator=(char_type __c) {
    _M_ok = _M_ok && !traits_type::eq_int_type(_M_buf->sputc(__c),
                                               traits_type::eof());
    return *this;
  }

  ostreambuf_iterator<_CharT, _Traits>& operator*()     { return *this; }
  ostreambuf_iterator<_CharT, _Traits>& operator++()    { return *this; }
  ostreambuf_iterator<_CharT, _Traits>& operator++(int) { return *this; }

  bool failed() const { return !_M_ok; }

private:
  streambuf_type* _M_buf;
  bool _M_ok;
};

template <class _CharT, class _Traits>
inline ostreambuf_iterator<_CharT, _Traits>::ostreambuf_iterator(basic_ostream<_CharT, _Traits>& __o) 
  : _M_buf(::std::priv:: __get_ostreambuf(__o)), _M_ok(_M_buf != 0) {}






#line 88 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostreambuf_iterator.h"





#line 94 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostreambuf_iterator.h"

}

#line 98 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostreambuf_iterator.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"



#line 38 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"

namespace std {




#line 45 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"

namespace priv {

template <class _CharT, class _Traits>
bool __init_bostr(basic_ostream<_CharT, _Traits>& __str);

}




template <class _CharT, class _Traits>
class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
  typedef basic_ostream<_CharT, _Traits> _Self;





#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"

public:                         
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

public:                         
  explicit basic_ostream(basic_streambuf<_CharT, _Traits>* __buf);
  ~basic_ostream();

public:                         
  typedef basic_ios<_CharT, _Traits>& (__cdecl *__ios_fn)(basic_ios<_CharT, _Traits>&);
  typedef ios_base& (__cdecl *__ios_base_fn)(ios_base&);
  typedef _Self& (__cdecl *__ostream_fn)(_Self&);
  _Self& operator<< (__ostream_fn __f) { return __f(*this); }
  _Self & operator<< (__ios_base_fn __f) { __f(*this); return *this; }
  _Self& operator<< (__ios_fn __ff) { __ff(*this); return *this; }

private:
  bool _M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
                        basic_streambuf<_CharT, _Traits>* __to);
  bool _M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
                          basic_streambuf<_CharT, _Traits>* __to);

public:
  void _M_put_char(_CharT __c);

  void _M_put_nowiden(const _CharT* __s);
  void _M_put_widen(const char* __s);
  bool _M_put_widen_aux(const char* __s, streamsize __n);

public:                         
  _Self& put(char_type __c);
  _Self& write(const char_type* __s, streamsize __n);

public:                         
  
  _Self& operator<<(basic_streambuf<_CharT, _Traits>* __buf);

  
  _Self& operator<<(unsigned char __x) { _M_put_char(__x); return *this; }
#line 110 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
  _Self& operator<<(short __x);
  _Self& operator<<(unsigned short __x);
  _Self& operator<<(int __x);


#line 116 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"



  _Self& operator<<(size_t __x);
#line 121 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
  _Self& operator<<(long __x);
  _Self& operator<<(unsigned long __x);

  _Self& operator<< (__int64 __x);
  _Self& operator<< (unsigned __int64 __x);
#line 127 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
  _Self& operator<<(float __x);
  _Self& operator<<(double __x);



  _Self& operator<<(const void* __x);

  _Self& operator<<(bool __x);
#line 136 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"

public:                         
  _Self& flush() {
    if (this->rdbuf())
      if (this->rdbuf()->pubsync() == -1)
        this->setstate(ios_base::badbit);
    return *this;
  }

  pos_type tellp() {
    return this->rdbuf() && !this->fail()
      ? this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out)
      : pos_type(-1);
  }

  _Self& seekp(pos_type __pos) {
    if (this->rdbuf() && !this->fail()) {
      if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1)) {
        this->setstate(ios_base::failbit);
      }
    }
    return *this;
  }

  _Self& seekp(off_type __off, ios_base::seekdir __dir) {
    if (this->rdbuf() && !this->fail())
      this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
    return *this;
  }










#line 176 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
    class sentry {
      typedef sentry _Self;
#line 179 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
    private:
      basic_ostream<_CharT, _Traits>& _M_str;
      
      bool _M_ok;
    public:
      explicit sentry(basic_ostream<_CharT, _Traits>& __str)
        : _M_str(__str),  _M_ok(::std::priv:: __init_bostr(__str))
      {}

      ~sentry() {
        if (_M_str.flags() & ios_base::unitbuf)


#line 193 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
            _M_str.flush();
      }

      operator bool() const { return _M_ok; }
    private:                        
      
      sentry(const _Self& __s) : _M_str(__s._M_str) {}
      _Self& operator=(const _Self&) { return *this; }
    };


#line 205 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
  
};
#line 208 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"








#line 217 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"

namespace priv {


template <class _CharT, class _Traits>
bool __init_bostr(basic_ostream<_CharT, _Traits>& __str) {
  if (__str.good()) {
    
    if (!__str.rdbuf())
      __str.setstate(ios_base::badbit);
    if (__str.tie())
      __str.tie()->flush();
    return __str.good();
  }
  else
    return false;
}

template <class _CharT, class _Traits>
inline basic_streambuf<_CharT, _Traits>* __cdecl
__get_ostreambuf(basic_ostream<_CharT, _Traits>& __St)
{ return __St.rdbuf(); }

}


template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c){
  __os._M_put_char(__c);
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __s) {
  __os._M_put_nowiden(__s);
  return __os;
}








































#line 297 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"


template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os, char __c) {
  __os._M_put_char(__os.widen(__c));
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>& __cdecl
operator<<(basic_ostream<char, _Traits>& __os, char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>& __cdecl
operator<<(basic_ostream<char, _Traits>& __os, signed char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>& __cdecl
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __s) {
  __os._M_put_widen(__s);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>& __cdecl
operator<<(basic_ostream<char, _Traits>& __os, const char* __s) {
  __os._M_put_nowiden(__s);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>& __cdecl
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __s) {
  __os._M_put_nowiden(reinterpret_cast<const char*>(__s));
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __s) {
  __os._M_put_nowiden(reinterpret_cast<const char*>(__s));
  return __os;
}
#line 355 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"




template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
endl(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(__os.widen('\n'));
  __os.flush();
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
ends(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(_CharT());
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
flush(basic_ostream<_CharT, _Traits>& __os) {
  __os.flush();
  return __os;
}

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"

























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"






































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_iostream_string.h"















 



















namespace std {

namespace priv {

template <class _CharT>
class __iostring_allocator : public allocator<_CharT> {
public:
  enum { _STR_SIZE = 256 };

private:
  enum { _BUF_SIZE = _STR_SIZE + 1 };
  typedef allocator<_CharT> _Base;
  _CharT _M_static_buf[_BUF_SIZE];

public:
  typedef typename _Base::size_type size_type;
  typedef typename _Base::pointer pointer;

  template <class _Tp1> struct rebind {

    typedef __iostring_allocator<_Tp1> other;


#line 60 "C:\\Pin35\\extras\\stlport\\include\\stl/_iostream_string.h"
  };
#line 62 "C:\\Pin35\\extras\\stlport\\include\\stl/_iostream_string.h"

  _CharT* allocate(size_type __n, const void* __ptr = 0) {
    if (__n > _BUF_SIZE) {
      return _Base::allocate(__n, __ptr);
    }
    return _M_static_buf;
  }
  void deallocate(pointer __p, size_type __n) {
    if (__p != _M_static_buf) _Base::deallocate(__p, __n);
  }
};




















#line 94 "C:\\Pin35\\extras\\stlport\\include\\stl/_iostream_string.h"


template <class _CharT>
struct __basic_iostring : public basic_string<_CharT, char_traits<_CharT>, __iostring_allocator<_CharT> > {
  





  typedef __basic_iostring<_CharT> _Self;
  typedef basic_string<_CharT, char_traits<_CharT>, __iostring_allocator<_CharT> > _Base;
  typedef typename _Base::_Reserve_t _Reserve_t;

  __basic_iostring() : _Base(_Reserve_t(), __iostring_allocator<_CharT>::_STR_SIZE)
  {}

  _Self& operator=(const _CharT* __s) {
    _Base::operator=(__s);
    return *this;
  }
};

typedef __basic_iostring<char> __iostring;


typedef __basic_iostring<wchar_t> __iowstring;
#line 122 "C:\\Pin35\\extras\\stlport\\include\\stl/_iostream_string.h"












#line 135 "C:\\Pin35\\extras\\stlport\\include\\stl/_iostream_string.h"

}

}

#line 141 "C:\\Pin35\\extras\\stlport\\include\\stl/_iostream_string.h"
#line 40 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"





namespace std {




template <class _CharT, class _OutputIter>
class num_put: public locale::facet {
public:
  typedef _CharT      char_type;
  typedef _OutputIter iter_type;

  explicit num_put(size_t __refs = 0) : locale::facet(__refs) {}


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                bool __val) const {
    return do_put(__s, __f, __fill, __val);
  }
#line 65 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"
  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
               long __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                unsigned long __val) const {
    return do_put(__s, __f, __fill, __val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                __int64 __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                unsigned __int64 __val) const {
    return do_put(__s, __f, __fill, __val);
  }
#line 86 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                double __val) const {
    return do_put(__s, __f, __fill, (double)__val);
  }






#line 98 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                const void * __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  static locale::id id;

protected:
  ~num_put() {}

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, bool __val) const;
#line 111 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, unsigned long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, double __val) const;


#line 117 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"


  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, __int64 __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                           unsigned __int64 __val) const ;
#line 123 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, const void* __val) const;
};






#line 132 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"



namespace priv {

template <class _Integer>
char* __cdecl
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x);





extern size_t __cdecl __write_float(__iostring&, ios_base::fmtflags, int, double);


#line 149 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"




void __cdecl __get_floor_digits(__iostring&, double);

template <class _CharT>
void __cdecl __get_money_digits(::std::priv:: __basic_iostring<_CharT>&, ios_base&, double);


extern void __cdecl __convert_float_buffer(__iostring const&, __iowstring&, const ctype<wchar_t>&, wchar_t, bool = true);
#line 161 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"
extern void __cdecl __adjust_float_buffer(__iostring&, char);

extern char* __cdecl
__write_integer(char* buf, ios_base::fmtflags flags, long x);

extern ptrdiff_t __cdecl __insert_grouping(char* first, char* last, const string&, char, char, char, int);
extern void __cdecl __insert_grouping(__iostring&, size_t, const string&, char, char, char, int);

extern ptrdiff_t __cdecl __insert_grouping(wchar_t*, wchar_t*, const string&, wchar_t, wchar_t, wchar_t, int);
extern void __cdecl __insert_grouping(__iowstring&, size_t, const string&, wchar_t, wchar_t, wchar_t, int);
#line 172 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"

}

#line 176 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"

























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"































#line 1 "C:\\Pin35\\extras\\stlport\\include\\cfloat"































#line 33 "C:\\Pin35\\extras\\stlport\\include\\cfloat"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\float.h"


















#line 20 "C:\\Pin35\\extras\\stlport\\include\\float.h"

#line 22 "C:\\Pin35\\extras\\stlport\\include\\float.h"

#line 24 "C:\\Pin35\\extras\\stlport\\include\\float.h"



#line 28 "C:\\Pin35\\extras\\stlport\\include\\float.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/float.h"










































#line 33 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\float.h"









#line 44 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 45 "C:\\Pin35\\extras\\stlport\\include\\float.h"







#line 53 "C:\\Pin35\\extras\\stlport\\include\\float.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\cfloat"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\cfloat"




#line 40 "C:\\Pin35\\extras\\stlport\\include\\cfloat"

#line 42 "C:\\Pin35\\extras\\stlport\\include\\cfloat"




#line 33 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"



#line 38 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"






namespace std {

enum float_round_style {
  round_indeterminate       = -1,
  round_toward_zero         =  0,
  round_to_nearest          =  1,
  round_toward_infinity     =  2,
  round_toward_neg_infinity =  3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent        =  0,
  denorm_present       =  1
};

namespace priv {


template <class __number>
class _Numeric_limits_base {
public:

  static __number (__cdecl min)()  { return __number(); }
  static __number (__cdecl max)()  { return __number(); }

  static const int digits = 0;
  static const int digits10 = 0;
  static const int radix = 0;
  static const int min_exponent = 0;
  static const int min_exponent10 = 0;
  static const int max_exponent = 0;
  static const int max_exponent10 = 0;

  static const float_denorm_style has_denorm = denorm_absent;
  static const float_round_style round_style = round_toward_zero;

  static const bool is_specialized = false;
  static const bool is_signed = false;
  static const bool is_integer = false;
  static const bool is_exact = false;
  static const bool has_infinity = false;
  static const bool has_quiet_NaN = false;
  static const bool has_signaling_NaN = false;
  static const bool has_denorm_loss = false;
  static const bool is_iec559 = false;
  static const bool is_bounded = false;
  static const bool is_modulo = false;
  static const bool traps = false;
  static const bool tinyness_before = false;

  static __number __cdecl epsilon()      { return __number(); }
  static __number __cdecl round_error()  { return __number(); }

  static __number __cdecl infinity()       { return __number(); }
  static __number __cdecl quiet_NaN()      { return __number(); }
  static __number __cdecl signaling_NaN()  { return __number(); }
  static __number __cdecl denorm_min()     { return __number(); }
};














#line 118 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

template <class _Int,
          _Int __imin,
          _Int __imax,
          int __idigits, bool __ismod>
class _Integer_limits : public _Numeric_limits_base<_Int> {
public:

  static _Int (__cdecl min) ()  { return (_Int)__imin; }
  static _Int (__cdecl max) ()  { return (_Int)__imax; }

  static const int digits = (__idigits < 0) ? ((int)((sizeof(_Int) * (8))) - ((__imin == 0) ? 0 : 1)) : (__idigits);
  static const int digits10 = (digits * 301UL) / 1000;
  static const int radix = 2;
  static const bool is_specialized = true;
  static const bool is_signed = (__imin != 0);
  static const bool is_integer = true;
  static const bool is_exact = true;
  static const bool is_bounded = true;
  static const bool is_modulo = __ismod;
};


template <class __number,
         int __Digits, int __Digits10,
         int __MinExp, int __MaxExp,
         int __MinExp10, int __MaxExp10,
         bool __IsIEC559,
         float_denorm_style __DenormStyle,
         float_round_style __RoundStyle>
class _Floating_limits : public _Numeric_limits_base<__number> {
public:

  static const int digits = __Digits;
  static const int digits10 = __Digits10;
  static const int radix = 2;
  static const int min_exponent = __MinExp;
  static const int max_exponent = __MaxExp;
  static const int min_exponent10 = __MinExp10;
  static const int max_exponent10 = __MaxExp10;

  static const float_denorm_style has_denorm = __DenormStyle;
  static const float_round_style round_style = __RoundStyle;

  static const bool is_specialized = true;
  static const bool is_signed = true;

  static const bool has_infinity = true;

  static const bool has_quiet_NaN = true;
  static const bool has_signaling_NaN = true;



#line 175 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

  static const bool is_iec559 = __IsIEC559 && has_infinity && has_quiet_NaN && has_signaling_NaN && (has_denorm == denorm_present);
  static const bool has_denorm_loss = false;
  static const bool is_bounded = true;
  static const bool traps = true;
  static const bool tinyness_before = false;
};

}





template<class _Tp>
class numeric_limits : public ::std::priv:: _Numeric_limits_base<_Tp> {};




template<>
class numeric_limits<bool>
  : public ::std::priv:: _Integer_limits<bool, false, true, 1, false>
{};
#line 200 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

template<>
class numeric_limits<char>
  : public ::std::priv:: _Integer_limits<char, (-0x7f-1), 0x7f, -1, true>
{};


template<>
class numeric_limits<signed char>
  : public ::std::priv:: _Integer_limits<signed char, (-0x7f-1), 0x7f, -1, true>
{};
#line 212 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

template<>
class numeric_limits<unsigned char>
  : public ::std::priv:: _Integer_limits<unsigned char, 0, 0xffU, -1, true>
{};



template<>
class numeric_limits<wchar_t>
  : public ::std::priv:: _Integer_limits<wchar_t, L'\0', ((1<<16)-1), -1, true>
{};

#line 226 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

template<>
class numeric_limits<short>
  : public ::std::priv:: _Integer_limits<short, (-0x7fff-1), 0x7fff, -1, true>
{};

template<>
class numeric_limits<unsigned short>
  : public ::std::priv:: _Integer_limits<unsigned short, 0, 0xffffU, -1, true>
{};




#line 241 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

template<>
class numeric_limits<int>
  : public ::std::priv:: _Integer_limits<int, (-0x7fffffff-1), 0x7fffffff, -1, true>
{};

template<>
class numeric_limits<unsigned int>
  : public ::std::priv:: _Integer_limits<unsigned int, 0, 0xffffffffU, -1, true>
{};

template<>
class numeric_limits<long>
  : public ::std::priv:: _Integer_limits<long, (-0x7fffffffL-1), 0x7fffffffL, -1, true>
{};

template<>
class numeric_limits<unsigned long>
  : public ::std::priv:: _Integer_limits<unsigned long, 0, 0xffffffffUL, -1, true>
{};

















#line 279 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"



template<>
class numeric_limits<__int64>
  : public ::std::priv:: _Integer_limits<__int64, (-0x7fffffffffffffffi64-1i64), 0x7fffffffffffffffi64, -1, true>
{};

template<>
class numeric_limits<unsigned __int64>
  : public ::std::priv:: _Integer_limits<unsigned __int64, 0, 0xffffffffffffffffUi64, -1, true>
{};















































#line 339 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

#line 341 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

namespace priv {


template <class __dummy>
class _LimG {
public:
  static float __cdecl get_F_inf();
  static float __cdecl get_F_qNaN();
  static float __cdecl get_F_sNaN();
  static float __cdecl get_F_denormMin();
  static double __cdecl get_D_inf();
  static double __cdecl get_D_qNaN();
  static double __cdecl get_D_sNaN();
  static double __cdecl get_D_denormMin();






#line 363 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"
};



#line 368 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

















#line 386 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"






#line 393 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"



#line 397 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"



#line 401 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

}

template<>
class numeric_limits<float>
  : public ::std::priv:: _Floating_limits<float,
                                       24,   
                                       6,        
                                       (-125),    
                                       128,    
                                       (-37), 
                                       38, 
                                       true,
                                       denorm_present,
                                       round_to_nearest> {
public:
  static float (__cdecl min) ()  { return 1.17549435E-38F; }
  static float __cdecl denorm_min() 


#line 422 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"
  { return denorm_present ? ::std::priv:: _LimG<bool>::get_F_denormMin() : 1.17549435E-38F; }
#line 424 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"
  static float (__cdecl max) ()  { return 3.402823466E+38F; }
  static float __cdecl epsilon()  { return 1.192092896e-07F; }
  static float __cdecl round_error()  { return 0.5f; } 
  static  float __cdecl infinity()  { return ::std::priv:: _LimG<bool>::get_F_inf(); }
  static  float __cdecl quiet_NaN()  { return ::std::priv:: _LimG<bool>::get_F_qNaN(); }
  static  float __cdecl signaling_NaN()  { return ::std::priv:: _LimG<bool>::get_F_sNaN(); }
};




template<>
class numeric_limits<double>
  : public ::std::priv:: _Floating_limits<double,
                                       53,   
                                       15,        
                                       (-1021),    
                                       1024,    
                                       (-307), 
                                       308, 
                                       true,
                                       denorm_present,
                                       round_to_nearest> {
public:
  static double (__cdecl min)()  { return 2.2250738585072014E-308; }
  static double __cdecl denorm_min() 


#line 453 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"
  { return denorm_present ? ::std::priv:: _LimG<bool>::get_D_denormMin() : 2.2250738585072014E-308; }
#line 455 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"
  static double (__cdecl max)()  { return 1.7976931348623157E+308; }
  static double __cdecl epsilon()  { return 2.2204460492503131e-016; }
  static double __cdecl round_error()  { return 0.5; } 
  static  double __cdecl infinity()  { return ::std::priv:: _LimG<bool>::get_D_inf(); }
  static  double __cdecl quiet_NaN()  { return ::std::priv:: _LimG<bool>::get_D_qNaN(); }
  static  double __cdecl signaling_NaN()  { return ::std::priv:: _LimG<bool>::get_D_sNaN(); }
};
















































#line 511 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"



}






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.c"





























namespace std {

namespace priv {







































































































#line 137 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.c"



































































































































































































































































#line 397 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.c"




}

}

#line 406 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.c"
#line 522 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"
#line 523 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"

#line 525 "C:\\Pin35\\extras\\stlport\\include\\stl/_limits.h"




#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"

namespace std {

namespace priv {








template <class _CharT, class _OutputIter>
_OutputIter  __cdecl
__copy_float_and_fill(const _CharT* __first, const _CharT* __last,
                      _OutputIter __oi,
                      ios_base::fmtflags __flags,
                      streamsize __width, _CharT __fill,
                      _CharT __xplus, _CharT __xminus) {
  if (__width <= __last - __first)
    return ::std::copy(__first, __last, __oi);
  else {
    streamsize __pad = __width - (__last - __first);
    ios_base::fmtflags __dir = __flags & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __oi = ::std::copy(__first, __last, __oi);
      return ::std::priv:: __fill_n(__oi, __pad, __fill);
    }
    else if (__dir == ios_base::internal && __first != __last &&
             (*__first == __xplus || *__first == __xminus)) {
      *__oi++ = *__first++;
      __oi = ::std::priv:: __fill_n(__oi, __pad, __fill);
      return ::std::copy(__first, __last, __oi);
    }
    else {
      __oi = ::std::priv:: __fill_n(__oi, __pad, __fill);
      return ::std::copy(__first, __last, __oi);
    }
  }
}



template <class _OutputIter>
_OutputIter  __cdecl
__put_float(__iostring &__str, _OutputIter __oi,
            ios_base& __f, wchar_t __fill,
            wchar_t __decimal_point, wchar_t __sep,
            size_t __group_pos, const string& __grouping) {
  const ctype<wchar_t>& __ct = use_facet<ctype<wchar_t> >(__f.getloc());

  __iowstring __wbuf;
  __convert_float_buffer(__str, __wbuf, __ct, __decimal_point);

  if (!__grouping.empty()) {
    __insert_grouping(__wbuf, __group_pos, __grouping,
                      __sep, __ct.widen('+'), __ct.widen('-'), 0);
  }

  return __copy_float_and_fill(__wbuf.data(), __wbuf.data() + __wbuf.size(), __oi,
                               __f.flags(), __f.width(0), __fill, __ct.widen('+'), __ct.widen('-'));
}
#line 92 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"


template <class _OutputIter>
_OutputIter  __cdecl
__put_float(__iostring &__str, _OutputIter __oi,
            ios_base& __f, char __fill,
            char __decimal_point, char __sep,
            size_t __group_pos, const string& __grouping) {
  if ((__group_pos < __str.size()) && (__str[__group_pos] == '.')) {
    __str[__group_pos] = __decimal_point;
  }

  if (!__grouping.empty()) {
    __insert_grouping(__str, __group_pos,
                      __grouping, __sep, '+', '-', 0);
  }

  return __copy_float_and_fill(__str.data(), __str.data() + __str.size(), __oi,
                               __f.flags(), __f.width(0), __fill, '+', '-');
}

template <class _CharT, class _OutputIter, class _Float>
_OutputIter __cdecl
__do_put_float(_OutputIter __s, ios_base& __f,
                _CharT __fill, _Float __x) {
  __iostring __buf;

  size_t __group_pos = __write_float(__buf, __f.flags(), (int)__f.precision(), __x);

  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__f.getloc());
  return __put_float(__buf, __s, __f, __fill,
                     __np.decimal_point(), __np.thousands_sep(),
                     __group_pos, __np.grouping());
}

inline void __get_money_digits_aux (__iostring &__buf, ios_base &, double __x)
{ __get_floor_digits(__buf, __x); }


inline void __get_money_digits_aux (__iowstring &__wbuf, ios_base &__f, double __x) {
  __iostring __buf;
  __get_floor_digits(__buf, __x);

  const ctype<wchar_t>& __ct = use_facet<ctype<wchar_t> >(__f.getloc());
  __convert_float_buffer(__buf, __wbuf, __ct, wchar_t(0), false);
}
#line 139 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"

template <class _CharT>
void __cdecl __get_money_digits(::std::priv:: __basic_iostring<_CharT> &__buf, ios_base& __f, double __x)
{ __get_money_digits_aux(__buf, __f, __x); }



template <class _CharT, class _OutputIter>
_OutputIter __cdecl
__copy_integer_and_fill(const _CharT* __buf, ptrdiff_t __len,
                        _OutputIter __oi,
                        ios_base::fmtflags __flg, streamsize __wid, _CharT __fill,
                        _CharT __xplus, _CharT __xminus) {
  if (__len >= __wid)
    return ::std::copy(__buf, __buf + __len, __oi);
  else {
    
    
    typedef char __static_assert[(sizeof(streamsize) > sizeof(ptrdiff_t)) || ((sizeof(streamsize) == sizeof(ptrdiff_t)) && numeric_limits<ptrdiff_t>::is_signed) ? 1 : -1] ;
#line 159 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
    ptrdiff_t __pad = static_cast<ptrdiff_t>((min) (static_cast<streamsize>((numeric_limits<ptrdiff_t>::max)()), static_cast<streamsize>(__wid - __len)));
#line 161 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
    ios_base::fmtflags __dir = __flg & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __oi = ::std::copy(__buf, __buf + __len, __oi);
      return ::std::priv:: __fill_n(__oi, __pad, __fill);
    }
    else if (__dir == ios_base::internal && __len != 0 &&
             (__buf[0] == __xplus || __buf[0] == __xminus)) {
      *__oi++ = __buf[0];
      __oi = __fill_n(__oi, __pad, __fill);
      return ::std::copy(__buf + 1, __buf + __len, __oi);
    }
    else if (__dir == ios_base::internal && __len >= 2 &&
             (__flg & ios_base::showbase) &&
             (__flg & ios_base::basefield) == ios_base::hex) {
      *__oi++ = __buf[0];
      *__oi++ = __buf[1];
      __oi = __fill_n(__oi, __pad, __fill);
      return ::std::copy(__buf + 2, __buf + __len, __oi);
    }
    else {
      __oi = __fill_n(__oi, __pad, __fill);
      return ::std::copy(__buf, __buf + __len, __oi);
    }
  }
}



template <class _OutputIter>
_OutputIter __cdecl
__put_integer(char* __buf, char* __iend, _OutputIter __s,
              ios_base& __f,
              ios_base::fmtflags __flags, wchar_t __fill) {
  locale __loc = __f.getloc();
  const ctype<wchar_t>& __ct = use_facet<ctype<wchar_t> >(__loc);

  wchar_t __xplus  = __ct.widen('+');
  wchar_t __xminus = __ct.widen('-');

  wchar_t __wbuf[64];
  __ct.widen(__buf, __iend, __wbuf);
  ptrdiff_t __len = __iend - __buf;
  wchar_t* __eend = __wbuf + __len;

  const numpunct<wchar_t>& __np = use_facet<numpunct<wchar_t> >(__loc);
  const string& __grouping = __np.grouping();

  if (!__grouping.empty()) {
    int __basechars;
    if (__flags & ios_base::showbase)
      switch (__flags & ios_base::basefield) {
        case ios_base::hex: __basechars = 2; break;
        case ios_base::oct: __basechars = 1; break;
        default: __basechars = 0;
      }
    else
      __basechars = 0;

    __len = __insert_grouping(__wbuf, __eend, __grouping, __np.thousands_sep(),
                              __xplus, __xminus, __basechars);
  }

  return __copy_integer_and_fill((wchar_t*)__wbuf, __len, __s,
                                 __flags, __f.width(0), __fill, __xplus, __xminus);
}
#line 228 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"


template <class _OutputIter>
_OutputIter __cdecl
__put_integer(char* __buf, char* __iend, _OutputIter __s,
              ios_base& __f, ios_base::fmtflags __flags, char __fill) {
  char __grpbuf[64];
  ptrdiff_t __len = __iend - __buf;

  const numpunct<char>& __np = use_facet<numpunct<char> >(__f.getloc());
  const string& __grouping = __np.grouping();

  if (!__grouping.empty()) {
    int __basechars;
    if (__flags & ios_base::showbase)
      switch (__flags & ios_base::basefield) {
        case ios_base::hex: __basechars = 2; break;
        case ios_base::oct: __basechars = 1; break;
        default: __basechars = 0;
      }
    else
      __basechars = 0;

     
     
    ::std::copy(__buf, __iend, (char *) __grpbuf);
    __buf = __grpbuf;
    __iend = __grpbuf + __len;
    __len = __insert_grouping(__buf, __iend, __grouping, __np.thousands_sep(),
                              '+', '-', __basechars);
  }

  return __copy_integer_and_fill(__buf, __len, __s, __flags, __f.width(0), __fill, '+', '-');
}


typedef __int64 __max_int_t;
typedef unsigned __int64 __umax_int_t;



#line 270 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"

 const char* __cdecl __hex_char_table_lo();
 const char* __cdecl __hex_char_table_hi();

template <class _Integer>
inline char* __cdecl
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags __flags, const __true_type& ) {
  const bool __negative = __x < 0 ;
  __max_int_t __temp = __x;
  __umax_int_t __utemp = __negative?-__temp:__temp;

  for (; __utemp != 0; __utemp /= 10)
    *--__ptr = (char)((int)(__utemp % 10) + '0');
  
  if (__negative)
    *--__ptr = '-';
  else if (__flags & ios_base::showpos)
    *--__ptr = '+';
  return __ptr;
}

template <class _Integer>
inline char* __cdecl
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags __flags, const __false_type& ) {
  for (; __x != 0; __x /= 10)
    *--__ptr = (char)((int)(__x % 10) + '0');
  
  if (__flags & ios_base::showpos)
    *--__ptr = '+';
  return __ptr;
}

template <class _Integer>
char* __cdecl
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x) {
  char* __ptr = __buf;

  if (__x == 0) {
    *--__ptr = '0';
    if ((__flags & ios_base::showpos) && ((__flags & (ios_base::oct | ios_base::hex)) == 0))
      *--__ptr = '+';
    
  }
  else {
    switch (__flags & ios_base::basefield) {
      case ios_base::oct:
        {
          __umax_int_t __temp = __x;
          
          if ( sizeof(__x) < 8  && sizeof(__umax_int_t) >= 8 )
            __temp &= 0xFFFFFFFF;

          for (; __temp != 0; __temp >>=3)
            *--__ptr = (char)((((unsigned)__temp)& 0x7) + '0');

          
          if (__flags & ios_base::showbase)
            *--__ptr = '0';
        }
        break;
      case ios_base::hex:
        {
          const char* __table_ptr = (__flags & ios_base::uppercase) ?
            __hex_char_table_hi() : __hex_char_table_lo();
          __umax_int_t __temp = __x;
          
          if ( sizeof(__x) < 8  && sizeof(__umax_int_t) >= 8 )
            __temp &= 0xFFFFFFFF;

          for (; __temp != 0; __temp >>=4)
            *--__ptr = __table_ptr[((unsigned)__temp & 0xF)];

          if (__flags & ios_base::showbase) {
            *--__ptr = __table_ptr[16];
            *--__ptr = '0';
          }
        }
        break;
      
      default:
        {






#line 358 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
          typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;
          __ptr = __write_decimal_backward(__ptr, __x, __flags, _IsSigned());
#line 361 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
        }
        break;
    }
  }

  
  return __ptr;
}

template <class _CharT, class _OutputIter, class _Integer>
_OutputIter __cdecl
__do_put_integer(_OutputIter __s, ios_base& __f, _CharT __fill, _Integer __x) {
  
  
  
  
  char __buf[sizeof(_Integer) * 3 + 2];
  const ptrdiff_t __buf_size = sizeof(__buf) / sizeof(char);
  ios_base::fmtflags __flags = __f.flags();
  char* __ibeg = __write_integer_backward((char*)__buf + __buf_size, __flags, __x);
  return __put_integer(__ibeg, (char*)__buf + __buf_size, __s, __f, __flags, __fill);
}

template <class _CharT, class _OutputIter>
_OutputIter __cdecl
__do_put_bool(_OutputIter __s, ios_base& __f, _CharT __fill, bool __x) {
  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__f.getloc());

  basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > __str = __x ? __np.truename() : __np.falsename();

  streamsize __wid = __f.width(0);
  if (__str.size() >= static_cast<size_t>(__wid))
    return ::std::copy(__str.begin(), __str.end(), __s);
  else {
    streamsize __pad = __wid - __str.size();
    ios_base::fmtflags __dir = __f.flags() & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __s = ::std::copy(__str.begin(), __str.end(), __s);
      return __fill_n(__s, __pad, __fill);
    }
    else  {
      __s = __fill_n(__s, __pad, __fill);
      return ::std::copy(__str.begin(), __str.end(), __s);
    }
  }
}
}





template <class _CharT, class _OutputIterator>
locale::id num_put<_CharT, _OutputIterator>::id;


template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     bool __val) const {
  if (!(__f.flags() & ios_base::boolalpha))
    
    return do_put(__s, __f, __fill, static_cast<long>(__val));

  return ::std::priv:: __do_put_bool(__s, __f, __fill, __val);
}
#line 429 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     long __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     unsigned long __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     double __val) const
{ return ::std::priv:: __do_put_float(__s, __f, __fill, __val); }







#line 455 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"


template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     __int64 __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     unsigned __int64 __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }
#line 469 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"




template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT ,
                                     const void* __val) const {
  const ctype<_CharT>& __c_type = use_facet<ctype<_CharT> >(__f.getloc());
  ios_base::fmtflags __save_flags = __f.flags();

  __f.setf(ios_base::hex, ios_base::basefield);
  __f.setf(ios_base::showbase);
  __f.setf(ios_base::internal, ios_base::adjustfield);
  __f.width((sizeof(void*) * 2) + 2); 
  if ( __val == 0 ) {
    
    
    const char* __table_ptr = (__save_flags & ios_base::uppercase) ?
            ::std::priv:: __hex_char_table_hi() : ::std::priv:: __hex_char_table_lo();
    __s++ = __c_type.widen( '0' );
    __s++ = __c_type.widen( __table_ptr[16] );
    __f.width((sizeof(void*) * 2)); 
  } else {
    __f.width((sizeof(void*) * 2) + 2); 
  }

#pragma warning (push)
#pragma warning (disable : 4311) 
#pragma warning (disable : 4302) 
#line 500 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
  _OutputIter result =

    ( sizeof(void*) == sizeof(unsigned long) ) ?
#line 504 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
    ::std::priv:: __do_put_integer(__s, __f, __c_type.widen('0'), reinterpret_cast<unsigned long>(__val))

      : 
    ::std::priv:: __do_put_integer(__s, __f, __c_type.widen('0'), reinterpret_cast<unsigned __int64>(__val))
#line 509 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
        ;

#pragma warning (pop)
#line 513 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"
  __f.flags(__save_flags);
  return result;
}

}

#line 520 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.c"




#line 181 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"
#line 182 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"

#line 184 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_put.h"




#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"

namespace std {






template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<_CharT, _Traits>* __buf)
    : basic_ios<_CharT, _Traits>() {
  this->init(__buf);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<_CharT, _Traits>* __from) {
  sentry __sentry(*this);
  if (__sentry) {
    if (__from) {
      bool __any_inserted = __from->gptr() != __from->egptr()
        ? this->_M_copy_buffered(__from, this->rdbuf())
        : this->_M_copy_unbuffered(__from, this->rdbuf());
      if (!__any_inserted)
        this->setstate(ios_base::failbit);
    }
    else
      this->setstate(ios_base::badbit);
  }

  return *this;
}






template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
  ::_M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
                     basic_streambuf<_CharT, _Traits>* __to) {
  bool __any_inserted = false;

  while (__from->egptr() != __from->gptr()) {
    const ptrdiff_t __avail = __from->egptr() - __from->gptr();

    streamsize __nwritten;
     {
      __nwritten = __to->sputn(__from->gptr(), __avail);
      __from->gbump((int)__nwritten);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return __any_inserted;
    }

    if (__nwritten == __avail) {
       {
        if (this->_S_eof(__from->sgetc()))
          return true;
        else
          __any_inserted = true;
      }
      if (false) {
        this->_M_handle_exception(ios_base::failbit);
        return false;
      }
    }
    else if (__nwritten != 0)
      return true;
    else
      return __any_inserted;
  }

  
  
  return __any_inserted || this->_M_copy_unbuffered(__from, __to);
}





template <class _CharT, class _Traits>
struct _SPutBackC {
  typedef basic_streambuf<_CharT, _Traits> _StreamBuf;
  typedef typename _StreamBuf::int_type int_type;
  _SPutBackC(_StreamBuf *pfrom)
    : __pfrom(pfrom), __c(0), __do_guard(false) {}
  ~_SPutBackC() {
    if (__do_guard) {
      __pfrom->sputbackc(_Traits::to_char_type(__c));
    }
  }

  void guard(int_type c) {
    __c = c;
    __do_guard = true;
  }
  void release() {
    __do_guard = false;
  }

private:
  _StreamBuf *__pfrom;
  int_type __c;
  bool __do_guard;
};

template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
  ::_M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
                       basic_streambuf<_CharT, _Traits>* __to) {
  typedef _SPutBackC<_CharT, _Traits> _SPutBackCGuard;
  bool __any_inserted = false;
  int_type __c;

   {
    _SPutBackCGuard __cguard(__from);
    for (;;) {
       {
        __c = __from->sbumpc();
      }
      if (false) {
        this->_M_handle_exception(ios_base::failbit);
        break;
      }

      if (this->_S_eof(__c))
        break;

      __cguard.guard(__c);


#line 169 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"
      if (this->_S_eof(__to->sputc(_Traits::to_char_type(__c))))
        break;







#line 179 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"
      __cguard.release();
      __any_inserted = true;
    }
  }
  if (false) {
    this->_M_handle_exception(ios_base::badbit);
  }
  return __any_inserted;
}

namespace priv {


template <class _CharT, class _Traits, class _Number>
basic_ostream<_CharT, _Traits>&  __cdecl
__put_num(basic_ostream<_CharT, _Traits>& __os, _Number __x) {
  typedef typename basic_ostream<_CharT, _Traits>::sentry _Sentry;
  _Sentry __sentry(__os);
  bool __failed = true;

  if (__sentry) {
     {
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > _NumPut;
      __failed = (use_facet<_NumPut>(__os.getloc())).put(ostreambuf_iterator<_CharT, _Traits>(__os.rdbuf()),
                                                         __os, __os.fill(),
                                                         __x).failed();
    }
    if (false) {
      __os._M_handle_exception(ios_base::badbit);
    }
  }
  if (__failed)
    __os.setstate(ios_base::badbit);
  return __os;
}

}





template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(short __x) {
  typedef char __static_assert[sizeof(short) <= sizeof(long) ? 1 : -1] ;
  long __tmp = ((this->flags() & _Basic_ios::basefield) != ios_base::dec) ?
                  static_cast<long>(static_cast<unsigned short>(__x)): __x;
  return ::std::priv:: __put_num(*this, __tmp);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned short __x) {
  typedef char __static_assert[sizeof(unsigned short) <= sizeof(unsigned long) ? 1 : -1] ;
  return ::std::priv:: __put_num(*this, static_cast<unsigned long>(__x));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(int __x) {
  typedef char __static_assert[sizeof(int) <= sizeof(long) ? 1 : -1] ;
  long __tmp = ((this->flags() & _Basic_ios::basefield) != ios_base::dec) ?
                  static_cast<long>(static_cast<unsigned int>(__x)): __x;
  return ::std::priv:: __put_num(*this, __tmp);
}

template <class _CharT, class _Traits>



#line 248 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"



basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(size_t __x) {
  typedef char __static_assert[sizeof(size_t) <= sizeof(unsigned long) ? 1 : -1] ;
#line 254 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"
  return ::std::priv:: __put_num(*this,  static_cast<unsigned long>(__x));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long __x)
{ return ::std::priv:: __put_num(*this,  __x); }

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned long __x)
{ return ::std::priv:: __put_num(*this,  __x); }


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<< (__int64 __x)
{ return ::std::priv:: __put_num(*this,  __x); }

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<< (unsigned __int64 __x)
{ return ::std::priv:: __put_num(*this,  __x); }
#line 274 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(float __x)
{ return ::std::priv:: __put_num(*this,  static_cast<double>(__x)); }

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(double __x)
{ return ::std::priv:: __put_num(*this,  __x); }







template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(const void* __x)
{ return ::std::priv:: __put_num(*this,  __x); }


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(bool __x)
{ return ::std::priv:: __put_num(*this,  __x); }
#line 298 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"

template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_char(_CharT __c) {
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
     {
      streamsize __npad = this->width() > 0 ? this->width() - 1 : 0;
      
      if (__npad == 0)
        __failed = this->_S_eof(this->rdbuf()->sputc(__c));
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = this->_S_eof(this->rdbuf()->sputc(__c));
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || this->_S_eof(this->rdbuf()->sputc(__c));
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::badbit);
  }
}

template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_nowiden(const _CharT* __s) {
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    streamsize __n = _Traits::length(__s);
    streamsize __npad = this->width() > __n ? this->width() - __n : 0;

     {
      if (__npad == 0)
        __failed = this->rdbuf()->sputn(__s, __n) != __n;
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = this->rdbuf()->sputn(__s, __n) != __n;
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || this->rdbuf()->sputn(__s, __n) != __n;
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::failbit);
  }
}

template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_widen(const char* __s) {
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    streamsize __n = char_traits<char>::length(__s);
    streamsize __npad = this->width() > __n ? this->width() - __n : 0;

     {
      if (__npad == 0)
        __failed = !this->_M_put_widen_aux(__s, __n);
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = !this->_M_put_widen_aux(__s, __n);
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || !this->_M_put_widen_aux(__s, __n);
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::failbit);
  }
}

template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>::_M_put_widen_aux(const char* __s,
                                                      streamsize __n) {
  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

  for ( ; __n > 0 ; --__n)
    if (this->_S_eof(__buf->sputc(this->widen(*__s++))))
      return false;
  return true;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c) {
  sentry __sentry(*this);
  bool __failed = true;

  if (__sentry) {
     {
      __failed = this->_S_eof(this->rdbuf()->sputc(__c));
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
  }

  if (__failed)
    this->setstate(ios_base::badbit);

  return *this;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n) {
  sentry __sentry(*this);
  bool __failed = true;

  if (__sentry) {
     {
      __failed = this->rdbuf()->sputn(__s, __n) != __n;
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
  }

  if (__failed)
    this->setstate(ios_base::badbit);

  return *this;
}

}

#line 452 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.c"




#line 385 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"
#line 386 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"

#line 388 "C:\\Pin35\\extras\\stlport\\include\\stl/_ostream.h"




#line 24 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"























#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"










#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_istreambuf_iterator.h"

































namespace std {


template <class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* __cdecl _M_get_istreambuf(basic_istream<_CharT, _Traits>& ) ;





template<class _CharT, class _Traits>
class istreambuf_iterator :
  public iterator<input_iterator_tag, _CharT, typename _Traits::off_type, _CharT*, _CharT&>
{
public:
  typedef _CharT                           char_type;
  typedef _Traits                          traits_type;
  typedef typename _Traits::int_type       int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_istream<_CharT, _Traits>   istream_type;

  typedef input_iterator_tag               iterator_category;
  typedef _CharT                           value_type;
  typedef typename _Traits::off_type       difference_type;
  typedef const _CharT*                    pointer;
  typedef const _CharT&                    reference;

public:
  istreambuf_iterator(streambuf_type* __p = 0) { this->_M_init(__p); }
  
  inline istreambuf_iterator(basic_istream<_CharT, _Traits>& __is);

  char_type operator*() const { this->_M_getc(); return _M_c; }
  istreambuf_iterator<_CharT, _Traits>& operator++() {
    _M_buf->sbumpc();
    _M_have_c = false;
    return *this;
  }
  istreambuf_iterator<_CharT, _Traits>  operator++(int);

  bool equal(const istreambuf_iterator<_CharT, _Traits>& __i) const {
    if (this->_M_buf)
      this->_M_getc();
    if (__i._M_buf)
      __i._M_getc();
    return this->_M_eof == __i._M_eof;
  }

private:
  void _M_init(streambuf_type* __p) {
    _M_buf = __p;
    _M_eof = (__p == 0);
    _M_have_c = false;
  }

  void _M_getc() const {
    if (_M_have_c)
      return;
    int_type __c = _M_buf->sgetc();
    _M_c = traits_type::to_char_type(__c);
    _M_eof = traits_type::eq_int_type(__c, traits_type::eof());
    _M_have_c = true;
  }

private:
  streambuf_type* _M_buf;
  mutable _CharT _M_c;
  mutable bool _M_eof;
  mutable bool _M_have_c;
};

template<class _CharT, class _Traits>
inline istreambuf_iterator<_CharT, _Traits>::istreambuf_iterator(basic_istream<_CharT, _Traits>& __is)
{ this->_M_init(_M_get_istreambuf(__is)); }

template<class _CharT, class _Traits>
inline bool __cdecl operator==(const istreambuf_iterator<_CharT, _Traits>& __x,
                                  const istreambuf_iterator<_CharT, _Traits>& __y) {
  return __x.equal(__y);
}



template<class _CharT, class _Traits>
inline bool __cdecl operator!=(const istreambuf_iterator<_CharT, _Traits>& __x,
                                  const istreambuf_iterator<_CharT, _Traits>& __y) {
  return !__x.equal(__y);
}

#line 124 "C:\\Pin35\\extras\\stlport\\include\\stl/_istreambuf_iterator.h"






#line 131 "C:\\Pin35\\extras\\stlport\\include\\stl/_istreambuf_iterator.h"











template <class _CharT, class _Traits>
istreambuf_iterator<_CharT, _Traits>
istreambuf_iterator<_CharT, _Traits>::operator++(int) {
  _M_getc(); 
  
  
  istreambuf_iterator<_CharT, _Traits> __tmp = *this;
  _M_buf->sbumpc();
  _M_have_c = false;
  return __tmp;
}

}

#line 157 "C:\\Pin35\\extras\\stlport\\include\\stl/_istreambuf_iterator.h"





#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ctraits_fns.h"



























































































#line 39 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"
                                
namespace std {




#line 46 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"

struct _No_Skip_WS {};        

template <class _CharT, class _Traits>
bool _M_init_skip(basic_istream<_CharT, _Traits>& __istr);
template <class _CharT, class _Traits>
bool _M_init_noskip(basic_istream<_CharT, _Traits>& __istr);









template <class _CharT, class _Traits>
class basic_istream : virtual public basic_ios<_CharT, _Traits> {
  typedef basic_istream<_CharT, _Traits> _Self;





#line 71 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"

public:
                         
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;
  typedef basic_ios<_CharT, _Traits>     _Basic_ios;

  typedef basic_ios<_CharT, _Traits>& (__cdecl *__ios_fn)(basic_ios<_CharT, _Traits>&);
  typedef ios_base& (__cdecl *__ios_base_fn)(ios_base&);
  typedef _Self& (__cdecl *__istream_fn)(_Self&);

public:                         
  explicit basic_istream(basic_streambuf<_CharT, _Traits>* __buf) :
    basic_ios<_CharT, _Traits>(), _M_gcount(0) {
    this->init(__buf);
  }
  ~basic_istream() {};

public:                         

public:                         
                                
  _Self& operator>> (__istream_fn __f) { return __f(*this); }
  _Self& operator>> (__ios_fn __f) {  __f(*this); return *this; }
  _Self& operator>> (__ios_base_fn __f) { __f(*this); return *this; }

public:                         
  _Self& operator>> (short& __val);
  _Self& operator>> (int& __val);
  _Self& operator>> (unsigned short& __val);
  _Self& operator>> (unsigned int& __val);
  _Self& operator>> (long& __val);
  _Self& operator>> (unsigned long& __val);

  _Self& operator>> (__int64& __val);
  _Self& operator>> (unsigned __int64& __val);
#line 111 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"
  _Self& operator>> (float& __val);
  _Self& operator>> (double& __val);




  _Self& operator>> (bool& __val);
#line 119 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"
  _Self& operator>> (void*& __val);

public:                         
  _Self& operator>>(basic_streambuf<_CharT, _Traits>*);

public:                         
  streamsize gcount() const { return _M_gcount; }
  int_type peek();

public:                         
  int_type get();
  _Self& get(char_type& __c);

public:                         
  _Self& get(char_type* __s, streamsize __n, char_type __delim);
  _Self& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

public:                         
  _Self& get(basic_streambuf<_CharT, _Traits>& __buf,
                     char_type __delim);
  _Self& get(basic_streambuf<_CharT, _Traits>& __buf)
    { return get(__buf, this->widen('\n')); }

public:                         
  _Self& getline(char_type* __s, streamsize __n, char_type delim);
  _Self& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

public:                         
  _Self& ignore();
  _Self& ignore(streamsize __n);
  _Self& ignore(streamsize __n, int_type __delim);

  _Self& read(char_type* __s, streamsize __n);
  streamsize readsome(char_type* __s, streamsize __n);

public:                         
  _Self& putback(char_type __c);
  _Self& unget();

public:                         
  int sync();

  pos_type tellg();
  _Self& seekg(pos_type __pos);
  _Self& seekg(off_type, ios_base::seekdir);

public:                         
  void _M_formatted_get(_CharT& __c);
  void _M_formatted_get(_CharT* __s);
  void _M_skip_whitespace(bool __set_failbit);

private:                        
  streamsize _M_gcount;         

public:










#line 187 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"
  class sentry {
    typedef sentry _Self;
#line 190 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"

  private:
    const bool _M_ok;
    

  public:
    typedef _Traits traits_type;

    explicit sentry(basic_istream<_CharT, _Traits>& __istr,
                    bool __noskipws = false) :
      _M_ok((__noskipws || !(__istr.flags() & ios_base::skipws)) ? _M_init_noskip(__istr) : _M_init_skip(__istr) )
      
      {}

    
    
    sentry(basic_istream<_CharT, _Traits>& __istr, _No_Skip_WS) : 
      _M_ok(_M_init_noskip(__istr)) {}

    ~sentry() {}

    operator bool() const { return _M_ok; }

  private:                        
    
    sentry(const _Self&) : _M_ok(false) {}
    _Self& operator=(const _Self&) { return *this; }
  };



#line 222 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"
  
};
#line 225 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"








#line 234 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"


template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>& __cdecl
operator>>(basic_istream<_CharT, _Traits>& __in_str, _CharT& __c) {
  __in_str._M_formatted_get(__c);
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>& __cdecl
operator>>(basic_istream<char, _Traits>& __in_str, unsigned char& __c) {
  __in_str._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>& __cdecl
operator>>(basic_istream<char, _Traits>& __in_str, signed char& __c) {
  __in_str._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in_str;
}

template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>& __cdecl
operator>>(basic_istream<_CharT, _Traits>& __in_str, _CharT* __s) {
  __in_str._M_formatted_get(__s);
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>& __cdecl
operator>>(basic_istream<char, _Traits>& __in_str, unsigned char* __s) {
  __in_str._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>& __cdecl
operator>>(basic_istream<char, _Traits>& __in_str, signed char* __s) {
  __in_str._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in_str;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& __cdecl
ws(basic_istream<_CharT, _Traits>& __istr) {
  if (!__istr.eof()) {
    typedef typename basic_istream<_CharT, _Traits>::sentry      _Sentry;
    _Sentry __sentry(__istr, _No_Skip_WS()); 
    if (__sentry)
      __istr._M_skip_whitespace(false);
  }
  return __istr;
}


template <class _CharT, class _Traits>
inline bool _M_init_skip(basic_istream<_CharT, _Traits>& __istr) {
  if (__istr.good()) {
    if (__istr.tie())
      __istr.tie()->flush();

    __istr._M_skip_whitespace(true);
  }

  if (!__istr.good()) {
    __istr.setstate(ios_base::failbit);
    return false;
  } else
    return true;
}

template <class _CharT, class _Traits>
inline bool _M_init_noskip(basic_istream<_CharT, _Traits>& __istr) {
  if (__istr.good()) {
    if (__istr.tie())
      __istr.tie()->flush();

    if (!__istr.rdbuf())
      __istr.setstate(ios_base::badbit);
  }
  else
    __istr.setstate(ios_base::failbit);
  return __istr.good();
}



template <class _CharT, class _Traits>
class basic_iostream
  : public basic_istream<_CharT, _Traits>,
    public basic_ostream<_CharT, _Traits>
{
public:
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

  explicit basic_iostream(basic_streambuf<_CharT, _Traits>* __buf);
  virtual ~basic_iostream();
};







#line 344 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>* __cdecl _M_get_istreambuf(basic_istream<_CharT, _Traits>& __istr)
{ return __istr.rdbuf(); }

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"





























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

















































namespace std {




template <class _CharT, class _InputIter>
class num_get: public locale::facet {
public:
  typedef _CharT     char_type;
  typedef _InputIter iter_type;

  explicit num_get(size_t __refs = 0): locale::facet(__refs) {}


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, bool& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }
#line 68 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, short& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, int& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }
#line 78 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, long& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned short& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned int& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned long& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, __int64& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned __int64& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }
#line 104 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, float& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, double& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }





#line 118 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, void*& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  static locale::id id;

protected:
  ~num_get() {}

  typedef string               string_type;
  typedef ctype<_CharT>        _Ctype;
  typedef numpunct<_CharT>     _Numpunct;


  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, bool& __val) const;
#line 136 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, long& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned short& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned int& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned long& __val) const;


  
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, short& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, int& __val) const;
#line 153 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, float& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, double& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, void*& __p) const;




#line 165 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"


  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, __int64& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned __int64& __val) const;
#line 172 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

};









#line 184 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"



namespace priv {

 bool __cdecl __valid_grouping(const char*, const char*, const char*, const char*);

template <class _InputIter, class _Integer, class _CharT>
bool __cdecl
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val, _CharT*);


bool  __cdecl __get_fdigit(wchar_t&, const wchar_t*);
bool  __cdecl __get_fdigit_or_sep(wchar_t&, wchar_t, const wchar_t*);
#line 199 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

inline void  __cdecl
_Initialize_get_float(const ctype<char>&,
                       char& Plus, char& Minus,
                       char& pow_e, char& pow_E,
                       char*) {
  Plus = '+';
  Minus = '-';
  pow_e = 'e';
  pow_E = 'E';
}


void  __cdecl _Initialize_get_float(const ctype<wchar_t>&,
                                                     wchar_t&, wchar_t&, wchar_t&, wchar_t&, wchar_t*);
#line 215 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"
void  __cdecl __string_to_float(const __iostring&, float&);
void  __cdecl __string_to_float(const __iostring&, double&);


#line 220 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

}

#line 224 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"


}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"




























namespace std {

namespace priv {

 unsigned char __cdecl __digit_val_table(unsigned);
 const char* __cdecl __narrow_atoms();



inline bool __cdecl __get_fdigit(char __c, const char*)
{ return __c >= '0' && __c <= '9'; }

inline bool __cdecl __get_fdigit_or_sep(char& __c, char __sep, const char *__digits) {
  if (__c == __sep) {
    __c = ',' ;
    return true ;
  }
  else
    return  __get_fdigit(__c, __digits);
}

inline int __cdecl
__get_digit_from_table(unsigned __index)
{ return (__index > 127 ? 0xFF : __digit_val_table(__index)); }

template <class _InputIter, class _CharT>
int
__get_base_or_zero(_InputIter& __in_ite, _InputIter& __end,
                   ios_base::fmtflags __flags, const ctype<_CharT>& __c_type) {
  _CharT __atoms[5];
  __c_type.widen(__narrow_atoms(), __narrow_atoms() + 5, __atoms);

  bool __negative = false;
  _CharT __c = *__in_ite;

  if (__c == __atoms[1]  ) {
    __negative = true;
    ++__in_ite;
  }
  else if (__c == __atoms[0]  )
    ++__in_ite;

  int __base;
  int __valid_zero = 0;

  ios_base::fmtflags __basefield = __flags & ios_base::basefield;

  switch (__basefield) {
  case ios_base::oct:
    __base = 8;
    break;
  case ios_base::dec:
    __base = 10;
    break;
  case ios_base::hex:
    __base = 16;
    if (__in_ite != __end && *__in_ite == __atoms[2]  ) {
      ++__in_ite;
      if (__in_ite != __end &&
          (*__in_ite == __atoms[3]  || *__in_ite == __atoms[4]  ))
        ++__in_ite;
      else
        __valid_zero = 1; 
    }
    break;
  default:
    if (__in_ite != __end && *__in_ite == __atoms[2]  ) {
      ++__in_ite;
      if (__in_ite != __end &&
          (*__in_ite == __atoms[3]  || *__in_ite == __atoms[4]  )) {
        ++__in_ite;
        __base = 16;
      }
      else
        {
          __base = 8;
          __valid_zero = 1; 
        }
    }
    else
      __base = 10;
    break;
  }
  return (__base << 2) | ((int)__negative << 1) | __valid_zero;
}


template <class _InputIter, class _Integer, class _CharT>
bool __cdecl
__get_integer(_InputIter& __first, _InputIter& __last,
              int __base, _Integer& __val,
              int __got, bool __is_negative, _CharT __separator, const string& __grouping, const __true_type& ) {
  bool __ovflow = false;
  _Integer __result = 0;
  bool __is_group = !__grouping.empty();
  char __group_sizes[64];
  char __current_group_size = 0;
  char* __group_sizes_end = __group_sizes;

  _Integer __over_base = (numeric_limits<_Integer>::min)() / static_cast<_Integer>(__base);

   for ( ; __first != __last ; ++__first) {

     const _CharT __c = *__first;

     if (__is_group && __c == __separator) {
       *__group_sizes_end++ = __current_group_size;
       __current_group_size = 0;
       continue;
     }

     int __n = __get_digit_from_table(__c);

     if (__n >= __base)
       break;

     ++__got;
     ++__current_group_size;

     if (__result < __over_base)
       __ovflow = true;  
     else {
       _Integer __next = static_cast<_Integer>(__base * __result - __n);
       if (__result != 0)
         __ovflow = __ovflow || __next >= __result;
       __result = __next;
     }
   }

   if ((__result == (numeric_limits<_Integer>::min)()) && !__is_negative)
     __ovflow = true;

   if (__is_group && __group_sizes_end != __group_sizes) {
     *__group_sizes_end++ = __current_group_size;
   }

   
   if (__got > 0) {
       __val = __ovflow ? __is_negative ? (numeric_limits<_Integer>::min)()
                                        : (numeric_limits<_Integer>::max)()
                        : __is_negative ? __result
                                        : static_cast<_Integer>(-__result);
   }
  
  return ((__got > 0) && !__ovflow) &&
          (__is_group == 0 ||
           __valid_grouping(__group_sizes, __group_sizes_end,
                            __grouping.data(), __grouping.data()+ __grouping.size()));
}

template <class _InputIter, class _Integer, class _CharT>
bool __cdecl
__get_integer(_InputIter& __first, _InputIter& __last,
              int __base, _Integer& __val,
              int __got, bool __is_negative, _CharT __separator, const string& __grouping, const __false_type& ) {
  bool __ovflow = false;
  _Integer __result = 0;
  bool __is_group = !__grouping.empty();
  char __group_sizes[64];
  char __current_group_size = 0;
  char* __group_sizes_end = __group_sizes;

  _Integer  __over_base = (numeric_limits<_Integer>::max)() / static_cast<_Integer>(__base);

  for ( ; __first != __last ; ++__first) {

    const _CharT __c = *__first;

    if (__is_group && __c == __separator) {
      *__group_sizes_end++ = __current_group_size;
      __current_group_size = 0;
      continue;
    }

    int __n = __get_digit_from_table(__c);

    if (__n >= __base)
      break;

    ++__got;
    ++__current_group_size;

    if (__result > __over_base)
      __ovflow = true;  
    else {
      _Integer __next = static_cast<_Integer>(__base * __result + __n);
      if (__result != 0)
        __ovflow = __ovflow || __next <= __result;
        __result = __next;
      }
  }

  if (__is_group && __group_sizes_end != __group_sizes) {
      *__group_sizes_end++ = __current_group_size;
  }

  
  if (__got > 0) {
      __val = __ovflow ? (numeric_limits<_Integer>::max)()
                       : (__is_negative ? static_cast<_Integer>(-__result)
                                        : __result);
  }

  
  return ((__got > 0) && !__ovflow) &&
          (__is_group == 0 ||
           __valid_grouping(__group_sizes, __group_sizes_end,
                            __grouping.data(), __grouping.data()+ __grouping.size()));
}


template <class _InputIter, class _Integer, class _CharT>
bool __cdecl
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val, _CharT* ) {
  string __grp;
  
  return __get_integer(__first, __last, 10, __val, 0, false, _CharT() , __grp, __false_type());
}

template <class _InputIter, class _Integer, class _CharT>
_InputIter __cdecl
__do_get_integer(_InputIter& __in_ite, _InputIter& __end, ios_base& __str,
                 ios_base::iostate& __err, _Integer& __val, _CharT* ) {
  locale __loc = __str.getloc();
  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);



#line 258 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"
  typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;
#line 260 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"

  const int __base_or_zero = __get_base_or_zero(__in_ite, __end, __str.flags(), __ctype);
  int  __got = __base_or_zero & 1;

  bool __result;

  if (__in_ite == __end) {      

    if (__got > 0) {       
      __val = 0;
      __result = true;
    }
    else
      __result = false;
  }
  else {
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    const bool __negative = (__base_or_zero & 2) != 0;
    const int __base = __base_or_zero >> 2;






#line 286 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"
    __result = __get_integer(__in_ite, __end, __base,  __val, __got, __negative, __np.thousands_sep(), __np.grouping(), _IsSigned());
#line 288 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"
  }

  __err = static_cast<ios_base::iostate>(__result ? ios_base::goodbit : ios_base::failbit);

  if (__in_ite == __end)
    __err |= ios_base::eofbit;
  return __in_ite;
}


template <class _InputIter, class _CharT>
_InputIter  __cdecl
__copy_sign(_InputIter __first, _InputIter __last, __iostring& __v,
            _CharT __xplus, _CharT __xminus) {
  if (__first != __last) {
    _CharT __c = *__first;
    if (__c == __xplus)
      ++__first;
    else if (__c == __xminus) {
      __v.push_back('-');
      ++__first;
    }
  }
  return __first;
}


template <class _InputIter, class _CharT>
bool __cdecl
__copy_digits(_InputIter& __first, _InputIter __last,
              __iostring& __v, const _CharT* __digits) {
  bool __ok = false;

  for ( ; __first != __last; ++__first) {
    _CharT __c = *__first;
    if (__get_fdigit(__c, __digits)) {
      __v.push_back((char)__c);
      __ok = true;
    }
    else
      break;
  }
  return __ok;
}

template <class _InputIter, class _CharT>
bool __cdecl
__copy_grouped_digits(_InputIter& __first, _InputIter __last,
                      __iostring& __v, const _CharT * __digits,
                      _CharT __sep, const string& __grouping,
                      bool& __grouping_ok) {
  bool __ok = false;
  char __group_sizes[64];
  char*__group_sizes_end = __group_sizes;
  char __current_group_size = 0;

  for ( ; __first != __last; ++__first) {
    _CharT __c = *__first;
    bool __tmp = __get_fdigit_or_sep(__c, __sep, __digits);
    if (__tmp) {
      if (__c == ',') {
        *__group_sizes_end++ = __current_group_size;
        __current_group_size = 0;
      }
      else {
        __ok = true;
        __v.push_back((char)__c);
        ++__current_group_size;
      }
    }
    else
      break;
  }

  if (__group_sizes_end != __group_sizes)
    *__group_sizes_end++ = __current_group_size;
  __grouping_ok = __valid_grouping(__group_sizes, __group_sizes_end, __grouping.data(), __grouping.data() + __grouping.size());
  return __ok;
}


template <class _InputIter, class _CharT>
bool __cdecl
__read_float(__iostring& __buf, _InputIter& __in_ite, _InputIter& __end,
             const ctype<_CharT> &__ct, const numpunct<_CharT> &__numpunct) {
  
  

  string __grouping = __numpunct.grouping();
  bool __digits_before_dot ;
  bool __digits_after_dot = false;
  bool __ok;

  bool   __grouping_ok = true;

  _CharT __dot = __numpunct.decimal_point();
  _CharT __sep = __numpunct.thousands_sep();

  _CharT __digits[10];
  _CharT __xplus;
  _CharT __xminus;

  _CharT __pow_e;
  _CharT __pow_E;

  _Initialize_get_float(__ct, __xplus, __xminus, __pow_e, __pow_E, __digits);

  
  __in_ite = __copy_sign(__in_ite, __end, __buf, __xplus, __xminus);

  
  if (!__grouping.empty())
    __digits_before_dot = __copy_grouped_digits(__in_ite, __end, __buf, __digits,
                                                __sep, __grouping, __grouping_ok);
  else
    __digits_before_dot = __copy_digits(__in_ite, __end, __buf, __digits);

  
  if (__in_ite != __end && *__in_ite == __dot) {
    __buf.push_back('.');
    ++__in_ite;
    __digits_after_dot = __copy_digits(__in_ite, __end, __buf, __digits);
  }

  
  __ok = __digits_before_dot || __digits_after_dot;

  
  if (__ok && __in_ite != __end && (*__in_ite == __pow_e || *__in_ite == __pow_E)) {
    __buf.push_back('e');
    ++__in_ite;
    __in_ite = __copy_sign(__in_ite, __end, __buf, __xplus, __xminus);
    __ok = __copy_digits(__in_ite, __end, __buf, __digits);
    
    
  }

  return __ok;
}

template <class _InputIter, class _Float, class _CharT>
_InputIter __cdecl
__do_get_float(_InputIter& __in_ite, _InputIter& __end, ios_base& __str,
               ios_base::iostate& __err, _Float& __val, _CharT* ) {
  locale __loc = __str.getloc();
  const ctype<_CharT> &__ctype = use_facet<ctype<_CharT> >(__loc);
  const numpunct<_CharT> &__numpunct = use_facet<numpunct<_CharT> >(__loc);

  __iostring __buf ;
  bool __ok = __read_float(__buf, __in_ite, __end, __ctype, __numpunct);
  if (__ok) {
    __string_to_float(__buf, __val);
    __err = ios_base::goodbit;
  }
  else {
    __err = ios_base::failbit;
  }
  if (__in_ite == __end)
    __err |= ios_base::eofbit;
  return __in_ite;
}

template <class _InputIter, class _CharT>
_InputIter __cdecl
__do_get_alphabool(_InputIter& __in_ite, _InputIter& __end, ios_base& __str,
                   ios_base::iostate& __err, bool& __x, _CharT* ) {
  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__str.getloc());
  const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > __truename  = __np.truename();
  const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > __falsename = __np.falsename();
  bool __true_ok  = true;
  bool __false_ok = true;

  size_t __n = 0;
  for ( ; __in_ite != __end; ++__in_ite) {
    _CharT __c = *__in_ite;
    __true_ok  = __true_ok  && (__c == __truename[__n]);
    __false_ok = __false_ok && (__c == __falsename[__n]);
    ++__n;

    if ((!__true_ok && !__false_ok) ||
        (__true_ok  && __n >= __truename.size()) ||
        (__false_ok && __n >= __falsename.size())) {
      ++__in_ite;
      break;
    }
  }
  if (__true_ok  && __n < __truename.size())  __true_ok  = false;
  if (__false_ok && __n < __falsename.size()) __false_ok = false;

  if (__true_ok || __false_ok) {
    __err = ios_base::goodbit;
    __x = __true_ok;
  }
  else
    __err = ios_base::failbit;

  if (__in_ite == __end)
    __err |= ios_base::eofbit;

  return __in_ite;
}

}





template <class _CharT, class _InputIterator>
locale::id num_get<_CharT, _InputIterator>::id;


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end,
                                    ios_base& __s, ios_base::iostate& __err, bool& __x) const {
  if (__s.flags() & ios_base::boolalpha) {
    return ::std::priv:: __do_get_alphabool(__in_ite, __end, __s, __err, __x, (_CharT*)0);
  }
  else {
    long __lx;
    _InputIter __tmp = ::std::priv:: __do_get_integer(__in_ite, __end, __s, __err, __lx, (_CharT*)0 );
    if (!(__err & ios_base::failbit)) {
      if (__lx == 0)
        __x = false;
      else if (__lx == 1)
        __x = true;
      else
        __err |= ios_base::failbit;
    }
    return __tmp;
  }
}
#line 522 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err, short& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err, int& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

#line 537 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err, long& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned short& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned int& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned long& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    float& __val) const
{ return ::std::priv:: __do_get_float(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    double& __val) const
{ return ::std::priv:: __do_get_float(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }








#line 587 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    void*& __p) const {

  unsigned __int64 __val;


#line 598 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"
  iter_type __tmp = ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 );
  if (!(__err & ios_base::failbit))
    __p = reinterpret_cast<void*>(__val);
  return __tmp;
}


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    __int64& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned __int64& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }
#line 619 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"

}

#line 623 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.c"




#line 230 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"
#line 231 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"

#line 233 "C:\\Pin35\\extras\\stlport\\include\\stl/_num_get.h"





#line 31 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"
#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"






#line 39 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"



#line 43 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"

namespace std {




namespace priv {

template <class _Traits>
struct _Is_not_wspace {
  typedef typename _Traits::char_type argument_type;
  typedef bool                        result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_not_wspace(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
  bool operator()(argument_type __c) const
    { return !_M_ctype->is(ctype_base::space, __c); }
};

template <class _Traits>
struct _Is_wspace_null {
  typedef typename _Traits::char_type argument_type;
  typedef bool                        result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_wspace_null(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
  bool operator()(argument_type __c) const {
    return _Traits::eq(__c, argument_type()) ||
           _M_ctype->is(ctype_base::space, __c);
  }
};

template <class _Traits>
struct _Scan_for_wspace {
  typedef typename _Traits::char_type  char_type;
  typedef char_type*                   first_argument_type;
  typedef char_type*                   second_argument_type;
  typedef char_type*                   result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_wspace(const ctype<char_type>* __ctype) : _M_ctype(__ctype) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_wspace_null {
  typedef typename _Traits::char_type  char_type;
  typedef char_type*                   first_argument_type;
  typedef char_type*                   second_argument_type;
  typedef char_type*                   result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_wspace_null(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    __last = find_if(__first, __last,
                     _Eq_char_bound<_Traits>(char_type()));
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_for_not_wspace {
  typedef typename _Traits::char_type  char_type;
  typedef char_type*                   first_argument_type;
  typedef char_type*                   second_argument_type;
  typedef char_type*                   result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_not_wspace(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_not(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_for_char_val {
  typedef typename _Traits::char_type char_type;
  typedef char_type*                  first_argument_type;
  typedef char_type*                  second_argument_type;
  typedef char_type*                  result_type;

  char_type _M_val;

  _Scan_for_char_val(char_type __val) : _M_val(__val) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last, _Eq_char_bound<_Traits>(_M_val));
  }
};

template <class _Traits>
struct _Scan_for_int_val {
  typedef typename _Traits::char_type char_type;
  typedef typename _Traits::int_type  int_type;
  typedef char_type*                  first_argument_type;
  typedef char_type*                  second_argument_type;
  typedef char_type*                  result_type;

  int_type _M_val;

  _Scan_for_int_val(int_type __val) : _M_val(__val) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last,
                   _Eq_int_bound<_Traits>(_M_val));
  }
};




template <class _CharT, class _Traits>
bool __cdecl
__pushback(basic_streambuf<_CharT, _Traits>* __buf, _CharT __c) {
  bool ret;
   {
    const typename _Traits::int_type __eof = _Traits::eof();
    ret = !_Traits::eq_int_type(__buf->sputbackc(__c), __eof);
  }
  if (false) {
    ret = false;
  }
  return ret;
}





template <class _CharT, class _Traits, class _Number>
ios_base::iostate __cdecl
__get_num(basic_istream<_CharT, _Traits>& __that, _Number& __val) {
  typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
  ios_base::iostate __err = 0;
  _Sentry __sentry( __that );     
  if (__sentry) {
    typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > _Num_get;
     {
      
      
      (use_facet<_Num_get>(__that.getloc())).get(istreambuf_iterator<_CharT, _Traits>(__that.rdbuf()),
                                               0, __that, __err, __val);
    }
    if (false) {
      __that._M_handle_exception(ios_base::badbit);
    }
    if (__err) __that.setstate(__err);
  }
  return __err;
}

}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (short& __val) {

















#line 228 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"
  ::std::priv:: __get_num(*this, __val);
  return *this;
#line 231 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (int& __val) {

















#line 253 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"
  ::std::priv:: __get_num(*this, __val);
  return *this;
#line 256 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned short& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned int& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (long& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned long& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (__int64& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned __int64& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}
#line 295 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (float& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (double& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}






#line 312 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (bool& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}
#line 319 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (void*& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}



template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek() {
  typename _Traits::int_type __tmp = _Traits::eof();

  this->_M_gcount = 0;
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
     {
      __tmp = this->rdbuf()->sgetc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
    if (this->_S_eof(__tmp))
      this->setstate(ios_base::eofbit);
  }

  return __tmp;
}


template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get() {
  typename _Traits::int_type __tmp = _Traits::eof();
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
     {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!this->_S_eof(__tmp))
      this->_M_gcount = 1;
  }

  if (_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return __tmp;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT& __c) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();
     {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!this->_S_eof(__tmp)) {
      this->_M_gcount = 1;
      __c = _Traits::to_char_type(__tmp);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}






template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::ignore() {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    int_type __c;
     {
      __c = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return *this;
    }

    if (!this->_S_eof(__c))
      this->_M_gcount = 1;
    else
      this->setstate(ios_base::eofbit);
  }

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(_CharT __c) {
  this->_M_gcount = 0;
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

    if (__buf) {
       {
        __tmp = __buf->sputbackc(__c);
      }
      if (false) {
        this->_M_handle_exception(ios_base::badbit);
      }
    }
    if (this->_S_eof(__tmp))
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::unget() {
  this->_M_gcount = 0;

  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    
    if (__buf) {
       {
        if (this->_S_eof(__buf->sungetc()))
          this->setstate(ios_base::badbit);
      }
      if (false) {
        this->_M_handle_exception(ios_base::badbit);
      }
    } else
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync() {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (__buf) {
    if (__buf->pubsync() == -1) {
      this->setstate(ios_base::badbit);
      return -1;
    }
    else
      return 0;
  }
  else
    return -1;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg() {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  return (__buf && !this->fail()) ? __buf->pubseekoff(0, ios_base::cur, ios_base::in)
    : pos_type(-1);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!this->fail() && __buf) {
    if (__buf->pubseekpos(__pos, ios_base::in) == pos_type(-1)) {
      this->setstate(ios_base::failbit);
    }
  }
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir) {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!this->fail() && __buf)
    __buf->pubseekoff(__off, __dir, ios_base::in);
  return *this;
}



template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT& __c) {


  sentry __sentry(*this); 

  if (__sentry) {
    typename _Traits::int_type __tmp;

     {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return;
    }

    if (!this->_S_eof(__tmp))
      __c = _Traits::to_char_type(__tmp);
    else
      this->setstate(ios_base::eofbit | ios_base::failbit);
  }
}























namespace priv {

template < class _CharT, class _Traits, class _Is_Delim>
streamsize __cdecl
__read_unbuffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
                  streamsize _Num, _CharT* __s,
                  _Is_Delim __is_delim,
                  bool __extract_delim, bool __append_null,
                  bool __is_getline)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;

  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
  
   {
    for (;;) {
      if (__n == _Num) {
        if (__is_getline) 
          __status |= ios_base::failbit;
        break;
      }
      int_type __c = __buf->sbumpc(); 

      if (__that->_S_eof(__c)) {
        if (__n < _Num || __is_getline)
          __status |= ios_base::eofbit;
        break;
      } else if (__is_delim(_Traits::to_char_type(__c))) {
        if (__extract_delim) { 
          ++__n;
        } else if ( !__pushback(__buf, _Traits::to_char_type(__c)) ) { 
          __status |= ios_base::failbit;
        }
        break;
      }
      
      *__s++ = _Traits::to_char_type(__c);
      ++__n;
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    *__s = _CharT();
    return __n;
  }

  if (__append_null)
    *__s =  _CharT();
  if (__status)
    __that->setstate(__status);    
  return __n;
}





template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize __cdecl
__read_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
                 streamsize _Num, _CharT* __s,
                 _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                 bool __extract_delim, bool __append_null,
                 bool __is_getline) {
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  bool __done    = false;

   {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
      const _CharT* __first = __buf->_M_gptr();
      const _CharT* __last  = __buf->_M_egptr();
      
      
      typedef char __static_assert[(sizeof(streamsize) > sizeof(ptrdiff_t)) || ((sizeof(streamsize) == sizeof(ptrdiff_t)) && numeric_limits<ptrdiff_t>::is_signed) ? 1 : -1] ;
#line 666 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"
      ptrdiff_t __request = static_cast<ptrdiff_t>((min) (static_cast<streamsize>((numeric_limits<ptrdiff_t>::max)()), _Num - __n));

      const _CharT* __p  = __scan_delim(__first, __last);
      ptrdiff_t __chunk = (min) (ptrdiff_t(__p - __first), __request);
      _Traits::copy(__s, __first, __chunk);
      __s += __chunk;
      __n += __chunk;
      __buf->_M_gbump((int)__chunk);

      
      if (__p != __last && __p - __first <= __request) {
        if (__extract_delim) {
          __n += 1;
          __buf->_M_gbump(1);
        }
        __done = true;
      }

      
      else if (__n == _Num) {

        
        if (__is_getline) {
          if (__chunk == __last - __first) {
            if (__that->_S_eof(__buf->sgetc()))
              __status |= ios_base::eofbit;
          }
          else
            __status |= ios_base::failbit;
        }
        __done   = true;
      }

      
      
      else {
        if (__that->_S_eof(__buf->sgetc())) {
          __status |= ios_base::eofbit;
          __done = true;
        }
      }
    } 
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    __done = true;
  }

  if (__done) {
    if (__append_null)
        *__s =  _CharT();
    if (__status != 0)
      __that->setstate(__status);   
    return __n;
  }

  
  
  
  

  return __n + __read_unbuffered(__that,  __buf, _Num - __n, __s, __is_delim,
                                 __extract_delim,__append_null,__is_getline);
}

}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT* __s, streamsize __n,
                                    _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

      if (__buf->egptr() != __buf->gptr())
        this->_M_gcount =
          ::std::priv:: __read_buffered(this,  __buf, __n - 1, __s,
                                     ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                     ::std::priv:: _Scan_for_char_val<_Traits>(__delim),
                                     false, true, false);
      else
        this->_M_gcount =
          ::std::priv:: __read_unbuffered(this,  __buf, __n - 1, __s,
                                       ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                       false, true, false);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(_CharT* __s, streamsize __n,
                                        _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
      this->_M_gcount = __buf->egptr() != __buf->gptr()
        ? ::std::priv:: __read_buffered(this,  __buf, __n - 1, __s,
                                     ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                     ::std::priv:: _Scan_for_char_val<_Traits>(__delim),
                                     true, true, true)
        : ::std::priv:: __read_unbuffered(this,  __buf, __n - 1, __s,
                                       ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                       true, true, true);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  else
    if (_Traits::eq(this->widen('\n'), __delim))
    {
        int i;
        for (i = 0; __s[i]; i++);
        while (--i >= 0 && _Traits::eq(__s[i], this->widen('\r'))) __s[i] = this->widen(0);
    }
#line 798 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof()) {
    basic_streambuf<_CharT, _Traits>*__buf = this->rdbuf();
    if (__buf->gptr() != __buf->egptr())
      _M_gcount
        = ::std::priv:: __read_buffered(this,  __buf, __n, __s,
                                     ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                     ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                     false, false, false);
    else
      _M_gcount
        = ::std::priv:: __read_unbuffered(this,  __buf, __n, __s,
                                       ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                       false, false, false);
  }
  else
    this->setstate(ios_base::failbit);

  if (this->eof())
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}




template <class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __nmax) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof() && __nmax >= 0) {

    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __avail = __buf->in_avail();

    
    if (__avail == -1)
      this->_M_setstate_nothrow(ios_base::eofbit);

    else if (__avail != 0) {

      if (__buf->gptr() != __buf->egptr())
        _M_gcount
          = ::std::priv:: __read_buffered(this,  __buf, (min) (__avail, __nmax), __s,
                                       ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                       ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                       false, false, false);
      else
        _M_gcount
          = ::std::priv:: __read_unbuffered(this,  __buf, (min) (__avail, __nmax), __s,
                                         ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                         false, false, false);
    }
  }
  else {
    
    if (this->eof())
      this->setstate(ios_base::eofbit | ios_base::failbit);
    else
      this->setstate(ios_base::failbit);
  }

  
  

  return _M_gcount;
}

template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT* __s) {
  sentry __sentry(*this); 

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __nmax = this->width() > 0
      ? this->width() - 1
      : ((numeric_limits<streamsize>::max)() / sizeof(_CharT)) - 1;

    streamsize __n = __buf->gptr() != __buf->egptr()
      ? ::std::priv:: __read_buffered(this,  __buf, __nmax, __s,
                                   ::std::priv:: _Is_wspace_null<_Traits>(this->_M_ctype_facet()),
                                   ::std::priv:: _Scan_wspace_null<_Traits>(this->_M_ctype_facet()),
                                   false, true, false)
      : ::std::priv:: __read_unbuffered(this,  __buf, __nmax, __s,
                                     ::std::priv:: _Is_wspace_null<_Traits>(this->_M_ctype_facet()),
                                     false, true, false);
    if (__n == 0)
      this->setstate(ios_base::failbit);
  }
  this->width(0);
}






template < class _CharT, class _Traits, class _Is_Delim>
void __cdecl
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
                     basic_streambuf<_CharT, _Traits>* __buf,
                     _Is_Delim __is_delim,
                     bool __extract_delim, bool __set_failbit) {
  bool __done = false;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

   {
    while (!__done) {
      int_type __c = __buf->sbumpc();

      if (__that->_S_eof(__c)) {
        __done = true;
        __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
                                  : ios_base::eofbit;
      }

      else if (__is_delim(_Traits::to_char_type(__c))) {
        __done = true;
        if (!__extract_delim)
          if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
            __status |= ios_base::failbit;
      }
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
  }

  __that->setstate(__status);
}






template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
void __cdecl
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
                   basic_streambuf<_CharT, _Traits>* __buf,
                   _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                   bool __extract_delim, bool __set_failbit) {
  bool __at_eof      = false;
  bool __found_delim = false;

   {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__at_eof && !__found_delim) {
      const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
      __buf->_M_gbump((int)(__p - __buf->_M_gptr()));

      if (__p != __buf->_M_egptr()) { 
        if (__extract_delim)
          __buf->_M_gbump(1);
        __found_delim = true;
      }

      else                         
        __at_eof = __that->_S_eof(__buf->sgetc());
    }                              
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    return;
  }

  if (__at_eof) {
    __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
                                   : ios_base::eofbit);
    return;
  }
  if (__found_delim)
    return;

  
  
  
  
  _M_ignore_unbuffered(__that,  __buf, __is_delim, __extract_delim, __set_failbit);
}












template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim>
streamsize __cdecl
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
                     basic_streambuf<_CharT, _Traits>* __buf,
                     streamsize _Num, _Max_Chars __max_chars,
                     _Is_Delim __is_delim,
                     bool __extract_delim, bool __set_failbit) {
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

   {
    while (__max_chars(_Num, __n) > 0) {
      int_type __c = __buf->sbumpc();

      if (__that->_S_eof(__c)) {
        __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
                                  : ios_base::eofbit;
        break;
      }

      else if (__is_delim(_Traits::to_char_type(__c))) {
        if (__extract_delim)
          ++__n;
        else if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
          __status |= ios_base::failbit;

        break;
      }
      
      ++__n;
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
  }

  if (__status)
    __that->setstate(__status);   
  return __n;
}

template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim, class _Scan_Delim>
streamsize __cdecl
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
                   basic_streambuf<_CharT, _Traits>* __buf,
                   streamsize _Num,
                   _Max_Chars __max_chars,
                   _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                   bool __extract_delim, bool __set_failbit) {
  streamsize __n = 0;
  bool __at_eof = false;
  bool __done   = false;

   {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
      ptrdiff_t __avail = __buf->_M_egptr() - __buf->_M_gptr();
      streamsize __m = __max_chars(_Num, __n);

      if (__avail >= __m) {       
        const _CharT* __last = __buf->_M_gptr() + static_cast<ptrdiff_t>(__m);
        const _CharT* __p = __scan_delim(__buf->_M_gptr(), __last);
        ptrdiff_t __chunk = __p - __buf->_M_gptr();
        __n += __chunk;
        __buf->_M_gbump((int)__chunk);

        if (__extract_delim && __p != __last) {
          __n += 1;
          __buf->_M_gbump(1);
        }

        __done = true;
      }

      else {
        const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
        ptrdiff_t __chunk = __p - __buf->_M_gptr();
        __n += __chunk;
        __buf->_M_gbump((int)__chunk);

        if (__p != __buf->_M_egptr()) { 
          if (__extract_delim) {
            __n += 1;
            __buf->_M_gbump(1);
          }

          __done = true;
        }

        
        else if (__that->_S_eof(__buf->sgetc())) {
          __done   = true;
          __at_eof = true;
        }
      }
    } 
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    return __n;
  }

  if (__at_eof)
    __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
                                   : ios_base::eofbit);

  if (__done)
    return __n;

  
  
  
  

  return __n + _M_ignore_unbuffered(__that,  __buf, _Num, __max_chars,
                                    __is_delim, __extract_delim, __set_failbit);
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef ::std::priv:: _Constant_unary_fun<bool, int_type> _Const_bool;
    typedef ::std::priv:: _Constant_binary_fun<streamsize, streamsize, streamsize> _Const_streamsize;
    const streamsize __maxss = (numeric_limits<streamsize>::max)();

    if (__n == (numeric_limits<int>::max)()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this,  __buf,
                                       __maxss, _Const_streamsize(__maxss),
                                       _Const_bool(false),
                                       ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                       false, false);
      else
        _M_gcount = _M_ignore_unbuffered(this,  __buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         _Const_bool(false), false, false);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this,  __buf,
                                       __n, minus<streamsize>(),
                                       _Const_bool(false),
                                       ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                       false, false);
      else
        _M_gcount = _M_ignore_unbuffered(this,  __buf, __n, minus<streamsize>(),
                                         _Const_bool(false), false, false);
    }
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef ::std::priv:: _Constant_binary_fun<streamsize, streamsize, streamsize>
      _Const_streamsize;
    const streamsize __maxss = (numeric_limits<streamsize>::max)();

    if (__n == (numeric_limits<int>::max)()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this,  __buf,
                                       __maxss, _Const_streamsize(__maxss),
                                       ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                       ::std::priv:: _Scan_for_int_val<_Traits>(__delim),
                                       true, false);
      else
        _M_gcount = _M_ignore_unbuffered(this,  __buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                         true, false);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this,  __buf,
                                       __n, minus<streamsize>(),
                                       ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                       ::std::priv:: _Scan_for_int_val<_Traits>(__delim),
                                       true, false);
      else
        _M_gcount = _M_ignore_unbuffered(this,  __buf, __n, minus<streamsize>(),
                                         ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                         true, false);
    }
  }

  return *this;
}



template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_skip_whitespace(bool __set_failbit) {
  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!__buf)
    this->setstate(ios_base::badbit);
  else if (__buf->gptr() != __buf->egptr())
    _M_ignore_buffered(this,  __buf,
                       ::std::priv:: _Is_not_wspace<_Traits>(this->_M_ctype_facet()),
                       ::std::priv:: _Scan_for_not_wspace<_Traits>(this->_M_ctype_facet()),
                       false, __set_failbit);
  else
    _M_ignore_unbuffered(this,  __buf,
                         ::std::priv:: _Is_not_wspace<_Traits>(this->_M_ctype_facet()),
                         false, __set_failbit);
}









namespace priv {

template < class _CharT, class _Traits, class _Is_Delim>
streamsize __cdecl
__copy_unbuffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
                  basic_streambuf<_CharT, _Traits>* __dest,
                  _Is_Delim __is_delim,
                  bool __extract_delim, bool __rethrow) {
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
  int_type __c;

   {
    for (;;) {
      
      __c = __src->sbumpc();

      
      if (__that->_S_eof(__c)) {
        __status |= ios_base::eofbit;
        break;
      }
      
      else if (__is_delim(_Traits::to_char_type(__c))) {
        if (!__extract_delim && !__pushback(__src, _Traits::to_char_type(__c)))
          __status |= ios_base::failbit;
        break;
      }
      else {
        
        bool __failed = false;
         {
          if (!__that->_S_eof(__dest->sputc(_Traits::to_char_type(__c))))
            ++__extracted;
          else
            __failed = true;
        }
        if (false) {
          __failed = true;
        }

        
        
        if (__failed && !__pushback(__src, _Traits::to_char_type(__c)))
          __status |= ios_base::failbit;

        
        if (__failed)
          break;
      }

    } 

  }
  
  
  if (false) {
    
    if (__rethrow && __extracted == 0)
      __that->_M_handle_exception(ios_base::failbit);
  }
  __that->setstate(__status);
  return __extracted;
}






template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize __cdecl
__copy_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
                basic_streambuf<_CharT, _Traits>* __dest,
                _Scan_Delim __scan_delim, _Is_Delim __is_delim,
                bool __extract_delim, bool __rethrow) {
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
  
  int_type __c ;
  _CharT* __first = __src->_M_gptr();
  ptrdiff_t __avail = __src->_M_egptr() - __first;
  
  bool __do_handle_exceptions = false;

   {
    for (;;) {
      const _CharT* __last = __scan_delim(__first, __src->_M_egptr());

      
      streamsize __n = __dest->sputn(__first, __extract_delim && __last != __src->_M_egptr()
                                     ? (__last - __first) + 1
                                     : (__last - __first));
      __src->_M_gbump((int)__n);
      __extracted += __n;

      
      __do_handle_exceptions = true;

      if (__n < __avail)          
        break;                    

      __c = __src->sgetc();

      
      
      __first = __src->_M_gptr();
      __avail = __src->_M_egptr() - __first;

      if (__avail > 0)
        {}  
      else if (__that->_S_eof(__c)) {
        __status |= ios_base::eofbit;
        break;
      }
      else {
        return __extracted + __copy_unbuffered(__that,  __src, __dest, __is_delim,
                                                __extract_delim, __rethrow);
      }

      __do_handle_exceptions = false;
    }
  }

  if (false) {
    
    if (__rethrow && __do_handle_exceptions &&  __extracted == 0)
      __that->_M_handle_exception(ios_base::failbit);
  }

  if (__status)
    __that->setstate(__status);   
  return __extracted;
}

}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
  ::get(basic_streambuf<_CharT, _Traits>& __dest, _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();

    if (__src)
      this->_M_gcount = __src->egptr() != __src->gptr()
        ? ::std::priv:: __copy_buffered(this,  __src, &__dest,
                                     ::std::priv:: _Scan_for_char_val<_Traits>(__delim),
                                     ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                     false, false)
        : ::std::priv:: __copy_unbuffered(this,  __src, &__dest,
                                       ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                       false, false);
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
  ::operator>>(basic_streambuf<_CharT, _Traits>* __dest) {
  streamsize __n = 0;
  typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
  _Sentry __sentry(*this);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();
    if (__src && __dest)
      __n = __src->egptr() != __src->gptr()
        ? ::std::priv:: __copy_buffered(this,  __src, __dest,
                                     ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                     ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                     false, true)
        : ::std::priv:: __copy_unbuffered(this,  __src, __dest,
                                       ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                       false, true);
  }

  if (__n == 0)
    this->setstate(ios_base::failbit);

  return *this;
}





template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>
  ::basic_iostream(basic_streambuf<_CharT, _Traits>* __buf)
    : basic_ios<_CharT, _Traits>(),
      basic_istream<_CharT, _Traits>(__buf),
      basic_ostream<_CharT, _Traits>(__buf) {
  this->init(__buf);
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{}

}





#line 1448 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.c"





#line 353 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"
#line 354 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"

#line 356 "C:\\Pin35\\extras\\stlport\\include\\stl/_istream.h"




#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"
#line 29 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"


namespace std {

template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s);











#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&  __cdecl
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>& __cdecl
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim);



template <class _CharT, class _Traits, class _Alloc>
inline basic_istream<_CharT, _Traits>& __cdecl
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s) {
  return getline(__is, __s, __is.widen('\n'));
}
#line 70 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.c"











namespace std {

template <class _CharT, class _Traits>
bool __cdecl
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                   basic_streambuf<_CharT, _Traits>* __buf,
                   streamsize __n) {
  _CharT __f = __os.fill();
  for (streamsize __i = 0; __i < __n; ++__i) {
    if (_Traits::eq_int_type(__buf->sputc(__f), _Traits::eof()))
      return false;
  }
  return true;
}


template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>& __cdecl
operator << (basic_ostream<_CharT, _Traits>& __os,
             const basic_string<_CharT,_Traits,_Alloc>& __s) {
  typedef basic_ostream<_CharT, _Traits> __ostream;
  typedef typename basic_string<_CharT, _Traits, _Alloc>::size_type size_type;

  
  typedef char __static_assert[static_cast<size_type>(-1) > 0 ? 1 : -1] ;

  typename __ostream::sentry __sentry(__os);
  bool __ok = false;

  if (__sentry) {
    __ok = true;
    size_type __n = __s.size();
    const bool __left = (__os.flags() & __ostream::left) != 0;
    const streamsize __w = __os.width(0);
    basic_streambuf<_CharT, _Traits>* __buf = __os.rdbuf();

    const bool __need_pad = (((sizeof(streamsize) > sizeof(size_t)) && (static_cast<streamsize>(__n) < __w)) ||
                             ((sizeof(streamsize) <= sizeof(size_t)) && (__n < static_cast<size_t>(__w))));
    streamsize __pad_len = __need_pad ? __w - __n : 0;

    if (!__left)
      __ok = __stlp_string_fill(__os, __buf, __pad_len);

    __ok = __ok && (__buf->sputn(__s.data(), streamsize(__n)) == streamsize(__n));

    if (__left)
      __ok = __ok && __stlp_string_fill(__os, __buf, __pad_len);
  }

  if (!__ok)
    __os.setstate(__ostream::failbit);

  return __os;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>& __cdecl
operator >> (basic_istream<_CharT, _Traits>& __is,
             basic_string<_CharT,_Traits, _Alloc>& __s) {
  typedef basic_istream<_CharT, _Traits> __istream;
  typedef typename basic_string<_CharT, _Traits, _Alloc>::size_type size_type;

  
  typedef char __static_assert[static_cast<size_type>(-1) > 0 ? 1 : -1] ;

  typename __istream::sentry __sentry(__is);

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    typedef ctype<_CharT> _C_type;

    const locale& __loc = __is.getloc();
    const _C_type& _Ctype = use_facet<_C_type>(__loc);
    __s.clear();
    streamsize __width = __is.width(0);
    size_type __n;
    if (__width <= 0)
      __n = __s.max_size();
    



    else if (sizeof(streamsize) > sizeof(size_type) &&
             (__width > static_cast<streamsize>(__s.max_size())))
      __n = 0;
    else {
      __n = static_cast<size_type>(__width);
      __s.reserve(__n);
    }

    while (__n-- > 0) {
      typename _Traits::int_type __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        _CharT __c = _Traits::to_char_type(__c1);

        if (_Ctype.is(_C_type::space, __c)) {
          if (_Traits::eq_int_type(__buf->sputbackc(__c), _Traits::eof()))
            __is.setstate(__istream::failbit);
          break;
        }
        else
          __s.push_back(__c);
      }
    }

    
    if (__s.empty())
      __is.setstate(__istream::failbit);
  }
  else
    __is.setstate(__istream::failbit);

  return __is;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>& __cdecl
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim) {
  typedef basic_istream<_CharT, _Traits> __istream;
  typedef typename basic_string<_CharT, _Traits, _Alloc>::size_type size_type;
  size_type __nread = 0;
  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is, true);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    __s.clear();

    while (__nread < __s.max_size()) {
      int __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        ++__nread;
        _CharT __c = _Traits::to_char_type(__c1);
        if (!_Traits::eq(__c, __delim))
          __s.push_back(__c);
        else
          break;              
      }
    }
  }
  if (__nread == 0 || __nread >= __s.max_size())
    __is.setstate(__istream::failbit);

  else if (_Traits::eq(__is.widen('\n'), __delim))
  {
      size_type i;
      for (i = __s.length() - 1; i >= 0 && _Traits::eq(__s[i], __is.widen('\r')); i--);
      __s = __s.substr(0, i + 1);
  }
#line 170 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.c"

  return __is;
}

}

#line 177 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.c"




#line 75 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"
#line 76 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"

#line 78 "C:\\Pin35\\extras\\stlport\\include\\stl/_string_io.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\string"
#line 39 "C:\\Pin35\\extras\\stlport\\include\\string"
#line 40 "C:\\Pin35\\extras\\stlport\\include\\string"







#line 48 "C:\\Pin35\\extras\\stlport\\include\\string"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 51 "C:\\Pin35\\extras\\stlport\\include\\string"

#line 53 "C:\\Pin35\\extras\\stlport\\include\\string"

#line 55 "C:\\Pin35\\extras\\stlport\\include\\string"





#line 82 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"


#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdarg.h"















































#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 42 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 46 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 48 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 83 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "c:\\pin35\\source\\include\\pin\\foundation.PLH"

















































#line 51 "c:\\pin35\\source\\include\\pin\\foundation.PLH"

#line 1 "C:\\Pin35\\extras\\crt\\include\\types_marker.h"






























































































































































































































































#line 53 "c:\\pin35\\source\\include\\pin\\foundation.PLH"

namespace LEVEL_BASE
{

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"









































#line 1 "C:\\Pin35\\extras\\crt\\include\\types.h"
































































































































































































#line 43 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"
#line 44 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"


    




#line 52 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"


typedef bool BOOL;


#line 58 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"



#line 62 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"


#line 65 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"

typedef signed int      SIZE;


using ::UINT32;
using ::UINT64;
using ::ADDRINT;
























































































#line 161 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"


typedef UINT32 VOIDINT;




#line 169 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"

typedef UINT64 REG_CLASS_BITS;
typedef UINT32 REG_SUBCLASS_BITS;







#line 180 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"



#line 184 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"

#line 186 "C:\\Pin35\\source\\include\\pin\\gen\\types_foundation.TLH"
#line 58 "c:\\pin35\\source\\include\\pin\\foundation.PLH"

}

#line 62 "c:\\pin35\\source\\include\\pin\\foundation.PLH"
#line 84 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "c:\\pin35\\source\\include\\pin\\pin-errtype.h"

















































typedef enum 
{
    PIN_ERR_FATAL,                 
    PIN_ERR_NONFATAL               
} PIN_ERR_SEVERITY_TYPE;

       



typedef enum 
{
    PIN_ERR_NONE = 0,               
    PIN_ERR_INTERNAL,               
    PIN_ERR_ASSERT,                 
    PIN_ERR_TOOL,                   
    PIN_ERR_CMD_LINE,               
    PIN_ERR_PARSING,                
    PIN_ERR_NO_APP,                 
    PIN_ERR_INVALID_PLOAD,          
    PIN_ERR_FILE_NOT_FOUND,         
    PIN_ERR_ELF_HEADER,             
    PIN_ERR_NO_PIE,                 
    PIN_ERR_NO_ENTRY_OFFSET,        
    PIN_ERR_INVALID_ADDRESS,        
    PIN_ERR_INVALID_ADDRESS_RANGE,  
    PIN_ERR_CANNOT_LOAD_TOOL,       
    PIN_ERR_PIN_INJECTION,          
    PIN_ERR_WAIT_FOR_INJECTOR,      
    PIN_ERR_BAD_OS_FILE,            
    PIN_ERR_UNSUPPORTED_OS,         
    PIN_ERR_BIN32,                  
    PIN_ERR_BIN64,                  
    PIN_ERR_CANNOT_RUN,             
    PIN_ERR_ATTACH_PID,             
    PIN_ERR_ATTACH_NYI,             
    PIN_ERR_ATTACH_REJECTED,        
    PIN_ERR_ATTACH_PTRACE_SCOPE_1,  
    PIN_ERR_DETACH_PID,             
    PIN_ERR_WAIT_PID,               
    PIN_ERR_STEP_PID,               
    PIN_ERR_WAIT_EXECV,             
    PIN_ERR_APP_RESUME,             
    PIN_ERR_NO_INSTRUMENT,          
    PIN_ERR_CHILD_PTRACEME,         
    PIN_ERR_CHILD_RESUME,           
    PIN_ERR_RELINK_APP,             
    PIN_ERR_KNOB_BAD,               
    PIN_ERR_NO_RELOCS,              
    PIN_ERR_VERSION_SKEW,           
    PIN_ERR_MS_DOS,                 
    PIN_ERR_LONG_PATH,              
    PIN_ERR_CANNOT_EXECUTE_FILE,    
    PIN_ERR_BLOCKSIG_TOOL,          

    PIN_ERR_BLOCKSIG_APP,           

    PIN_ERR_USER_SPECIFIED_ERROR,   
    PIN_ERR_OUT_OF_MEMORY,          
    PIN_ERR_NON_NUMERIC_STRING,     
    PIN_ERR_EMPTY_STRING,           
    PIN_ERR_NUMERIC_FROM_STRING,    
    PIN_ERR_ALREADY_ATTACHED,       
    PIN_ERR_ILLEGAL_EXCEPTION,      
    PIN_ERR_EXCEPTION_NEEDS_ADDR,   
    PIN_ERR_PREDEFINED_INSTRUMENTATION_FAILED, 
    PIN_ERR_UNSUPPORTED_SYSCALL,    
    PIN_ERR_ACCESS_DENIED,          
    PIN_ERR_INVALID_SUSPEND_REQUEST,
    PIN_ERR_DEBUGGER,               
    PIN_ERR_LAST                    
} PIN_ERRTYPE;

#line 124 "c:\\pin35\\source\\include\\pin\\pin-errtype.h"
#line 85 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


namespace LEVEL_BASE
{
    using namespace std;
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"








































typedef VOID (*AFUNPTR)();
typedef VOID *(*THREAD_STARTROUTINE)(void *);
typedef VOID (*DESTRUCTFUN)(void*);

static inline USIZE USIZE_INVALID() {return ~((USIZE)0);}





typedef UINT16 OPCODE;

static inline  OPCODE OPCODE_INVALID() {return  0;}
static inline BOOL OPCODE_valid(OPCODE opc){ return opc != 0;}



#line 59 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"

#line 61 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"





#line 67 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"



#line 71 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"

#line 73 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"





#line 79 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"



#line 83 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"

#line 85 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"



#line 89 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"

#line 91 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"





#line 97 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"



#line 101 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"

#line 103 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"





#line 109 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"





#line 115 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"



#line 119 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"

#line 121 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"







#line 129 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"


#line 132 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"

class STAT;
class STAT_NORM;

























































#line 193 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"


typedef struct
{
    ADDRINT _brk;
    ADDRINT _phdr;
    ADDRINT _entry;
    UINT32 _phnum;
    const CHAR *_loaderFname;
    VOID *_pinclientint;
    CHAR *_pinversion;
    VOID *_fpWaitForReady;

    
    ADDRINT _loadOffsetIndex;

    
    
    ADDRINT _loadOffset;

    
    VOID *_dlHandle;

    
    ADDRINT _toolBaseAddress;

    
    ADDRINT _textAddress;

    
    ADDRINT _dataAddress;

    
    ADDRINT _bssAddress;

    
    CHAR *_toolFname;
} ImageLoaderInfo;

typedef struct {
public:
    char* name;
    ADDRINT lm;
    ADDRINT l_ld;
    ADDRINT l_addr;
} LINUX_LOADER_IMAGE_INFO;

#line 241 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"







const UINT32 PIN_INFINITE_TIMEOUT = static_cast<UINT32>(-1);




const UINT32 PIN_MAX_THREADS = 2048;

#line 256 "C:\\Pin35\\source\\include\\pin\\gen\\types_base.TLH"
#line 91 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\message.PH"






class LOGFILE
{
  public:
    








    virtual VOID Open(const CHAR *name, BOOL append) = 0;

    virtual BOOL IsOpen() const = 0;
    virtual VOID Close() = 0;

    


    virtual VOID Write(const CHAR* message, size_t length) = 0;
    VOID Write(const string& message);
    virtual VOID WriteAtPosition( const CHAR* message, size_t length, size_t offset) = 0;

    virtual ~LOGFILE() {}
};

                                                                  
enum LOGTYPE
{
    LOGTYPE_CONSOLE,              
    LOGTYPE_LOGFILE,              
    LOGTYPE_CONSOLE_AND_LOGFILE   
};

                                                                  
typedef BOOL (*MESSAGE_CALLBACK)(const string &message, PIN_ERRTYPE type,
                                            INT32 userType, INT32 severity, INT32 numArgs,
                                            va_list ap);

                                                                  
class MESSAGE_TYPE
{
  private:
    static VOID (*_panic_callback) ();
    static VOID (*_terminate_callback) ();
    static string _log_fname;
    static string _image_name;
    static MESSAGE_TYPE *_list;
    static LOGFILE   *_logstream;
    static BOOL _logstreamAppend;
    static MESSAGE_CALLBACK _message_callback;

  private:
    const string _name;
    const string _prefix;
    const string _comment;
    BOOL _terminate;
    BOOL _trace;
    BOOL _enabled;
    BOOL _resource;
    LOGTYPE _log;
    
    BOOL _initted;

    MESSAGE_TYPE   *_next;


  public:
    static VOID RegisterPanicCallBack( VOID (*cb) () );
    static VOID RegisterTerminateCallBack( VOID (*cb) () );
    static VOID RegisterLogFile(const string& name, BOOL append);
    static string GetLogFileName();
    static VOID RegisterImageName(const string& name );
    static MESSAGE_TYPE * Find(const string& name);
    static BOOL Disable(const string& name);
    static BOOL Enable(const string& name);
    static UINT32 Number();
    static string StringLongAll();
    static BOOL IsTerminating();
    static __declspec(noreturn) VOID PrintMessageAndExit(const char *message, const char *message2,
                                    PIN_ERRTYPE errType = PIN_ERR_NONE, INT32 numArgs = 0, ...);
    static VOID RegisterMessageCallBack(MESSAGE_CALLBACK fun);
    static VOID UnregisterMessageCallBack();
    static MESSAGE_CALLBACK MessageCallBack();
    static BOOL ErrorFileSpecified();

  private:
    static VOID DumpTrace();

  public:
    MESSAGE_TYPE( string name, string prefix, BOOL terminate, BOOL trace, BOOL enabled, BOOL resource,
                  LOGTYPE log, string comment);

    VOID Message(const string& message, BOOL printPrefix = 1,
                 PIN_ERRTYPE errType = PIN_ERR_NONE, INT32 numArgs=0, ...);

    VOID __declspec(noreturn) MessageNoReturn(const string& message, BOOL printPrefix = 1,
                 PIN_ERRTYPE errType = PIN_ERR_NONE, INT32 numArgs=0, ...);

    BOOL inline on() const {return _enabled;}
    VOID disable() {_enabled=false;}
    VOID enable() {_enabled=true;}

    int Compare(const MESSAGE_TYPE & k2) const;

  private:
    VOID MessageInternal(const string& message, BOOL printPrefix, PIN_ERRTYPE errType, va_list va, INT32 numArgs);
};

                                                                  
class MESSAGE_TYPE_ALWAYS_ON : public MESSAGE_TYPE
{
  public:
    inline MESSAGE_TYPE_ALWAYS_ON( string name, string prefix, BOOL terminate, BOOL trace, BOOL resource,
                  LOGTYPE log, string comment)
      : MESSAGE_TYPE(name, prefix, terminate, trace, true, resource, log, comment)
    {}
    BOOL inline on() const {return true;}
};

                                                                  
extern MESSAGE_TYPE MessageTypeNonFatalError;

                                                                  
extern MESSAGE_TYPE MessageTypeError;

                                                                  
extern MESSAGE_TYPE MessageTypeCriticalError;

                                                                  
extern MESSAGE_TYPE MessageTypeWarning;

                                                                  
extern MESSAGE_TYPE MessageTypeConsole;

                                                                  
extern MESSAGE_TYPE MessageTypeConsoleNoPrefix;

                                                                  
extern MESSAGE_TYPE_ALWAYS_ON MessageTypeAssert;

                                                                  
extern MESSAGE_TYPE MessageTypePhase;

                                                                  
extern MESSAGE_TYPE MessageTypeKnown;

                                                                  
extern MESSAGE_TYPE MessageTypeInfo;

                                                                  
extern MESSAGE_TYPE MessageTypeDebug;

                                                                  
extern MESSAGE_TYPE MessageTypeOpportunity;

                                                                  
extern MESSAGE_TYPE MessageTypeStats;

                                                                  
extern MESSAGE_TYPE MessageTypeLog;

                                                                  
extern const string Line1;

                                                                  
extern UINT64 MilliSecondsElapsed();

                                                                  
extern string AssertString(const char *fileName, const char *functionName, unsigned line, const std::string &message);

                                                                  
extern "C" VOID PrintPinStackTrace(ostream& os);

                                                                  
extern VOID BreakMe();

                                                                  
extern BOOL SlowAssertsEnabled();

                                                                  
















#line 206 "C:\\Pin35\\source\\include\\pin\\gen\\message.PH"

#line 208 "C:\\Pin35\\source\\include\\pin\\gen\\message.PH"











































































#line 92 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
}

#line 1 "C:\\Pin35\\extras\\components\\include\\util/intel-fp.hpp"





































namespace UTIL {




union  X87REG_PADDED
{
    struct
    {
        UINT64 _significand;  
        UINT16 _exponent;     
        UINT16 _pad[3];
    } _fp;
    struct
    {
        UINT64 _lo;           
        UINT64 _hi;           
    } _raw;
};




union  XMMREG
{
    UINT8 _vec8[16];      
    UINT16 _vec16[8];     
    UINT32 _vec32[4];     
    UINT64 _vec64[2];     
};




struct  FXSAVE_IA32
{
    UINT16 _fcw;          
    UINT16 _fsw;          
    UINT8 _ftw;           
    UINT8 _pad1;
    UINT16 _fop;          
    UINT32 _fpuip;        
    UINT16 _cs;           
    UINT16 _pad2;
    UINT32 _fpudp;        
    UINT16 _ds;           
    UINT16 _pad3;
    UINT32 _mxcsr;        
    UINT32 _mxcsrmask;    
    X87REG_PADDED _sts[8];      
    XMMREG _xmms[8];            
    UINT8 _pad4[224];
};




struct  FXSAVE_INTEL64_DEFAULT
{
    UINT16 _fcw;          
    UINT16 _fsw;          
    UINT8 _ftw;           
    UINT8 _pad1;
    UINT16 _fop;          
    UINT32 _fpuip;        
    UINT16 _cs;           
    UINT16 _pad2;
    UINT32 _fpudp;        
    UINT16 _ds;           
    UINT16 _pad3;
    UINT32 _mxcsr;        
    UINT32 _mxcsrmask;    
    X87REG_PADDED _sts[8];      
    XMMREG _xmms[16];           
    UINT8 _pad4[96];
};




struct  FXSAVE_INTEL64_PROMOTED
{
    UINT16 _fcw;          
    UINT16 _fsw;          
    UINT8 _ftw;           
    UINT8 _pad1;
    UINT16 _fop;          
    UINT64 _fpuip;        
    UINT64 _fpudp;        
    UINT32 _mxcsr;        
    UINT32 _mxcsrmask;    
    X87REG_PADDED _sts[8];      
    XMMREG _xmms[16];           
    UINT8 _pad4[96];
};










inline UINT8 GetX87AbridgedTag(UINT16 fullTag)
{
    const UINT16 empty = 3;

    UINT8 tags = 0;
    UINT16 mask = 3;
    for (int i = 0;  i < 8;  i++)
    {
        UINT8 tag;
        if ((fullTag & mask) == (empty << 2*i))
            tag = 0;
        else
            tag = 1;
        tags |= (tag << i);
        mask <<= 2;
    }

    return tags;
}









template<typename FXSAVE> UINT16 GetX87FullTag(const FXSAVE *fxsave)
{
    
    

    UINT16 tags = 0;
    UINT8 ftw = fxsave->_ftw;
    unsigned tos = (fxsave->_fsw >> 11) & 0x7;

    const UINT16 valid = 0;
    const UINT16 zero = 1;
    const UINT16 special = 2;
    const UINT16 empty = 3;
    const UINT64 jbit = UINT64(1) << 63;

    for (unsigned i = 0;  i < 8;  i++)
    {
        UINT16 tag;

        if (!(ftw & 1))
        {
            tag = empty;
        }
        else
        {
            
            
            
            unsigned streg = (i - tos) & 0x7;
            const X87REG_PADDED *reg = &fxsave->_sts[streg];

            UINT16 exponent = reg->_fp._exponent & 0x7fff;
            if (exponent == 0x7fff)
            {
                tag = special;
            }
            else if (exponent == 0)
            {
                if (!reg->_fp._significand)
                {
                    tag = zero;
                }
                else
                {
                    tag = special;
                }
            }
            else
            {
                if (reg->_fp._significand & jbit)
                    tag = valid;
                else
                    tag = special;
            }
        }

        tags |= (tag << (2*i));
        ftw >>= 1;
    }

    return tags;
}











inline UINT16 GetSimpleX87FullTag(UINT8 abridgedTag)
{
    const UINT16 valid = 0;
    const UINT16 empty = 3;

    UINT16 tags = 0;
    for (unsigned i = 0;  i < 8;  i++)
    {
        UINT16 tag = (abridgedTag & 1) ? valid : empty;
        tags |= (tag << (2*i));
        abridgedTag >>= 1;
    }

    return tags;
}


} 
#line 263 "C:\\Pin35\\extras\\components\\include\\util/intel-fp.hpp"
#line 95 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"

































































namespace ATOMIC {}

#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\util.hpp"










































namespace UTIL {}

#line 1 "c:\\pin35\\extras\\components\\include\\util/data.hpp"




































#line 1 "C:\\Pin35\\extras\\stlport\\include\\string"



























































#line 38 "c:\\pin35\\extras\\components\\include\\util/data.hpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\cstring"




















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 





#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 22 "C:\\Pin35\\extras\\stlport\\include\\cstring"
#line 23 "C:\\Pin35\\extras\\stlport\\include\\cstring"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\cstring"







#line 37 "C:\\Pin35\\extras\\stlport\\include\\cstring"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 40 "C:\\Pin35\\extras\\stlport\\include\\cstring"

#line 42 "C:\\Pin35\\extras\\stlport\\include\\cstring"

#line 44 "C:\\Pin35\\extras\\stlport\\include\\cstring"




#line 39 "c:\\pin35\\extras\\components\\include\\util/data.hpp"

#line 1 "c:\\pin35\\extras\\components\\include\\types.h"






























































































































































































































#line 41 "c:\\pin35\\extras\\components\\include\\util/data.hpp"


namespace UTIL {










class  DATA
{
public:
    


    enum COPY
    {
        


        COPY_EAGER,

        








        COPY_LAZY
    };

    


    enum FILL
    {
        FILL_UNSPECIFIED,   
        FILL_ZERO           
    };


public:
    


    DATA() : _sbuf(0), _start(0), _size(0) {}

    





    DATA(size_t size, FILL fill = FILL_UNSPECIFIED)
    :
        _sbuf(new SHARED_BUF(size)),
        _start(_sbuf->_buf),
        _size(size)
    {
        if (fill == FILL_ZERO)
            std::memset(_start, 0, _size);
    }

    






    DATA(const void *buf, size_t size, COPY copy = COPY_EAGER)
    {
        CopyFromBuffer(buf, size, copy);
    }

    





    DATA(const char *str, COPY copy = COPY_EAGER)
    {
        CopyFromBuffer(str, std::strlen(str), copy);
    }

    





    DATA(const std::string &str, COPY copy = COPY_EAGER)
    {
        CopyFromBuffer(str.c_str(), str.size(), copy);
    }

    






    DATA(const DATA &other, size_t off=0)
    {
        CopyFromData(other, off);
    }

    









    DATA(const DATA &other, size_t off, size_t len)
    {
        CopyFromDataWithLen(other, off, len);
    }

    ~DATA() {DetachBuf();}

    






    DATA &operator =(const DATA &other)
    {
        Assign(other);
        return *this;
    }

    





    void Assign(size_t size, FILL fill = FILL_UNSPECIFIED)
    {
        DetachBuf();
        _sbuf = new SHARED_BUF(size);
        _start = _sbuf->_buf;
        _size = size;
        if (fill == FILL_ZERO)
            std::memset(_start, 0, _size);
    }

    






    void Assign(const void *buf, size_t size, COPY copy = COPY_EAGER)
    {
        DetachBuf();
        CopyFromBuffer(buf, size, copy);
    }

    





    void Assign(const char *str, COPY copy = COPY_EAGER)
    {
        DetachBuf();
        CopyFromBuffer(str, std::strlen(str), copy);
    }

    





    void Assign(const std::string &str, COPY copy = COPY_EAGER)
    {
        DetachBuf();
        CopyFromBuffer(str.c_str(), str.size(), copy);
    }

    






    void Assign(const DATA &other, size_t off=0)
    {
        if (this != &other)
        {
            DetachBuf();
            CopyFromData(other, off);
        }
        else
        {
            PopFront(off);
        }
    }

    









    void Assign(const DATA &other, size_t off, size_t len)
    {
        if (this != &other)
        {
            DetachBuf();
            CopyFromDataWithLen(other, off, len);
        }
        else
        {
            PopFront(off);
            if (len < _size)
                _size = len;
        }
    }

    


    void Clear()
    {
        DetachBuf();
        _sbuf = 0;
        _start = 0;
        _size = 0;
    }

    





    void PopFront(size_t num)
    {
        if (num >= _size)
        {
            DetachBuf();
            _sbuf = 0;
            _start = 0;
            _size = 0;
            return;
        }
        _start = static_cast<UINT8 *>(_start) + num;
        _size -= num;
    }

    





    void PopBack(size_t num)
    {
        if (num >= _size)
        {
            DetachBuf();
            _sbuf = 0;
            _start = 0;
            _size = 0;
            return;
        }
        _size -= num;
    }

    









    void Resize(size_t newSize, FILL fill = FILL_UNSPECIFIED)
    {
        if (newSize <= _size)
        {
            if (!newSize)
            {
                DetachBuf();
                _sbuf = 0;
                _start = 0;
                _size = 0;
                return;
            }
            _size = newSize;
        }
        else
        {
            
            
            
            
            
            SHARED_BUF *sbuf = new SHARED_BUF(newSize);
            std::memcpy(sbuf->_buf, _start, _size);
            if (fill == FILL_ZERO)
                std::memset(static_cast<UINT8 *>(sbuf->_buf) + _size, 0, newSize - _size);
            DetachBuf();
            _sbuf = sbuf;
            _start = sbuf->_buf;
            _size = newSize;
        }
    }

    




    void MakeUnique()
    {
        
        
        if (!_sbuf || _sbuf->_refCount == 1 || _sbuf->_refCount == EXCLUSIVE)
            return;

        
        
        _sbuf->_refCount--;
        _sbuf = new SHARED_BUF(_size);
        std::memcpy(_sbuf->_buf, _start, _size);
        _start = _sbuf->_buf;
    }

    


    size_t GetSize() const {return _size;}

    



    template<typename T> const T *GetBuf() const
    {
        return static_cast<const T *>(_start);
    }

    








    template<typename T> T *GetWritableBuf()
    {
        
        
        
        
        if (_sbuf && _sbuf->_refCount != EXCLUSIVE)
        {
            
            
            
            if (_sbuf->_refCount > 1)
            {
                _sbuf->_refCount--;
                _sbuf = new SHARED_BUF(_size);
                std::memcpy(_sbuf->_buf, _start, _size);
                _start = _sbuf->_buf;
            }

            
            
            
            else if (_sbuf->_isLazy)
            {
                UINT8 *buf = new UINT8[_size];
                std::memcpy(buf, _start, _size);
                _sbuf->_buf = buf;
                _sbuf->_size = _size;
                _sbuf->_isLazy = 0;
                _start = buf;
            }

            
            
            
            _sbuf->_refCount = EXCLUSIVE;
        }

        return static_cast<T *>(_start);
    }

    


    void ReleaseWritableBuf()
    {
        if (_sbuf && _sbuf->_refCount == EXCLUSIVE)
            _sbuf->_refCount = 1;
    }

private:
    






    void CopyFromBuffer(const void *buf, size_t size, COPY copy)
    {
        if (copy == COPY_EAGER)
        {
            _sbuf = new SHARED_BUF(size);
            std::memcpy(_sbuf->_buf, buf, size);
        }
        else
        {
            _sbuf = new SHARED_BUF(buf, size);
        }
        _start = _sbuf->_buf;
        _size = size;
    }

    






    void CopyFromData(const DATA &other, size_t off)
    {
        
        
        if (off >= other._size)
        {
            _sbuf = 0;
            _start = 0;
            _size = 0;
            return;
        }

        
        
        
        if (other._sbuf->_refCount == EXCLUSIVE)
        {
            _size = other._size - off;
            _sbuf = new SHARED_BUF(_size);
            std::memcpy(_sbuf->_buf, static_cast<UINT8 *>(other._start) + off, _size);
            _start = _sbuf->_buf;
            return;
        }

        
        
        _sbuf = other._sbuf;
        _sbuf->_refCount++;
        _start = static_cast<UINT8 *>(other._start) + off;
        _size = other._size - off;
    }

    









    void CopyFromDataWithLen(const DATA &other, size_t off, size_t len)
    {
        
        
        if (off >= other._size)
        {
            _sbuf = 0;
            _start = 0;
            _size = 0;
            return;
        }

        if (len > other._size - off)
            _size = other._size - off;
        else
            _size = len;

        
        
        
        if (other._sbuf->_refCount == EXCLUSIVE)
        {
            _sbuf = new SHARED_BUF(_size);
            std::memcpy(_sbuf->_buf, static_cast<UINT8 *>(other._start) + off, _size);
            _start = _sbuf->_buf;
            return;
        }

        
        
        _sbuf = other._sbuf;
        _sbuf->_refCount++;
        _start = static_cast<UINT8 *>(other._start) + off;
    }

    



    void DetachBuf()
    {
        if (_sbuf && ((_sbuf->_refCount == EXCLUSIVE) || (--(_sbuf->_refCount) == 0)))
        {
            if (_sbuf->_isLazy == 0)
                delete [] static_cast<UINT8 *>(_sbuf->_buf);
            delete _sbuf;
        }
    }

private:
    static const UINT32 EXCLUSIVE = UINT32(0x7fffffff);

    
    
    struct SHARED_BUF
    {
        
        
        SHARED_BUF(size_t sz) : _refCount(1), _isLazy(0), _size(sz), _buf(new UINT8[_size]) {}

        
        
        SHARED_BUF(const void *buf, size_t sz) : _refCount(1), _isLazy(1), _size(sz), _buf(const_cast<void *>(buf)) {}


        UINT32 _refCount:31;  
        UINT32 _isLazy:1;     
        size_t _size;               

        
        
        
        void *_buf;
    };

    SHARED_BUF *_sbuf;
    void *_start;       
    size_t _size;       
};

} 
#line 624 "c:\\pin35\\extras\\components\\include\\util/data.hpp"
#line 46 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/intel-fp.hpp"






































































































































































































































































#line 47 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/locker.hpp"




































namespace UTIL {







template<class LOCK> class  LOCKER
{
public:
    



    LOCKER(LOCK *lock, bool acquire = true) : _lock(lock), _isLocked(acquire)
    {
        if (acquire)
            _lock->Lock();
    }

    


    ~LOCKER()
    {
        if (_isLocked)
            _lock->Unlock();
    }

    


    void Unlock()
    {
        _lock->Unlock();
        _isLocked = false;
    }

    



    void Lock()
    {
        _lock->Lock();
        _isLocked = true;
    }

    




    void SetLocked(bool isLocked)
    {
        _isLocked = isLocked;
    }

private:
    LOCK *_lock;
    bool _isLocked;
};








template<class LOCK> class  RWLOCKER
{
public:
    enum LockType
    {
        READ,
        WRITE
    };

    



    RWLOCKER(LOCK *lock, LockType lock_type, bool acquire = true) : _lock(lock)
    {
        if (acquire)
        {
            Lock(lock_type);
        }
    }

    


    ~RWLOCKER()
    {
        Unlock();
    }

    


    void Unlock()
    {
        if (_isLocked)
        {
            if (0 != _lock)
            {
                _lock->Unlock();
            }
            _isLocked = false;
        }
    }

    



    void Lock(LockType lock_type)
    {
        if  (0 != _lock)
        {
            switch (lock_type)
            {
            case RWLOCKER::READ:  _lock->ReadLock();     break;
            case RWLOCKER::WRITE: _lock->WriteLock();    break;
            }
        }
        _isLocked = true;
    }

private:
    LOCK *_lock;
    bool _isLocked;
};
















































































template <typename CSTYPE> class  SCOPED_CRITICAL_SECTION
{
public:
    



    SCOPED_CRITICAL_SECTION(CSTYPE *cs, bool acquire = true) : _cs(cs), _isLocked(acquire)
    {
        if (acquire)
            EnterCriticalSection(cs);
    }

    


    ~SCOPED_CRITICAL_SECTION()
    {
        if (_isLocked)
            LeaveCriticalSection(_cs);
    }

    


    void Unlock()
    {
        LeaveCriticalSection(_cs);
        _isLocked = false;
    }

    



    void Lock()
    {
        EnterCriticalSection(_cs);
        _isLocked = true;
    }

    




    void SetLocked(bool isLocked)
    {
        _isLocked = isLocked;
    }

private:
    CSTYPE *_cs;
    bool _isLocked;
};

} 
#line 311 "c:\\pin35\\extras\\components\\include\\util/locker.hpp"
#line 48 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/numberbits.hpp"





































namespace UTIL {




















template<UINT32 num> struct  NUMBER_BITS
{
    static const UINT32 count = 
        ((num ? 1 : 0) +
        ((num>>1) ? 1 : 0) +
        ((num>>2) ? 1 : 0) +
        ((num>>3) ? 1 : 0) +
        ((num>>4) ? 1 : 0) +
        ((num>>5) ? 1 : 0) +
        ((num>>6) ? 1 : 0) +
        ((num>>7) ? 1 : 0) +
        ((num>>8) ? 1 : 0) +
        ((num>>9) ? 1 : 0) +
        ((num>>10) ? 1 : 0) +
        ((num>>11) ? 1 : 0) +
        ((num>>12) ? 1 : 0) +
        ((num>>13) ? 1 : 0) +
        ((num>>14) ? 1 : 0) +
        ((num>>15) ? 1 : 0) +
        ((num>>16) ? 1 : 0) +
        ((num>>17) ? 1 : 0) +
        ((num>>18) ? 1 : 0) +
        ((num>>19) ? 1 : 0) +
        ((num>>20) ? 1 : 0) +
        ((num>>21) ? 1 : 0) +
        ((num>>22) ? 1 : 0) +
        ((num>>23) ? 1 : 0) +
        ((num>>24) ? 1 : 0) +
        ((num>>25) ? 1 : 0) +
        ((num>>26) ? 1 : 0) +
        ((num>>27) ? 1 : 0) +
        ((num>>28) ? 1 : 0) +
        ((num>>29) ? 1 : 0) +
        ((num>>30) ? 1 : 0) +
        ((num>>31) ? 1 : 0));
};

} 
#line 98 "c:\\pin35\\extras\\components\\include\\util/numberbits.hpp"
#line 49 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/quote-argument-ms.hpp"





































namespace UTIL {




template <typename T> class  QUOTE_ARGUMENT_MS_BASE
{
private:
    typedef std::basic_string<T> STRING;
    STRING _quoted;

protected:
    



    QUOTE_ARGUMENT_MS_BASE(const STRING &arg, const T *whitespace)
    {
        
        
        _quoted = arg;
        if (_quoted.find_first_of(whitespace) != STRING::npos ||
            _quoted.find_first_of('"') != STRING::npos)
        {
            EscapeBackSlashes();
            EscapeQuotes();
            AddQuotes(whitespace);
        }
    }

    


    STRING Get()   {return _quoted;}

private:
    








    void EscapeBackSlashes()
    {
        size_t quote = _quoted.find_first_of('"', 1);
        while (quote != STRING::npos)
        {
            size_t numSlashes = 0;
            size_t notSlash = _quoted.find_last_not_of('\\', quote-1);
            if (notSlash != quote-1)
            {
                if (notSlash == STRING::npos)
                    numSlashes = quote;
                else
                    numSlashes = quote - notSlash - 1;
                _quoted.insert(quote, numSlashes, '\\');
            }
            quote = _quoted.find_first_of('"', quote + numSlashes + 1);
        }
    }

    


    void EscapeQuotes()
    {
        size_t quote = _quoted.find_first_of('"');
        while (quote != STRING::npos)
        {
            _quoted.insert(quote, 1, '\\');
            quote = _quoted.find_first_of('"', quote + 2);
        }
    }

    


    void AddQuotes(const T *whitespace)
    {
        if (_quoted.find_first_of(whitespace) != STRING::npos)
        {
            _quoted.insert((size_t)0, (size_t)1, '"');
            _quoted.append(1, '"');

            
            
            
            size_t quote = _quoted.size() - 1;
            if (_quoted[quote-1] == '\\')
            {
                size_t notSlash = _quoted.find_last_not_of('\\', quote-2);
                size_t numSlashes = quote - notSlash - 1;
                _quoted.insert(quote, numSlashes, '\\');
            }
        }
    }
};







class  QUOTE_ARGUMENT_MS : private QUOTE_ARGUMENT_MS_BASE<char>
{
public:
    



    QUOTE_ARGUMENT_MS(std::string str, const char *ws = " \t") : QUOTE_ARGUMENT_MS_BASE<char>(str, ws) {}

    


    std::string Get() {return QUOTE_ARGUMENT_MS_BASE<char>::Get();}
};






class  QUOTE_ARGUMENT_MS_WIDE : private QUOTE_ARGUMENT_MS_BASE<wchar_t>
{
public:
    



    QUOTE_ARGUMENT_MS_WIDE(std::wstring str, const wchar_t *ws = L" \t") : QUOTE_ARGUMENT_MS_BASE<wchar_t>(str, ws) {}

    


    std::wstring Get() {return QUOTE_ARGUMENT_MS_BASE<wchar_t>::Get();}
};

} 
#line 182 "c:\\pin35\\extras\\components\\include\\util/quote-argument-ms.hpp"
#line 50 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/range.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\util/round.hpp"






































namespace UTIL {









template<typename T> T RoundDown(T val, size_t align)
{
    size_t mod = val % align;
    val -= mod;
    return val;
}









template<typename T> T RoundUp(T val, size_t align)
{
    size_t mod = val % align;
    if (mod)
        val += (align - mod);
    return val;
}









template<typename T> T *RoundDown(T *ptr, size_t align)
{
    PTRINT val = reinterpret_cast<PTRINT>(ptr);
    size_t mod = val % align;
    val -= mod;
    return reinterpret_cast<T*>(val);
}









template<typename T> T *RoundUp(T *ptr, size_t align)
{
    PTRINT val = reinterpret_cast<PTRINT>(ptr);
    size_t mod = val % align;
    if (mod)
        val += (align - mod);
    return reinterpret_cast<T*>(val);
}









inline size_t PtrDiff(const void* ptr1, const void* ptr2)
{
    return static_cast<const INT8 *>(ptr1) - static_cast<const INT8 *>(ptr2);
}









inline void *PtrAtOffset(void *ptr, size_t offset)
{
    return static_cast<INT8 *>(ptr) + offset;
}









inline const void *PtrAtOffset(const void* ptr, size_t offset)
{
    return static_cast<const INT8 *>(ptr) + offset;
}




template <typename T> T * PtrAtOffset(void * ptr, size_t offset)
{
    return static_cast<T *>(PtrAtOffset(ptr, offset));
}




template <typename T> const T * PtrAtOffset(const void * ptr, size_t offset)
{
    return static_cast<const T *>(PtrAtOffset(ptr, offset));
}


} 
#line 163 "c:\\pin35\\extras\\components\\include\\util/round.hpp"
#line 38 "c:\\pin35\\extras\\components\\include\\util/range.hpp"


namespace UTIL {




template<typename ADDRTYPE> class  RANGE
{
public:
    RANGE() : _base(0), _size(0) {}     

    





    RANGE(ADDRTYPE base, size_t size) : _base(base), _size(size) {}

    





    RANGE(void *base, size_t size) : _base(reinterpret_cast<PTRINT>(base)), _size(size) {}

    





    void Assign(ADDRTYPE base, size_t size)
    {
        _base = base;
        _size = size;
    }

    





    void Assign(void *base, size_t size)
    {
        _base = reinterpret_cast<PTRINT>(base);
        _size = size;
    }

    ADDRTYPE GetBase() const    { return _base; }           
    size_t GetSize() const      { return _size; }           
    ADDRTYPE GetEnd() const     { return _base + _size; }   
    void Clear()                { _base = 0;  _size = 0; }  

    





    void AlignEndpoints(size_t alignment)
    {
        ADDRTYPE end = RoundUp(GetEnd(), alignment);
        _base = RoundDown(_base, alignment);
        _size = end - _base;
    }

    






    bool Contains(ADDRTYPE addr) const
    {
        return ((addr - _base) < _size);
    }

    






    bool Contains(const RANGE &range) const
    {
        return (Contains(range.m_base) && !range.Contains(GetEnd()));
    }

private:
    ADDRTYPE _base;
    size_t _size;
};

typedef RANGE<ADDRINT> ARANGE;    
typedef RANGE<ANYADDR> ANYRANGE;  
typedef RANGE<PTRINT> PRANGE;     

} 
#line 143 "c:\\pin35\\extras\\components\\include\\util/range.hpp"
#line 51 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/regvalue.hpp"






































#line 1 "C:\\Pin35\\extras\\stlport\\include\\string.h"

























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 31 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\string.h"






#line 42 "C:\\Pin35\\extras\\stlport\\include\\string.h"






#line 49 "C:\\Pin35\\extras\\stlport\\include\\string.h"


#line 52 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/string.h"








































































































































































































































































































































#line 53 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 54 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 55 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 56 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 60 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 64 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 65 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 66 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 67 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 40 "c:\\pin35\\extras\\components\\include\\util/regvalue.hpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\algorithm"





























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 





#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 31 "C:\\Pin35\\extras\\stlport\\include\\algorithm"

#line 33 "C:\\Pin35\\extras\\stlport\\include\\algorithm"








#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"





































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_heap.h"
































namespace std {



template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);


template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp);

template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val);

template <class _RandomAccessIterator, class _Tp, class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _RandomAccessIterator __result, _Tp __val, _Distance*)
{
  *__result = *__first;
  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __val);
}

template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
        _RandomAccessIterator __last);

template <class _RandomAccessIterator, class _Distance,
          class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val, _Compare __comp);

template <class _RandomAccessIterator, class _Tp, class _Compare,
          class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _RandomAccessIterator __result, _Tp __val, _Compare __comp,
           _Distance*)
{
  *__result = *__first;
  __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                __val, __comp);
}

template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
         _RandomAccessIterator __last, _Compare __comp);

template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);

template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp);

template <class _RandomAccessIterator>
inline
void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  while (__last - __first > 1)
    pop_heap(__first, __last--);
}

template <class _RandomAccessIterator, class _Compare>
inline
void
sort_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
{
  while (__last - __first > 1)
    pop_heap(__first, __last--, __comp);
}

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_heap.c"




































namespace std {

template <class _RandomAccessIterator, class _Distance, class _Tp>
inline
void
__push_heap(_RandomAccessIterator __first,
            _Distance __holeIndex, _Distance __topIndex, _Tp __val)
{
  _Distance __parent = (__holeIndex - 1) / 2;
  while (__holeIndex > __topIndex && *(__first + __parent) < __val) {
    *(__first + __holeIndex) = *(__first + __parent);
    __holeIndex = __parent;
    __parent = (__holeIndex - 1) / 2;
  }
  *(__first + __holeIndex) = __val;
}

template <class _RandomAccessIterator, class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
                _RandomAccessIterator __last, _Distance*, _Tp*)
{
  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
              _Tp(*(__last - 1)));
}

template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  __push_heap_aux(__first, __last,
                  (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0);
}


template <class _RandomAccessIterator, class _Distance, class _Tp,
          class _Compare>
inline
void
__push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
            _Distance __topIndex, _Tp __val, _Compare __comp)
{
  _Distance __parent = (__holeIndex - 1) / 2;
  while (__holeIndex > __topIndex && __comp(*(__first + __parent), __val)) {
    
    *(__first + __holeIndex) = *(__first + __parent);
    __holeIndex = __parent;
    __parent = (__holeIndex - 1) / 2;
  }
  *(__first + __holeIndex) = __val;
}

template <class _RandomAccessIterator, class _Compare,
          class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
                _RandomAccessIterator __last, _Compare __comp,
                _Distance*, _Tp*)
{
  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
              _Tp(*(__last - 1)), __comp);
}

template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp)
{
  __push_heap_aux(__first, __last, __comp,
                  (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0);
}

template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val) {
  _Distance __topIndex = __holeIndex;
  _Distance __secondChild = 2 * __holeIndex + 2;
  while (__secondChild < __len) {
    if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
      __secondChild--;
    *(__first + __holeIndex) = *(__first + __secondChild);
    __holeIndex = __secondChild;
    __secondChild = 2 * (__secondChild + 1);
  }
  if (__secondChild == __len) {
    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
    __holeIndex = __secondChild - 1;
  }
  __push_heap(__first, __holeIndex, __topIndex, __val);
}


template <class _RandomAccessIterator, class _Tp>
inline void
__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*) {
  __pop_heap(__first, __last - 1, __last - 1,
             _Tp(*(__last - 1)), (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
        _RandomAccessIterator __last) {
  __pop_heap_aux(__first, __last, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0);
}

template <class _RandomAccessIterator, class _Distance,
          class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val, _Compare __comp)
{
  _Distance __topIndex = __holeIndex;
  _Distance __secondChild = 2 * __holeIndex + 2;
  while (__secondChild < __len) {
    if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1)))) {
      
#line 155 "C:\\Pin35\\extras\\stlport\\include\\stl/_heap.c"
      __secondChild--;
    }
    *(__first + __holeIndex) = *(__first + __secondChild);
    __holeIndex = __secondChild;
    __secondChild = 2 * (__secondChild + 1);
  }
  if (__secondChild == __len) {
    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
    __holeIndex = __secondChild - 1;
  }
  __push_heap(__first, __holeIndex, __topIndex, __val, __comp);
}


template <class _RandomAccessIterator, class _Tp, class _Compare>
inline void
__pop_heap_aux(_RandomAccessIterator __first,
               _RandomAccessIterator __last, _Tp*, _Compare __comp)
{
  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __comp,
             (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}


template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
         _RandomAccessIterator __last, _Compare __comp)
{
    __pop_heap_aux(__first, __last, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0, __comp);
}

template <class _RandomAccessIterator, class _Tp, class _Distance>
inline
void
__make_heap(_RandomAccessIterator __first,
            _RandomAccessIterator __last, _Tp*, _Distance*)
{
  if (__last - __first < 2) return;
  _Distance __len = __last - __first;
  _Distance __parent = (__len - 2)/2;

  for (;;) {
    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));
    if (__parent == 0) return;
    __parent--;
  }
}

template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  __make_heap(__first, __last,
              (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

template <class _RandomAccessIterator, class _Compare,
          class _Tp, class _Distance>
inline
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
            _Compare __comp, _Tp*, _Distance*)
{
  if (__last - __first < 2) return;
  _Distance __len = __last - __first;
  _Distance __parent = (__len - 2)/2;

  for (;;) {
    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)),
                  __comp);
    if (__parent == 0) return;
    __parent--;
  }
}

template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
{
  __make_heap(__first, __last, __comp,
              (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

}

#line 243 "C:\\Pin35\\extras\\stlport\\include\\stl/_heap.c"




#line 119 "C:\\Pin35\\extras\\stlport\\include\\stl/_heap.h"
#line 120 "C:\\Pin35\\extras\\stlport\\include\\stl/_heap.h"

#line 122 "C:\\Pin35\\extras\\stlport\\include\\stl/_heap.h"




#line 39 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"
#line 40 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"












#line 53 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"

namespace std {


template <class _InputIter, class _Function>
inline _Function
for_each(_InputIter __first, _InputIter __last, _Function __f) {
  for ( ; __first != __last; ++__first)
    __f(*__first);
  return __f;
}


template <class _InputIter, class _Predicate>
inline typename iterator_traits<_InputIter>::difference_type
count_if(_InputIter __first, _InputIter __last, _Predicate __pred) {
  
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first) {
    if (__pred(*__first))
      ++__n;
  }
  return __n;
}



template <class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last,
              _BinaryPredicate __binary_pred) {
  
  if (__first == __last)
    return __last;
  _ForwardIter __next = __first;
  while(++__next != __last) {
    if (__binary_pred(*__first, *__next))
      return __first;
    __first = __next;
  }
  return __last;
}

template <class _ForwardIter>
inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last) {
  return adjacent_find(__first, __last,
                       ::std::priv:: __equal_to((typename ::std::iterator_traits< _ForwardIter >::value_type*)0));
}


template <class _InputIter, class _Tp, class _Size>
inline void
count(_InputIter __first, _InputIter __last, const _Tp& __val, _Size& __n) {
  
    for ( ; __first != __last; ++__first)
      if (*__first == __val)
        ++__n;
}

template <class _InputIter, class _Predicate, class _Size>
inline void
count_if(_InputIter __first, _InputIter __last, _Predicate __pred, _Size& __n) {
  
  for ( ; __first != __last; ++__first)
    if (__pred(*__first))
      ++__n;
}
#line 122 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2);


template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val);
template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val, _BinaryPred __binary_pred);

template <class _InputIter, class _ForwardIter>
inline _InputIter find_first_of(_InputIter __first1, _InputIter __last1,
                                _ForwardIter __first2, _ForwardIter __last2) {
  
  
  return ::std::priv:: __find_first_of(__first1, __last1, __first2, __last2);
}

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
inline _InputIter
find_first_of(_InputIter __first1, _InputIter __last1,
              _ForwardIter __first2, _ForwardIter __last2, _BinaryPredicate __comp) {
  
  
  return ::std::priv:: __find_first_of(__first1, __last1, __first2, __last2, __comp);
}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2);


template <class _ForwardIter1, class _ForwardIter2>
inline _ForwardIter2
swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2) {
  
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    iter_swap(__first1, __first2);
  return __first2;
}


template <class _InputIter, class _OutputIter, class _UnaryOperation>
inline _OutputIter
transform(_InputIter __first, _InputIter __last, _OutputIter __result, _UnaryOperation __opr) {
  
  for ( ; __first != __last; ++__first, ++__result)
    *__result = __opr(*__first);
  return __result;
}
template <class _InputIter1, class _InputIter2, class _OutputIter, class _BinaryOperation>
inline _OutputIter
transform(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _OutputIter __result,_BinaryOperation __binary_op) {
  
  for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
    *__result = __binary_op(*__first1, *__first2);
  return __result;
}



template <class _ForwardIter, class _Predicate, class _Tp>
inline void
replace_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred, const _Tp& __new_value) {
  
  for ( ; __first != __last; ++__first)
    if (__pred(*__first))
      *__first = __new_value;
}

template <class _InputIter, class _OutputIter, class _Tp>
inline  _OutputIter
replace_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
             const _Tp& __old_value, const _Tp& __new_value) {
  
  for ( ; __first != __last; ++__first, ++__result)
    *__result = *__first == __old_value ? __new_value : *__first;
  return __result;
}

template <class _Iterator, class _OutputIter, class _Predicate, class _Tp>
inline _OutputIter
replace_copy_if(_Iterator __first, _Iterator __last,
                _OutputIter __result,
                _Predicate __pred, const _Tp& __new_value) {
  
  for ( ; __first != __last; ++__first, ++__result)
    *__result = __pred(*__first) ? __new_value : *__first;
  return __result;
}



template <class _ForwardIter, class _Generator>
inline void
generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen) {
  
  for ( ; __first != __last; ++__first)
    *__first = __gen();
}

template <class _OutputIter, class _Size, class _Generator>
inline void
generate_n(_OutputIter __first, _Size __n, _Generator __gen) {
  for ( ; __n > 0; --__n, ++__first)
    *__first = __gen();
}



template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter
remove_copy(_InputIter __first, _InputIter __last,_OutputIter __result, const _Tp& __val) {
  
  for ( ; __first != __last; ++__first) {
    if (!(*__first == __val)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIter, class _OutputIter, class _Predicate>
inline _OutputIter
remove_copy_if(_InputIter __first, _InputIter __last, _OutputIter __result, _Predicate __pred) {
  
  for ( ; __first != __last; ++__first) {
    if (!__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _ForwardIter, class _Tp>
inline _ForwardIter
remove(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
  
  __first = find(__first, __last, __val);
  if (__first == __last)
    return __first;
  else {
    _ForwardIter __next = __first;
    return remove_copy(++__next, __last, __first, __val);
  }
}

template <class _ForwardIter, class _Predicate>
inline _ForwardIter
remove_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
  
  __first = find_if(__first, __last, __pred);
  if ( __first == __last )
    return __first;
  else {
    _ForwardIter __next = __first;
    return remove_copy_if(++__next, __last, __first, __pred);
  }
}


template <class _InputIter, class _OutputIter>
_OutputIter unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result);

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
                        _BinaryPredicate __binary_pred);

template <class _ForwardIter>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last) {
  __first = adjacent_find(__first, __last);
  return unique_copy(__first, __last, __first);
}

template <class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last,
                           _BinaryPredicate __binary_pred) {
  __first = adjacent_find(__first, __last, __binary_pred);
  return unique_copy(__first, __last, __first, __binary_pred);
}



namespace priv {

template <class _BidirectionalIter>
inline void
__reverse(_BidirectionalIter __first, _BidirectionalIter __last, const bidirectional_iterator_tag &) {
  for (; __first != __last && __first != --__last; ++__first)
    ::std::iter_swap(__first,__last);
}

template <class _RandomAccessIter>
inline void
__reverse(_RandomAccessIter __first, _RandomAccessIter __last, const random_access_iterator_tag &) {
  for (; __first < __last; ++__first)
    ::std::iter_swap(__first, --__last);
}

}

template <class _BidirectionalIter>
inline void
reverse(_BidirectionalIter __first, _BidirectionalIter __last) {
  
  ::std::priv:: __reverse(__first, __last, typename ::std::iterator_traits< _BidirectionalIter >::iterator_category());
}

template <class _BidirectionalIter, class _OutputIter>
inline
_OutputIter reverse_copy(_BidirectionalIter __first,
                         _BidirectionalIter __last,
                         _OutputIter __result) {
  
  while (__first != __last) {
    --__last;
    *__result = *__last;
    ++__result;
  }
  return __result;
}

template <class _ForwardIter>
void rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last);

template <class _ForwardIter, class _OutputIter>
inline _OutputIter rotate_copy(_ForwardIter __first, _ForwardIter __middle,
                               _ForwardIter __last, _OutputIter __result) {
  return ::std::copy(__first, __middle, copy(__middle, __last, __result));
}



template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last);

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                    _RandomNumberGenerator& __rand);




template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n);

template <class _ForwardIter, class _OutputIter, class _Distance,
          class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n,
                            _RandomNumberGenerator& __rand);

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last);

template <class _InputIter, class _RandomAccessIter,
          class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last,
              _RandomNumberGenerator& __rand);

#line 395 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"



template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate   __pred);

template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred);


namespace priv {

template <class _Size>
inline _Size __lg(_Size __n) {
  _Size __k;
  for (__k = 0; __n != 1; __n >>= 1) ++__k;
  return __k;
}

}

template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last);
template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp);


template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last, _Compare __comp);



template <class _RandomAccessIter>
void partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
                  _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
                  _RandomAccessIter __last, _Compare __comp);

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first, _RandomAccessIter __result_last);

template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first,
                  _RandomAccessIter __result_last, _Compare __comp);


template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last, _Compare __comp);


namespace priv {

template <class _T1, class _T2>
struct __less_2 {
  bool operator() (const _T1& __x, const _T2& __y) const { return __x < __y ; }
};

template <class _T1, class _T2>
__less_2<_T1,_T2> __less2(_T1*, _T2* ) { return __less_2<_T1, _T2>(); }




#line 476 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"

}


template <class _ForwardIter, class _Tp>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
                                   const _Tp& __val) {
  
  return ::std::priv:: __lower_bound(__first, __last, __val,
                                  ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                  ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val, _Compare __comp) {
  
  return ::std::priv:: __lower_bound(__first, __last, __val, __comp, __comp,
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                           _Compare1 __comp1, _Compare2 __comp2, _Distance*);

}

template <class _ForwardIter, class _Tp>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val) {
  
  return ::std::priv:: __upper_bound(__first, __last, __val,
                                  ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                  ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val, _Compare __comp) {
  
  return ::std::priv:: __upper_bound(__first, __last, __val, __comp, __comp,
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
              _Compare1 __comp1, _Compare2 __comp2, _Distance*);

}

template <class _ForwardIter, class _Tp>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
  
  return ::std::priv:: __equal_range(__first, __last, __val,
                                  ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                  ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
            _Compare __comp) {
  
  return ::std::priv:: __equal_range(__first, __last, __val, __comp, __comp,
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
                   const _Tp& __val) {
  
  _ForwardIter __i = ::std::priv:: __lower_bound(__first, __last, __val,
                                              ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                              ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                              (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
  return __i != __last && !(__val < *__i);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
                          const _Tp& __val,
                          _Compare __comp) {
  
  _ForwardIter __i = ::std::priv:: __lower_bound(__first, __last, __val, __comp, __comp,
                                              (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
  return __i != __last && !__comp(__val, *__i);
}



template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result, _Compare __comp);





template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last) ;

template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last, _Compare __comp);






template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp);



template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result);


template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result,
                         _Compare __comp);





template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last);
template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp);

template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last);

template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp);




template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last);

template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp);


template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last);


template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp);






template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last);

template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
             _StrictWeakOrdering __comp);




namespace priv {

template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
                 _StrictWeakOrdering __comp);

}
template <class _ForwardIter>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last) {
  return ::std::priv:: __is_sorted(__first, __last,
                                ::std::priv:: __less((typename ::std::iterator_traits< _ForwardIter >::value_type*)0));
}

template <class _ForwardIter, class _StrictWeakOrdering>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last,
                      _StrictWeakOrdering __comp) {
  return ::std::priv:: __is_sorted(__first, __last, __comp);
}
#line 733 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"






























#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"












































namespace std {

template <class _Tp>
pair<_Tp*, ptrdiff_t>  __cdecl
__get_temporary_buffer(ptrdiff_t __len, _Tp*);



template <class _Tp>
inline pair<_Tp*, ptrdiff_t>  __cdecl get_temporary_buffer(ptrdiff_t __len) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}







template <class _Tp>
inline pair<_Tp*, ptrdiff_t>  __cdecl
get_temporary_buffer(ptrdiff_t __len, _Tp*) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}
#line 70 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"
#line 71 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"

template <class _Tp>
inline void  __cdecl return_temporary_buffer(_Tp* __p) {

  free((char*)__p);
}

template <class _ForwardIterator, class _Tp>
class _Temporary_buffer {
private:
  ptrdiff_t  _M_original_len;
  ptrdiff_t  _M_len;
  _Tp*       _M_buffer;

  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(0x7fffffff / sizeof(_Tp)))
      _M_len = 0x7fffffff / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, const __true_type&) {}
  void _M_initialize_buffer(const _Tp& val, const __false_type&) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:
  ptrdiff_t size() const { return _M_len; }
  ptrdiff_t requested_size() const { return _M_original_len; }
  _Tp* begin() { return _M_buffer; }
  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {
    


#line 116 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"
    typedef typename __type_traits<_Tp>::has_trivial_default_constructor  _Trivial;
#line 118 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"
     {
      _M_len = ::std::distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    
  }

  ~_Temporary_buffer() {
    ::std::_Destroy_Range(_M_buffer, _M_buffer + _M_len);
    ::free(_M_buffer);
  }

private:
  
  _Temporary_buffer(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
  void operator=(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
};





template <class _ForwardIterator,
          class _Tp

                    = typename iterator_traits<_ForwardIterator>::value_type
#line 147 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"
         >
struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
{
  temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
  ~temporary_buffer() {}
};

#line 156 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.c"
































namespace std {

template <class _Tp>
pair<_Tp*, ptrdiff_t> __cdecl
__get_temporary_buffer(ptrdiff_t __len, _Tp*)
{
  if (__len > ptrdiff_t(0x7fffffff / sizeof(_Tp)))
    __len = 0x7fffffff / sizeof(_Tp);

  while (__len > 0) {
    _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
    if (__tmp != 0)
      return pair<_Tp*, ptrdiff_t>(__tmp, __len);
    __len /= 2;
  }

  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
}
}

#line 54 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.c"




#line 161 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"
#line 162 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"

#line 164 "C:\\Pin35\\extras\\stlport\\include\\stl/_tempbuf.h"




#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"

namespace std {

namespace priv {

template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
                            _BidirectionalIter __middle,
                            _BidirectionalIter __last,
                            _Distance __len1, _Distance __len2,
                            _Compare __comp);


template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
                                     _BidirectionalIter1 __last1,
                                     _BidirectionalIter2 __first2,
                                     _BidirectionalIter2 __last2,
                                     _BidirectionalIter3 __result,
                                     _Compare __comp);

template <class _Tp>

inline
#line 62 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"
const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c) {
  if (__a < __b)
    if (__b < __c)
      return __b;
    else if (__a < __c)
      return __c;
    else
      return __a;
  else if (__a < __c)
    return __a;
  else if (__b < __c)
    return __c;
  else
    return __b;
}

template <class _Tp, class _Compare>

inline
#line 82 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"
const _Tp&
__median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp) {
  if (__comp(__a, __b)) {
    
    if (__comp(__b, __c)) {
      
      return __b;
    }
    else if (__comp(__a, __c)) {
      
      return __c;
    }
    else
      return __a;
  }
  else if (__comp(__a, __c)) {
    
    return __a;
  }
  else if (__comp(__b, __c)) {
    
    return __c;
  }
  else
    return __b;
}

}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2) {
  
  
  
  if (__first1 == __last1 || __first2 == __last2)
    return __first1;

  
  _ForwardIter2 __p1(__first2);

  if ( ++__p1 == __last2 )
    return find(__first1, __last1, *__first2);

  

  for ( ; ; ) { 
    __first1 = find(__first1, __last1, *__first2);
    if (__first1 == __last1)
      return __last1;

    _ForwardIter2 __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1)
      return __last1;

    while (*__current == *__p) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}

namespace priv {

template <class _RandomAccessIter, class _Integer, class _Tp,
          class _BinaryPred, class _Distance>
_RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Integer __count, const _Tp& __val, _BinaryPred __pred,
                             _Distance*, const random_access_iterator_tag &)
{
  _Distance __tailSize = __last - __first;
  const _Distance __pattSize = __count;
  const _Distance __skipOffset = __pattSize - 1;
  _RandomAccessIter __backTrack;
  _Distance __remainder, __prevRemainder;

  for ( _RandomAccessIter __lookAhead = __first + __skipOffset; __tailSize >= __pattSize; __lookAhead += __pattSize ) { 
    
    __tailSize -= __pattSize;

    while ( !__pred(*__lookAhead, __val) ) { 
      if (__tailSize < __pattSize)
        return __last;

      __lookAhead += __pattSize;
      __tailSize -= __pattSize;
    }

    if ( __skipOffset == 0 ) {
      return (__lookAhead - __skipOffset); 
    }

    __remainder = __skipOffset;

    for (__backTrack = __lookAhead; __pred(*--__backTrack, __val); ) {
      if (--__remainder == 0)
        return (__lookAhead - __skipOffset); 
    }

    if (__remainder > __tailSize)
      return __last; 

    __lookAhead += __remainder;
    __tailSize -= __remainder;

    while ( __pred(*__lookAhead, __val) ) {
      __prevRemainder = __remainder;
      __backTrack = __lookAhead;

      do {
        if (--__remainder == 0)
          return (__lookAhead - __skipOffset); 
      } while (__pred(*--__backTrack, __val));

      
      __remainder += __pattSize - __prevRemainder;

      if (__remainder > __tailSize)
        return __last; 

      __lookAhead += __remainder;
      __tailSize -= __remainder;
    }

    
  }

  return __last; 
}

template <class _ForwardIter, class _Integer, class _Tp,
          class _Distance, class _BinaryPred>
_ForwardIter __search_n(_ForwardIter __first, _ForwardIter __last,
                        _Integer __count, const _Tp& __val, _BinaryPred __pred,
                        _Distance*, const forward_iterator_tag &) {
  for (; (__first != __last) && !__pred(*__first, __val); ++__first) {}
  while (__first != __last) {
    _Integer __n = __count - 1;
    _ForwardIter __i = __first;
    ++__i;
    while (__i != __last && __n != 0 && __pred(*__i, __val)) {
      ++__i;
      --__n;
    }
    if (__n == 0)
      return __first;
    else if (__i != __last)
      for (__first = ++__i; (__first != __last) && !__pred(*__first, __val); ++__first) {}
    else
      break;
  }
  return __last;
}

}


template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val) {
  
  if (__count <= 0)
    return __first;
  if (__count == 1)
    
    return find(__first, __last, __val);
  return ::std::priv:: __search_n(__first, __last, __count, __val, equal_to<_Tp>(),
                               (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0,
                               typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val,
                      _BinaryPred __binary_pred) {
  
  if (__count <= 0)
    return __first;
  return ::std::priv:: __search_n(__first, __last, __count, __val, __binary_pred,
                               (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0,
                               typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2) {
  
  
  return ::std::priv:: __find_end(__first1, __last1, __first2, __last2,

                               typename ::std::iterator_traits< _ForwardIter1 >::iterator_category(),
                               typename ::std::iterator_traits< _ForwardIter2 >::iterator_category(),



#line 285 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"
                               ::std::priv:: __equal_to((typename ::std::iterator_traits< _ForwardIter1 >::value_type*)0)
    );
}


namespace priv {

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate,
          class _Tp>
inline _OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last,
              _OutputIterator __result,
              _BinaryPredicate __binary_pred, _Tp*) {
  _Tp __val = *__first;
  *__result = __val;
  while (++__first != __last)
    if (!__binary_pred(__val, *__first)) {
      __val = *__first;
      *++__result = __val;
    }
  return ++__result;
}

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
inline _OutputIter
__unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
              _BinaryPredicate __binary_pred, const output_iterator_tag &) {
  return ::std::priv:: __unique_copy(__first, __last, __result, __binary_pred,
                                  (typename ::std::iterator_traits< _InputIter >::value_type*)0);
}

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter
__unique_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
              _BinaryPredicate __binary_pred, const forward_iterator_tag &) {
  *__result = *__first;
  while (++__first != __last)
    if (!__binary_pred(*__result, *__first)) *++__result = *__first;
  return ++__result;
}

















#line 343 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"

}

template <class _InputIter, class _OutputIter>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
  
  if (__first == __last) return __result;
  return ::std::priv:: __unique_copy(__first, __last, __result,
                                  ::std::priv:: __equal_to((typename ::std::iterator_traits< _InputIter >::value_type*)0),
                                  typename ::std::iterator_traits< _OutputIter >::iterator_category());
}

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
            _BinaryPredicate __binary_pred) {
  
  if (__first == __last) return __result;
  return ::std::priv:: __unique_copy(__first, __last, __result, __binary_pred,
                                  typename ::std::iterator_traits< _OutputIter >::iterator_category());
}


namespace priv {

template <class _ForwardIter, class _Distance>
_ForwardIter __rotate_aux(_ForwardIter __first,
                          _ForwardIter __middle,
                          _ForwardIter __last,
                          _Distance*,
                          const forward_iterator_tag &) {
  if (__first == __middle)
    return __last;
  if (__last  == __middle)
    return __first;

  _ForwardIter __first2 = __middle;
  do {
    ::std::swap(*__first++, *__first2++);
    if (__first == __middle)
      __middle = __first2;
  } while (__first2 != __last);

  _ForwardIter __new_middle = __first;

  __first2 = __middle;

  while (__first2 != __last) {
    ::std::swap (*__first++, *__first2++);
    if (__first == __middle)
      __middle = __first2;
    else if (__first2 == __last)
      __first2 = __middle;
  }

  return __new_middle;
}

template <class _BidirectionalIter, class _Distance>
_BidirectionalIter __rotate_aux(_BidirectionalIter __first,
                                _BidirectionalIter __middle,
                                _BidirectionalIter __last,
                                _Distance*,
                                const bidirectional_iterator_tag &) {
  if (__first == __middle)
    return __last;
  if (__last  == __middle)
    return __first;

  ::std::priv:: __reverse(__first,  __middle, bidirectional_iterator_tag());
  ::std::priv:: __reverse(__middle, __last,   bidirectional_iterator_tag());

  while (__first != __middle && __middle != __last)
    ::std::swap(*__first++, *--__last);

  if (__first == __middle) {
    ::std::priv:: __reverse(__middle, __last,   bidirectional_iterator_tag());
    return __last;
  }
  else {
    ::std::priv:: __reverse(__first,  __middle, bidirectional_iterator_tag());
    return __first;
  }
}


template <class _EuclideanRingElement>
inline
_EuclideanRingElement __gcd(_EuclideanRingElement __m,
                            _EuclideanRingElement __n) {
  while (__n != 0) {
    _EuclideanRingElement __t = __m % __n;
    __m = __n;
    __n = __t;
  }
  return __m;
}

template <class _RandomAccessIter, class _Distance, class _Tp>
_RandomAccessIter __rotate_aux(_RandomAccessIter __first,
                               _RandomAccessIter __middle,
                               _RandomAccessIter __last,
                               _Distance *, _Tp *) {

  _Distance __n = __last   - __first;
  _Distance __k = __middle - __first;
  _Distance __l = __n - __k;
  _RandomAccessIter __result = __first + (__last - __middle);

  if (__k == 0)  
    return __last;

  if (__k == __l) {
    ::std::swap_ranges(__first, __middle, __middle);
    return __result;
  }

  _Distance __d = ::std::priv:: __gcd(__n, __k);

  for (_Distance __i = 0; __i < __d; __i++) {
    _Tp __tmp = *__first;
    _RandomAccessIter __p = __first;

    if (__k < __l) {
      for (_Distance __j = 0; __j < __l/__d; __j++) {
        if (__p > __first + __l) {
          *__p = *(__p - __l);
          __p -= __l;
        }

        *__p = *(__p + __k);
        __p += __k;
      }
    }

    else {
      for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
        if (__p < __last - __k) {
          *__p = *(__p + __k);
          __p += __k;
        }

        *__p = * (__p - __l);
        __p -= __l;
      }
    }

    *__p = __tmp;
    ++__first;
  }

  return __result;
}

template <class _RandomAccessIter, class _Distance>
inline _RandomAccessIter
__rotate_aux(_RandomAccessIter __first, _RandomAccessIter __middle, _RandomAccessIter __last,
             _Distance * __dis, const random_access_iterator_tag &) {
  return ::std::priv:: __rotate_aux(__first, __middle, __last,
                                 __dis, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0);
}

template <class _ForwardIter>
_ForwardIter
__rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last) {
  
  
  return __rotate_aux(__first, __middle, __last,
                      (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0,
                      typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

}

template <class _ForwardIter>
void rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last) {
  ::std::priv:: __rotate(__first, __middle, __last);
}




namespace priv {

template <class _Distance>
inline _Distance __random_number(_Distance __n) {

  return rand() % __n;


#line 535 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"
}

}

template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first,
                    _RandomAccessIter __last) {
  
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    iter_swap(__i, __first + ::std::priv:: __random_number((__i - __first) + 1));
}

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                    _RandomNumberGenerator &__rand) {
  
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    iter_swap(__i, __first + __rand((__i - __first) + 1));
}



template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n) {
  
  _Distance __remaining = ::std::distance(__first, __last);
  _Distance __m = (min) (__n, __remaining);

  while (__m > 0) {
    if (::std::priv:: __random_number(__remaining) < __m) {
      *__out_ite = *__first;
      ++__out_ite;
      --__m;
    }

    --__remaining;
    ++__first;
  }
  return __out_ite;
}


template <class _ForwardIter, class _OutputIter, class _Distance,
          class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n,
                            _RandomNumberGenerator& __rand) {
  
  _Distance __remaining = ::std::distance(__first, __last);
  _Distance __m = (min) (__n, __remaining);

  while (__m > 0) {
    if (__rand(__remaining) < __m) {
      *__out_ite = *__first;
      ++__out_ite;
      --__m;
    }

    --__remaining;
    ++__first;
  }
  return __out_ite;
}

namespace priv {

template <class _InputIter, class _RandomAccessIter, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
                                  _RandomAccessIter __out_ite,
                                  const _Distance __n) {
  _Distance __m = 0;
  _Distance __t = __n;
  for ( ; __first != __last && __m < __n; ++__m, ++__first)
    __out_ite[__m] = *__first;

  while (__first != __last) {
    ++__t;
    _Distance __M = __random_number(__t);
    if (__M < __n)
      __out_ite[__M] = *__first;
    ++__first;
  }

  return __out_ite + __m;
}

template <class _InputIter, class _RandomAccessIter,
          class _RandomNumberGenerator, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
                                  _RandomAccessIter __out_ite,
                                  _RandomNumberGenerator& __rand,
                                  const _Distance __n) {
  _Distance __m = 0;
  _Distance __t = __n;
  for ( ; __first != __last && __m < __n; ++__m, ++__first)
    __out_ite[__m] = *__first;

  while (__first != __last) {
    ++__t;
    _Distance __M = __rand(__t);
    if (__M < __n)
      __out_ite[__M] = *__first;
    ++__first;
  }

  return __out_ite + __m;
}

}

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last) {
  
  
  return ::std::priv:: __random_sample(__first, __last,
                                    __out_first, __out_last - __out_first);
}

template <class _InputIter, class _RandomAccessIter, class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last,
              _RandomNumberGenerator& __rand) {
  
  
  return ::std::priv:: __random_sample(__first, __last,
                                    __out_first, __rand,
                                    __out_last - __out_first);
}

#line 671 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"


namespace priv {

template <class _ForwardIter, class _Predicate>
inline _ForwardIter __partition(_ForwardIter __first,
                                           _ForwardIter __last,
                                           _Predicate   __pred,
                                           const forward_iterator_tag &) {
  if (__first == __last) return __first;

  while (__pred(*__first))
    if (++__first == __last) return __first;

  _ForwardIter __next = __first;

  while (++__next != __last) {
    if (__pred(*__next)) {
      ::std::swap(*__first, *__next);
      ++__first;
    }
  }
  return __first;
}

template <class _BidirectionalIter, class _Predicate>
inline _BidirectionalIter __partition(_BidirectionalIter __first,
                                                 _BidirectionalIter __last,
                                                 _Predicate __pred,
                                                 const bidirectional_iterator_tag &) {
  for (;;) {
    for (;;) {
      if (__first == __last)
        return __first;
      else if (__pred(*__first))
        ++__first;
      else
        break;
    }
    --__last;
    for (;;) {
      if (__first == __last)
        return __first;
      else if (!__pred(*__last))
        --__last;
      else
        break;
    }
    iter_swap(__first, __last);
    ++__first;
  }
}










#line 734 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"

}

template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate   __pred) {
  
  return ::std::priv:: __partition(__first, __last, __pred, typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}







namespace priv {

template <class _ForwardIter, class _Predicate, class _Distance>
_ForwardIter __inplace_stable_partition(_ForwardIter __first,
                                        _ForwardIter __last,
                                        _Predicate __pred, _Distance __len,
                                        bool __pred_of_first, bool __pred_of_before_last) {
  if (__len == 1)
    return (__pred_of_first && (__pred_of_before_last || __pred(*__first))) ? __last : __first;
  _ForwardIter __middle = __first;
  _Distance __half_len = __len / 2;
  ::std::advance(__middle, __half_len);
  return ::std::priv:: __rotate(::std::priv:: __inplace_stable_partition(__first, __middle, __pred, __half_len, __pred_of_first, false),
                             __middle,
                             ::std::priv:: __inplace_stable_partition(__middle, __last, __pred, __len - __half_len, true, __pred_of_before_last));
}

template <class _ForwardIter, class _Pointer, class _Predicate,
          class _Distance>
_ForwardIter __stable_partition_adaptive(_ForwardIter __first,
                                         _ForwardIter __last,
                                         _Predicate __pred, _Distance __len,
                                         _Pointer __buffer, _Distance __buffer_size,
                                         bool __pred_of_first, bool __pred_of_before_last) {
  if (__len <= __buffer_size) {
    _ForwardIter __result1 = __first;
    _Pointer __result2 = __buffer;
    if ((__first != __last) && (!__pred_of_first || __pred(*__first))) {
      *__result2 = *__first;
      ++__result2; ++__first; --__len;
    }
    for (; __first != __last ; ++__first, --__len) {
      if (((__len == 1) && (__pred_of_before_last || __pred(*__first))) ||
          ((__len != 1) && __pred(*__first))){
        *__result1 = *__first;
        ++__result1;
      }
      else {
        *__result2 = *__first;
        ++__result2;
      }
    }
    ::std::copy(__buffer, __result2, __result1);
    return __result1;
  }
  else {
    _ForwardIter __middle = __first;
    _Distance __half_len = __len / 2;
    ::std::advance(__middle, __half_len);
    return ::std::priv:: __rotate(::std::priv:: __stable_partition_adaptive(__first, __middle, __pred,
                                                                      __half_len, __buffer, __buffer_size,
                                                                      __pred_of_first, false),
                               __middle,
                               ::std::priv:: __stable_partition_adaptive(__middle, __last, __pred,
                                                                      __len - __half_len, __buffer, __buffer_size,
                                                                      true, __pred_of_before_last));
  }
}

template <class _ForwardIter, class _Predicate, class _Tp, class _Distance>
inline _ForwardIter
__stable_partition_aux_aux(_ForwardIter __first, _ForwardIter __last,
                           _Predicate __pred, _Tp*, _Distance*, bool __pred_of_before_last) {
  _Temporary_buffer<_ForwardIter, _Tp> __buf(__first, __last);
      
  return (__buf.size() > 0) ?
    __stable_partition_adaptive(__first, __last, __pred,
                                _Distance(__buf.requested_size()),
                                __buf.begin(), __buf.size(),
                                false, __pred_of_before_last)  :
    __inplace_stable_partition(__first, __last, __pred,
                               _Distance(__buf.requested_size()),
                               false, __pred_of_before_last);
    
}

template <class _ForwardIter, class _Predicate>
_ForwardIter
__stable_partition_aux(_ForwardIter __first, _ForwardIter __last, _Predicate __pred,
                       const forward_iterator_tag &) {
  return __stable_partition_aux_aux(__first, __last, __pred,
                                    (typename ::std::iterator_traits< _ForwardIter >::value_type*)0,
                                    (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0, false);
}

template <class _BidirectIter, class _Predicate>
_BidirectIter
__stable_partition_aux(_BidirectIter __first, _BidirectIter __last, _Predicate __pred,
                       const bidirectional_iterator_tag &) {
  for (--__last;;) {
    if (__first == __last)
      return __first;
    else if (!__pred(*__last))
      --__last;
    else
      break;
  }
  ++__last;
  
  return __stable_partition_aux_aux(__first, __last, __pred,
                                    (typename ::std::iterator_traits< _BidirectIter >::value_type*)0,
                                    (typename ::std::iterator_traits< _BidirectIter >::difference_type*)0, true);
}








#line 861 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"

}

template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
  
  for (;;) {
    if (__first == __last)
      return __first;
    else if (__pred(*__first))
      ++__first;
    else
      break;
  }
  return ::std::priv:: __stable_partition_aux(__first, __last, __pred,
                                           typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

namespace priv {

template <class _RandomAccessIter, class _Tp, class _Compare>
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first,
                                        _RandomAccessIter __last,
                                        _Tp __pivot, _Compare __comp) {
  for (;;) {
    while (__comp(*__first, __pivot)) {
      
      ++__first;
    }
    --__last;
    while (__comp(__pivot, *__last)) {
      
      --__last;
    }
    if (!(__first < __last))
      return __first;
    iter_swap(__first, __last);
    ++__first;
  }
}




template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val,
                               _Compare __comp) {
  _RandomAccessIter __next = __last;
  --__next;
  while (__comp(__val, *__next)) {
    
    *__last = *__next;
    __last = __next;
    --__next;
  }
  *__last = __val;
}

template <class _RandomAccessIter, class _Tp, class _Compare>
inline void __linear_insert(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Tp __val, _Compare __comp) {
  
  
  if (__comp(__val, *__first)) {
    
    copy_backward(__first, __last, __last + 1);
    *__first = __val;
  }
  else
    __unguarded_linear_insert(__last, __val, __comp);
}

template <class _RandomAccessIter, class _Tp, class _Compare>
void __insertion_sort(_RandomAccessIter __first,
                      _RandomAccessIter __last,
                      _Tp *, _Compare __comp) {
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    __linear_insert<_RandomAccessIter, _Tp, _Compare>(__first, __i, *__i, __comp);  
}

template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_insertion_sort_aux(_RandomAccessIter __first,
                                    _RandomAccessIter __last,
                                    _Tp*, _Compare __comp) {
  for (_RandomAccessIter __i = __first; __i != __last; ++__i)
    __unguarded_linear_insert<_RandomAccessIter, _Tp, _Compare>(__i, *__i, __comp);
}

template <class _RandomAccessIter, class _Compare>
inline void __unguarded_insertion_sort(_RandomAccessIter __first,
                                       _RandomAccessIter __last,
                                       _Compare __comp) {
  __unguarded_insertion_sort_aux(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _RandomAccessIter, class _Compare>
void __final_insertion_sort(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Compare __comp) {
  if (__last - __first > 16) {
    __insertion_sort(__first, __first + 16, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
    __unguarded_insertion_sort(__first + 16, __last, __comp);
  }
  else
    __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _RandomAccessIter, class _Tp, class _Size, class _Compare>
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit, _Compare __comp) {
  while (__last - __first > 16) {
    if (__depth_limit == 0) {
      partial_sort(__first, __last, __last, __comp);
      return;
    }
    --__depth_limit;
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1), __comp)),
       __comp);
    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit, __comp);
    __last = __cut;
  }
}

}

template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last) {
  
  if (__first != __last) {
    ::std::priv:: __introsort_loop(__first, __last,
                                (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                                ::std::priv:: __lg(__last - __first) * 2,
                                ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
    ::std::priv:: __final_insertion_sort(__first, __last,
                                      ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
  }
}

template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp) {
  
  if (__first != __last) {
    ::std::priv:: __introsort_loop(__first, __last,
                                (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                                ::std::priv:: __lg(__last - __first) * 2, __comp);
    ::std::priv:: __final_insertion_sort(__first, __last, __comp);
  }
}


namespace priv {

template <class _RandomAccessIter, class _Compare>
void __inplace_stable_sort(_RandomAccessIter __first,
                           _RandomAccessIter __last, _Compare __comp) {
  if (__last - __first < 15) {
    __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
    return;
  }
  _RandomAccessIter __middle = __first + (__last - __first) / 2;
  __inplace_stable_sort(__first, __middle, __comp);
  __inplace_stable_sort(__middle, __last, __comp);
  __merge_without_buffer(__first, __middle, __last,
                         __middle - __first,
                         __last - __middle,
                         __comp);
}

template <class _RandomAccessIter1, class _RandomAccessIter2,
          class _Distance, class _Compare>
void __merge_sort_loop(_RandomAccessIter1 __first,
                       _RandomAccessIter1 __last,
                       _RandomAccessIter2 __result, _Distance __step_size,
                       _Compare __comp) {
  _Distance __two_step = 2 * __step_size;

  while (__last - __first >= __two_step) {
    __result = merge(__first, __first + __step_size,
                     __first + __step_size, __first + __two_step,
                     __result,
                     __comp);
    __first += __two_step;
  }
  __step_size = (min) (_Distance(__last - __first), __step_size);

  merge(__first, __first + __step_size,
        __first + __step_size, __last,
        __result,
        __comp);
}

const int __stl_chunk_size = 7;

template <class _RandomAccessIter, class _Distance, class _Compare>
void __chunk_insertion_sort(_RandomAccessIter __first,
                            _RandomAccessIter __last,
                            _Distance __chunk_size, _Compare __comp) {
  while (__last - __first >= __chunk_size) {
    __insertion_sort(__first, __first + __chunk_size,
                     (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
    __first += __chunk_size;
  }
  __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
          class _Compare>
void __merge_sort_with_buffer(_RandomAccessIter __first,
                              _RandomAccessIter __last, _Pointer __buffer,
                              _Distance*, _Compare __comp) {
  _Distance __len = __last - __first;
  _Pointer __buffer_last = __buffer + __len;

  _Distance __step_size = __stl_chunk_size;
  __chunk_insertion_sort(__first, __last, __step_size, __comp);

  while (__step_size < __len) {
    __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
    __step_size *= 2;
    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
    __step_size *= 2;
  }
}

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
_BidirectionalIter1 __rotate_adaptive(_BidirectionalIter1 __first,
                                      _BidirectionalIter1 __middle,
                                      _BidirectionalIter1 __last,
                                      _Distance __len1, _Distance __len2,
                                      _BidirectionalIter2 __buffer,
                                      _Distance __buffer_size) {
  if (__len1 > __len2 && __len2 <= __buffer_size) {
    _BidirectionalIter2 __buffer_end = ::std::copy(__middle, __last, __buffer);
    ::std::copy_backward(__first, __middle, __last);
    return ::std::copy(__buffer, __buffer_end, __first);
  }
  else if (__len1 <= __buffer_size) {
    _BidirectionalIter2 __buffer_end = ::std::copy(__first, __middle, __buffer);
    ::std::copy(__middle, __last, __first);
    return ::std::copy_backward(__buffer, __buffer_end, __last);
  }
  else
    return ::std::priv:: __rotate(__first, __middle, __last);
}

template <class _BidirectionalIter, class _Distance, class _Pointer,
          class _Compare>
void __merge_adaptive(_BidirectionalIter __first,
                      _BidirectionalIter __middle,
                      _BidirectionalIter __last,
                      _Distance __len1, _Distance __len2,
                      _Pointer __buffer, _Distance __buffer_size,
                      _Compare __comp) {
  if (__len1 <= __len2 && __len1 <= __buffer_size) {
    _Pointer __buffer_end = ::std::copy(__first, __middle, __buffer);
    ::std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
  }
  else if (__len2 <= __buffer_size) {
    _Pointer __buffer_end = ::std::copy(__middle, __last, __buffer);
    ::std::priv:: __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
                                __comp);
  }
  else {
    _BidirectionalIter __first_cut = __first;
    _BidirectionalIter __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2) {
      __len11 = __len1 / 2;
      ::std::advance(__first_cut, __len11);
      __second_cut = ::std::lower_bound(__middle, __last, *__first_cut, __comp);
      __len22 += ::std::distance(__middle, __second_cut);
    }
    else {
      __len22 = __len2 / 2;
      ::std::advance(__second_cut, __len22);
      __first_cut = ::std::upper_bound(__first, __middle, *__second_cut, __comp);
      __len11 += ::std::distance(__first, __first_cut);
    }
    _BidirectionalIter __new_middle =
      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,
                        __len22, __buffer, __buffer_size);
    __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                     __len22, __buffer, __buffer_size, __comp);
    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                     __len2 - __len22, __buffer, __buffer_size, __comp);
  }
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
          class _Compare>
void __stable_sort_adaptive(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Pointer __buffer,
                            _Distance __buffer_size, _Compare __comp) {
  _Distance __len = (__last - __first + 1) / 2;
  _RandomAccessIter __middle = __first + __len;
  if (__len > __buffer_size) {
    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
                           __comp);
    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
                           __comp);
  }
  else {
    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)0,
                               __comp);
    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)0,
                               __comp);
  }
  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                   _Distance(__last - __middle), __buffer, __buffer_size,
                   __comp);
}

template <class _RandomAccessIter, class _Tp, class _Distance, class _Compare>
void __stable_sort_aux(_RandomAccessIter __first,
                       _RandomAccessIter __last, _Tp*, _Distance*,
                       _Compare __comp) {
  _Temporary_buffer<_RandomAccessIter, _Tp> buf(__first, __last);
  if (buf.begin() == 0)
    __inplace_stable_sort(__first, __last, __comp);
  else
    __stable_sort_adaptive(__first, __last, buf.begin(),
                           _Distance(buf.size()),
                           __comp);
}

}

template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last) {
  
  ::std::priv:: __stable_sort_aux(__first, __last,
                               (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                               (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                               ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last, _Compare __comp) {
  
  ::std::priv:: __stable_sort_aux(__first, __last,
                               (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                               (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                               __comp);
}


namespace priv {

template <class _RandomAccessIter, class _Tp, class _Compare>
void __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
                    _RandomAccessIter __last, _Tp*, _Compare __comp) {
  make_heap(__first, __middle, __comp);
  for (_RandomAccessIter __i = __middle; __i < __last; ++__i) {
    if (__comp(*__i, *__first)) {
      
      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,
                 (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0);
    }
  }
  sort_heap(__first, __middle, __comp);
}

}

template <class _RandomAccessIter>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
                  _RandomAccessIter __last) {
  
  
  ::std::priv:: __partial_sort(__first, __middle, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                            ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
                  _RandomAccessIter __last, _Compare __comp) {
  
  
  ::std::priv:: __partial_sort(__first, __middle, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

namespace priv {

template <class _InputIter, class _RandomAccessIter, class _Compare,
          class _Distance, class _Tp>
_RandomAccessIter __partial_sort_copy(_InputIter __first,
                                      _InputIter __last,
                                      _RandomAccessIter __result_first,
                                      _RandomAccessIter __result_last,
                                      _Compare __comp, _Distance*, _Tp*) {
  if (__result_first == __result_last) return __result_last;
  _RandomAccessIter __result_real_last = __result_first;
  while(__first != __last && __result_real_last != __result_last) {
    *__result_real_last = *__first;
    ++__result_real_last;
    ++__first;
  }
  make_heap(__result_first, __result_real_last, __comp);
  while (__first != __last) {
    if (__comp(*__first, *__result_first)) {
      
      __adjust_heap(__result_first, _Distance(0),
                    _Distance(__result_real_last - __result_first),
                    _Tp(*__first),
                    __comp);
    }
    ++__first;
  }
  sort_heap(__result_first, __result_real_last, __comp);
  return __result_real_last;
}

}

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first, _RandomAccessIter __result_last) {
  
  
  return ::std::priv:: __partial_sort_copy(__first, __last, __result_first, __result_last,
                                        ::std::priv:: __less((typename ::std::iterator_traits< _InputIter >::value_type*)0),
                                        (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                                        (typename ::std::iterator_traits< _InputIter >::value_type*)0);
}

template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first,
                  _RandomAccessIter __result_last, _Compare __comp) {
  
  
  return ::std::priv:: __partial_sort_copy(__first, __last, __result_first, __result_last,
                                        __comp,
                                        (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                                        (typename ::std::iterator_traits< _InputIter >::value_type*)0);
}


namespace priv {

template <class _RandomAccessIter, class _Tp, class _Compare>
void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                   _RandomAccessIter __last, _Tp*, _Compare __comp) {
  while (__last - __first > 3) {
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1),
                                         __comp)),
                            __comp);
    if (__cut <= __nth)
      __first = __cut;
    else
      __last = __cut;
  }
  __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

}

template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last) {
  
  
  ::std::priv:: __nth_element(__first, __nth, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                           ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last, _Compare __comp) {
  
  
  ::std::priv:: __nth_element(__first, __nth, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}


namespace priv {

template <class _ForwardIter, class _Tp,
          class _Compare1, class _Compare2, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                           _Compare1 __comp1, _Compare2 __comp2, _Distance*) {
  _Distance __len = ::std::distance(__first, __last);
  _Distance __half;

  while (__len > 0) {
    __half = __len >> 1;
    _ForwardIter __middle = __first;
    ::std::advance(__middle, __half);
    if (__comp2(__val, *__middle)) {
      
      __len = __half;
    }
    else {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
  }
  return __first;
}

template <class _ForwardIter, class _Tp,
          class _Compare1, class _Compare2, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
              _Compare1 __comp1, _Compare2 __comp2, _Distance* __dist) {
  _Distance __len = ::std::distance(__first, __last);
  _Distance __half;

  while (__len > 0) {
    __half = __len >> 1;
    _ForwardIter __middle = __first;
    ::std::advance(__middle, __half);
    if (__comp1(*__middle, __val)) {
      
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else if (__comp2(__val, *__middle)) {
      
      __len = __half;
    }
    else {
      _ForwardIter __left = ::std::priv:: __lower_bound(__first, __middle, __val, __comp1, __comp2, __dist);
      
      
      if (__comp1(*__left, __val)) {
        
        return pair<_ForwardIter, _ForwardIter>(__left, __left);
      }
      ::std::advance(__first, __len);
      _ForwardIter __right = ::std::priv:: __upper_bound(++__middle, __first, __val, __comp1, __comp2, __dist);
      return pair<_ForwardIter, _ForwardIter>(__left, __right);
    }
  }
  return pair<_ForwardIter, _ForwardIter>(__first, __first);
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result) {
  
  
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first2 < *__first1) {
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
    }
    ++__result;
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result, _Compare __comp) {
  
  
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first2, *__first1)) {
      
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
    }
    ++__result;
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

namespace priv {

template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
                            _BidirectionalIter __middle,
                            _BidirectionalIter __last,
                            _Distance __len1, _Distance __len2,
                            _Compare __comp) {
  if (__len1 == 0 || __len2 == 0)
    return;
  if (__len1 + __len2 == 2) {
    if (__comp(*__middle, *__first)) {
      
      iter_swap(__first, __middle);
    }
    return;
  }
  _BidirectionalIter __first_cut = __first;
  _BidirectionalIter __second_cut = __middle;
  _Distance __len11 = 0;
  _Distance __len22 = 0;
  if (__len1 > __len2) {
    __len11 = __len1 / 2;
    ::std::advance(__first_cut, __len11);
    __second_cut = ::std::lower_bound(__middle, __last, *__first_cut, __comp);
    __len22 += ::std::distance(__middle, __second_cut);
  }
  else {
    __len22 = __len2 / 2;
    ::std::advance(__second_cut, __len22);
    __first_cut = ::std::upper_bound(__first, __middle, *__second_cut, __comp);
    __len11 += ::std::distance(__first, __first_cut);
  }
  _BidirectionalIter __new_middle
    = ::std::priv:: __rotate(__first_cut, __middle, __second_cut);
  __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,
                         __comp);
  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,
                         __len2 - __len22, __comp);
}

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
                                     _BidirectionalIter1 __last1,
                                     _BidirectionalIter2 __first2,
                                     _BidirectionalIter2 __last2,
                                     _BidirectionalIter3 __result,
                                     _Compare __comp) {
  if (__first1 == __last1)
    return copy_backward(__first2, __last2, __result);
  if (__first2 == __last2)
    return copy_backward(__first1, __last1, __result);
  --__last1;
  --__last2;
  for (;;) {
    if (__comp(*__last2, *__last1)) {
      
      *--__result = *__last1;
      if (__first1 == __last1)
        return copy_backward(__first2, ++__last2, __result);
      --__last1;
    }
    else {
      *--__result = *__last2;
      if (__first2 == __last2)
        return copy_backward(__first1, ++__last1, __result);
      --__last2;
    }
  }
}

template <class _BidirectionalIter, class _Tp,
          class _Distance, class _Compare>
inline void __inplace_merge_aux(_BidirectionalIter __first,
                                _BidirectionalIter __middle,
                                _BidirectionalIter __last, _Tp*, _Distance*,
                                _Compare __comp) {
  _Distance __len1 = ::std::distance(__first, __middle);
  _Distance __len2 = ::std::distance(__middle, __last);

  _Temporary_buffer<_BidirectionalIter, _Tp> __buf(__first, __last);
  if (__buf.begin() == 0)
    __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
  else
    __merge_adaptive(__first, __middle, __last, __len1, __len2,
                     __buf.begin(), _Distance(__buf.size()),
                     __comp);
}

}

template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last) {
  
  
  if (__first == __middle || __middle == __last)
    return;
  ::std::priv:: __inplace_merge_aux(__first, __middle, __last,
                                 (typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0, (typename ::std::iterator_traits< _BidirectionalIter >::difference_type*)0,
                                 ::std::priv:: __less((typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last, _Compare __comp) {
  
  
  if (__first == __middle || __middle == __last)
    return;
  ::std::priv:: __inplace_merge_aux(__first, __middle, __last,
                                 (typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0, (typename ::std::iterator_traits< _BidirectionalIter >::difference_type*)0,
                                 __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _Compare>
bool __includes(_InputIter1 __first1, _InputIter1 __last1,
                _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
  
  
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first2, *__first1)) {
      
      return false;
    }
    else if (__comp(*__first1, *__first2))
      ++__first1;
    else
      ++__first1, ++__first2;

  return __first2 == __last2;
}

}

template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
  return ::std::priv:: __includes(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2) {
  return ::std::priv:: __includes(__first1, __last1, __first2, __last2,
                               ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_union(_InputIter1 __first1, _InputIter1 __last1,
                        _InputIter2 __first2, _InputIter2 __last2,
                        _OutputIter __result, _Compare __comp) {
  
  
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
      
      *__result = *__first1;
      ++__first1;
    }
    else if (__comp(*__first2, *__first1)) {
      
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
      ++__first2;
    }
    ++__result;
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result) {
  return ::std::priv:: __set_union(__first1, __last1, __first2, __last2, __result,
                                ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result, _Compare __comp) {
  return ::std::priv:: __set_union(__first1, __last1, __first2, __last2, __result, __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                               _InputIter2 __first2, _InputIter2 __last2,
                               _OutputIter __result, _Compare __comp) {
  
  
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first1, *__first2)) {
      
      ++__first1;
    }
    else if (__comp(*__first2, *__first1))
      ++__first2;
    else {
      *__result = *__first1;
      ++__first1;
      ++__first2;
      ++__result;
    }
  return __result;
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result) {
  return ::std::priv:: __set_intersection(__first1, __last1, __first2, __last2, __result,
                                       ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp) {
  return ::std::priv:: __set_intersection(__first1, __last1, __first2, __last2, __result, __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp) {
  
  
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first1, *__first2)) {
      
      *__result = *__first1;
      ++__first1;
      ++__result;
    }
    else if (__comp(*__first2, *__first1))
      ++__first2;
    else {
      ++__first1;
      ++__first2;
    }
  return ::std::copy(__first1, __last1, __result);
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result) {
  return ::std::priv:: __set_difference(__first1, __last1, __first2, __last2, __result,
                                     ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp) {
  return ::std::priv:: __set_difference(__first1, __last1, __first2, __last2, __result, __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
__set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp) {
  
  
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
      
      *__result = *__first1;
      ++__first1;
      ++__result;
    }
    else if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
      ++__result;
    }
    else {
      ++__first1;
      ++__first2;
    }
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result) {
  return ::std::priv:: __set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                               ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result,
                         _Compare __comp) {
  return ::std::priv:: __set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp);
}




template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last) {
  
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (*__result < *__first) {
      
      __result = __first;
    }
  return __result;
}

template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
                         _Compare __comp) {
  
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last) {
    if (__comp(*__result, *__first)) {
      
      __result = __first;
    }
  }
  return __result;
}

template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last) {
  
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (*__first < *__result) {
      
      __result = __first;
    }
  return __result;
}

template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
                         _Compare __comp) {
  
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last) {
    if (__comp(*__first, *__result)) {
      
      __result = __first;
    }
  }
  return __result;
}



namespace priv {

template <class _BidirectionalIter, class _Compare>
bool __next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                        _Compare __comp) {
  
  if (__first == __last)
    return false;
  _BidirectionalIter __i = __first;
  ++__i;
  if (__i == __last)
    return false;
  __i = __last;
  --__i;

  for(;;) {
    _BidirectionalIter __ii = __i;
    --__i;
    if (__comp(*__i, *__ii)) {
      
      _BidirectionalIter __j = __last;
      while (!__comp(*__i, *--__j)) {}
      iter_swap(__i, __j);
      reverse(__ii, __last);
      return true;
    }
    if (__i == __first) {
      reverse(__first, __last);
      return false;
    }
  }


#line 1891 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"
}

}

template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
  
  return ::std::priv:: __next_permutation(__first, __last,
                                       ::std::priv:: __less((typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp) {
  
  return ::std::priv:: __next_permutation(__first, __last, __comp);
}

namespace priv {

template <class _BidirectionalIter, class _Compare>
bool __prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                        _Compare __comp) {
  if (__first == __last)
    return false;
  _BidirectionalIter __i = __first;
  ++__i;
  if (__i == __last)
    return false;
  __i = __last;
  --__i;

  for(;;) {
    _BidirectionalIter __ii = __i;
    --__i;
    if (__comp(*__ii, *__i)) {
      
      _BidirectionalIter __j = __last;
      while (!__comp(*--__j, *__i)) {}
      iter_swap(__i, __j);
      reverse(__ii, __last);
      return true;
    }
    if (__i == __first) {
      reverse(__first, __last);
      return false;
    }
  }


#line 1942 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"
}

}

template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
  
  return ::std::priv:: __prev_permutation(__first, __last,
                                       ::std::priv:: __less((typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp) {
  
  return ::std::priv:: __prev_permutation(__first, __last, __comp);
}






namespace priv {

template <class _RandomAccessIter, class _Distance, class _StrictWeakOrdering>
bool __is_heap(_RandomAccessIter __first, _StrictWeakOrdering __comp,
               _Distance __n) {
  _Distance __parent = 0;
  for (_Distance __child = 1; __child < __n; ++__child) {
    if (__comp(__first[__parent], __first[__child])) {
      
      return false;
    }
    if ((__child & 1) == 0)
      ++__parent;
  }
  return true;
}

}

template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last) {
  
  return ::std::priv:: __is_heap(__first, ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0), __last - __first);
}

template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
             _StrictWeakOrdering __comp) {
  
  return ::std::priv:: __is_heap(__first, __comp, __last - __first);
}


namespace priv {

template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
                 _StrictWeakOrdering __comp) {
  
  if (__first == __last)
    return true;

  _ForwardIter __next = __first;
  for (++__next; __next != __last; __first = __next, ++__next) {
    if (__comp(*__next, *__first)) {
      
      return false;
    }
  }

  return true;
}

}
#line 2020 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"

}



#line 2026 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.c"




#line 738 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"
#line 739 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"

#line 741 "C:\\Pin35\\extras\\stlport\\include\\stl/_algo.h"





#line 42 "C:\\Pin35\\extras\\stlport\\include\\algorithm"
#line 43 "C:\\Pin35\\extras\\stlport\\include\\algorithm"
#line 44 "C:\\Pin35\\extras\\stlport\\include\\algorithm"







#line 52 "C:\\Pin35\\extras\\stlport\\include\\algorithm"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 55 "C:\\Pin35\\extras\\stlport\\include\\algorithm"

#line 57 "C:\\Pin35\\extras\\stlport\\include\\algorithm"

#line 59 "C:\\Pin35\\extras\\stlport\\include\\algorithm"




#line 41 "c:\\pin35\\extras\\components\\include\\util/regvalue.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/data.hpp"















































































































































































































































































































































































































































































































































































































































#line 42 "c:\\pin35\\extras\\components\\include\\util/regvalue.hpp"


namespace UTIL {







class  REGVALUE
{
public:
    


    REGVALUE() : _size(0), _value(0) {}

    




    REGVALUE(const REGVALUE &other)
    {
        SetCopy(other);
    }

    




    REGVALUE(ADDRINT val)
    {
        SetAddress(val);
    }

    





    REGVALUE(UINT64 val, unsigned size)
    {
        Set64(val, size);
    }

    






    REGVALUE(UINT64 lo, UINT64 hi, unsigned size)
    {
        Set128(lo, hi, size);
    }

    








    REGVALUE(const UTIL::DATA &val, unsigned size=0)
    {
        SetBuffer(val.GetBuf<void>(), val.GetSize(), size);
    }

    








    template<typename T> REGVALUE(const T *buf, size_t byteSize, unsigned size=0)
    {
        SetBuffer(static_cast<const void *>(buf), byteSize, size);
    }

    ~REGVALUE() {ClearIfNeeded();}

    






    REGVALUE &operator =(const REGVALUE &other)
    {
        ClearIfNeeded();
        SetCopy(other);
        return *this;
    }

    




    void Assign(const REGVALUE &other)
    {
        ClearIfNeeded();
        SetCopy(other);
    }

    




    void Assign(ADDRINT val)
    {
        ClearIfNeeded();
        SetAddress(val);
    }

    





    void Assign(UINT64 val, unsigned size)
    {
        ClearIfNeeded();
        Set64(val, size);
    }

    






    void Assign(UINT64 lo, UINT64 hi, unsigned size)
    {
        ClearIfNeeded();
        Set128(lo, hi, size);
    }

    





    void Assign(UINT64 * data, unsigned size)
    {
        ClearIfNeeded();
        Set256(data, size);
    }

    








    void Assign(const UTIL::DATA &val, unsigned size=0)
    {
        ClearIfNeeded();
        SetBuffer(val.GetBuf<void>(), val.GetSize(), size);
    }

    








    template<typename T> void Assign(const T *buf, size_t byteSize, unsigned size=0)
    {
        ClearIfNeeded();
        SetBuffer(static_cast<const void *>(buf), byteSize, size);
    }

    





    void Resize(unsigned size)
    {
        if (_size <= 8*sizeof(PTRINT))
        {
            Set64(_value, size);
        }
        else
        {
            UTIL::DATA *d = _bigValue;
            SetBuffer(d->GetBuf<void>(), d->GetSize(), size);
            delete d;
        }
    }

    


    unsigned GetBitSize() const     {return _size;}

    








    void CopyToData(UTIL::DATA *data) const
    {
        if (_size <= 8*sizeof(PTRINT))
            data->Assign(&_value, GetByteSize());
        else
            data->Assign(*_bigValue);
    }

    







    void CopyToBuffer(void *data) const
    {
        if (_size <= 8*sizeof(PTRINT))
            memcpy(data, &_value, GetByteSize());
        else
            memcpy(data, _bigValue->GetBuf<void>(), _bigValue->GetSize());
    }

    






    template<typename T> T GetValueAs() const
    {
        if (_size <= 8*sizeof(PTRINT))
            return static_cast<T>(_value);
        return GetIndexedWord<T>(0);
    }

    








    template<typename T> T GetIndexedWord(unsigned index) const
    {
        size_t byteSize = GetByteSize();
        const UINT8 *buf = static_cast<const UINT8 *>(GetBuffer());
        size_t offset = index * sizeof(T);
        if (offset + sizeof(T) <= byteSize)
        {
            T tmp;
            memcpy(static_cast<void *>(&tmp), static_cast<const void *>(buf+offset), sizeof(T));
            return tmp;
        }
        else if (offset < byteSize)
        {
            T tmp(0);
            memcpy(static_cast<void *>(&tmp), static_cast<const void *>(buf+offset), byteSize-offset);
            return tmp;
        }
        else
        {
            return T(0);
        }
    }

private:
    




    void SetCopy(const REGVALUE &other)
    {
        _size = other._size;
        if (_size <= 8*sizeof(PTRINT))
            _value = other._value;
        else
            _bigValue = new UTIL::DATA(*other._bigValue);
    }

    




    void SetAddress(ADDRINT val)
    {
        _size = 8*sizeof(ADDRINT);

        _value = val;


#line 368 "c:\\pin35\\extras\\components\\include\\util/regvalue.hpp"
    }

    





    void Set64(UINT64 val, unsigned size)
    {
        _size = size;
        if (size == 8*sizeof(PTRINT))
        {
            _value = static_cast<PTRINT>(val);
        }
        else if (size < 8*sizeof(PTRINT))
        {
            PTRINT mask = PTRINT(1);
            _value = static_cast<PTRINT>(val) & ((mask << size) - PTRINT(1));
        }
        else if (size == 8*sizeof(UINT64))
        {
            _bigValue = new DATA(&val, 8);
        }
        else if (size > 8*sizeof(UINT64))
        {
            
            
            unsigned byteSize = (size + 7) >> 3;
            _bigValue = new DATA(byteSize);
            memcpy(_bigValue->GetWritableBuf<void>(), static_cast<void *>(&val), sizeof(val));
            UINT8 *rest = _bigValue->GetWritableBuf<UINT8>() + sizeof(val);
            memset(static_cast<void *>(rest), 0, byteSize - sizeof(val));
            _bigValue->ReleaseWritableBuf();
        }
        else
        {
            
            
            
            UINT64 mask = UINT64(1);
            val = val & ((mask << size) - UINT64(1));
            unsigned byteSize = (size + 7) >> 3;
            _bigValue = new DATA(&val, byteSize);
        }
    }

    






    void Set128(UINT64 lo, UINT64 hi, unsigned size)
    {
        UINT64 buf[2];
        buf[0] = lo;
        buf[1] = hi;
        SetBuffer(static_cast<const void *>(buf), sizeof(buf), size);
    }

    





    void Set256(UINT64 * data, unsigned size)
    {
        UINT64 buf[4];
        buf[0] = data[0];
        buf[1] = data[1];
        buf[2] = data[2];
        buf[3] = data[3];
        SetBuffer(static_cast<const void *>(buf), sizeof(buf), size);
    }

    







    void SetBuffer(const void *buf, size_t byteSizeIn, unsigned size)
    {
        if (!size)
            size = static_cast<unsigned>(8*byteSizeIn);
        _size = size;
        size_t byteSize = (size + 7) >> 3;

        if (size == 8*sizeof(PTRINT))
        {
            
            
            
            _value = 0;
            memcpy(static_cast<void *>(&_value), buf, std::min(byteSizeIn, sizeof(PTRINT)));
        }
        else if (size < 8*sizeof(PTRINT))
        {
            
            
            _value = 0;
            memcpy(static_cast<void *>(&_value), buf, std::min(byteSizeIn, byteSize));
            PTRINT mask = PTRINT(1);
            _value &= ((mask << size) - PTRINT(1));
        }
        else
        {
            
            
            
            _bigValue = new DATA(byteSize);
            size_t sizeCopied = std::min(byteSizeIn, byteSize);
            memcpy(_bigValue->GetWritableBuf<void>(), buf, sizeCopied);
            memset(static_cast<void *>(_bigValue->GetWritableBuf<UINT8>()+sizeCopied), 0, byteSize-sizeCopied);

            
            
            
            
            if ((byteSize <= byteSizeIn) && (size < 8*byteSize))
            {
                unsigned numBitsLast = static_cast<unsigned>(8 - (8*byteSize - size));
                UINT8 *last = &_bigValue->GetWritableBuf<UINT8>()[_bigValue->GetSize()-1];
                UINT8 mask = UINT8(1);
                *last &= ((mask << numBitsLast) - UINT8(1));
            }
            _bigValue->ReleaseWritableBuf();
        }
    }

    


    void ClearIfNeeded()
    {
        if (_size > 8*sizeof(PTRINT))
            delete _bigValue;
    }

    


    size_t GetByteSize() const
    {
        return (_size + 7) >> 3;
    }

    




    const void *GetBuffer() const
    {
        if (_size <= 8*sizeof(PTRINT))
            return static_cast<const void *>(&_value);
        else
            return _bigValue->GetBuf<void>();
    }


private:
    unsigned _size;             

    
    
    union
    {
        PTRINT _value;    
        UTIL::DATA *_bigValue;  
    };
};

} 
#line 548 "c:\\pin35\\extras\\components\\include\\util/regvalue.hpp"
#line 52 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/round.hpp"


































































































































































#line 53 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/scoped-ptr.hpp"




































#line 1 "C:\\Pin35\\extras\\stlport\\include\\assert.h"

















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 19 "C:\\Pin35\\extras\\stlport\\include\\assert.h"


#line 22 "C:\\Pin35\\extras\\stlport\\include\\assert.h"







#line 30 "C:\\Pin35\\extras\\stlport\\include\\assert.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/assert.h"












































#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 46 "C:\\Pin35\\extras\\crt\\include/assert.h"













#line 60 "C:\\Pin35\\extras\\crt\\include/assert.h"
#line 61 "C:\\Pin35\\extras\\crt\\include/assert.h"

extern "C" {
 void __assert(const char *, int, const char *) ;
 void __assert2(const char *, int, const char *, const char *) ;













}
#line 31 "C:\\Pin35\\extras\\stlport\\include\\assert.h"
#line 32 "C:\\Pin35\\extras\\stlport\\include\\assert.h"
#line 33 "C:\\Pin35\\extras\\stlport\\include\\assert.h"



#line 37 "C:\\Pin35\\extras\\stlport\\include\\assert.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\assert.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 42 "C:\\Pin35\\extras\\stlport\\include\\assert.h"

#line 44 "C:\\Pin35\\extras\\stlport\\include\\assert.h"

#line 46 "C:\\Pin35\\extras\\stlport\\include\\assert.h"





#line 38 "c:\\pin35\\extras\\components\\include\\util/scoped-ptr.hpp"


namespace UTIL {









template<typename T> class  SCOPED_PTR
{
public:
    




    explicit SCOPED_PTR(T *p = 0) : _ptr(p) {}

    


    ~SCOPED_PTR()
    {
        delete _ptr;    
    }

    




    void Reset(T *p = 0)
    {
        delete _ptr;
        _ptr = p;
    }

    


    T & operator*() const
    {
        ((_ptr != 0) ? (void)0 : __assert2("c:\\pin35\\extras\\components\\include\\util/scoped-ptr.hpp", 84, "", "_ptr != 0"));
        return *_ptr;
    }

    


    T * operator->() const
    {
        ((_ptr != 0) ? (void)0 : __assert2("c:\\pin35\\extras\\components\\include\\util/scoped-ptr.hpp", 93, "", "_ptr != 0"));
        return _ptr;
    }

    


    T * Get() const
    {
        return _ptr;
    }

    




    void Swap(SCOPED_PTR &other)
    {
        T *t = other._ptr;
        other._ptr = _ptr;
        _ptr = t;
    }

    




    operator bool () const
    {
        return (_ptr != 0);
    }

    


    bool operator! () const
    {
        return (_ptr == 0);
    }

private:
    T *_ptr;

    SCOPED_PTR(SCOPED_PTR const &);
    SCOPED_PTR & operator=(SCOPED_PTR const &);
};

} 
#line 144 "c:\\pin35\\extras\\components\\include\\util/scoped-ptr.hpp"
#line 54 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/scoped-array.hpp"




































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"

















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 19 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"


#line 22 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"






#line 1 "c:\\pin35\\extras\\stlport\\include\\errno.h"


















#line 20 "c:\\pin35\\extras\\stlport\\include\\errno.h"

#line 22 "c:\\pin35\\extras\\stlport\\include\\errno.h"


































#line 57 "c:\\pin35\\extras\\stlport\\include\\errno.h"
#line 58 "c:\\pin35\\extras\\stlport\\include\\errno.h"







#line 66 "c:\\pin35\\extras\\stlport\\include\\errno.h"





#line 29 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 34 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stddef.h"

















































































































































































#line 181 "C:\\Pin35\\extras\\crt\\include/stddef.h"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 40 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"



#line 44 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 45 "C:\\Pin35\\extras\\stlport\\include\\stddef.h"
#line 38 "c:\\pin35\\extras\\components\\include\\util/scoped-array.hpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\assert.h"

















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 19 "C:\\Pin35\\extras\\stlport\\include\\assert.h"


#line 22 "C:\\Pin35\\extras\\stlport\\include\\assert.h"










#line 33 "C:\\Pin35\\extras\\stlport\\include\\assert.h"



#line 37 "C:\\Pin35\\extras\\stlport\\include\\assert.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\assert.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 42 "C:\\Pin35\\extras\\stlport\\include\\assert.h"

#line 44 "C:\\Pin35\\extras\\stlport\\include\\assert.h"

#line 46 "C:\\Pin35\\extras\\stlport\\include\\assert.h"





#line 39 "c:\\pin35\\extras\\components\\include\\util/scoped-array.hpp"


namespace UTIL {









template<typename T> class  SCOPED_ARRAY
{
public:
    




    explicit SCOPED_ARRAY(T *p = 0) : _ptr(p) {}

    


    ~SCOPED_ARRAY()
    {
        delete [] _ptr;    
    }

    




    void Reset(T *p = 0)
    {
        delete [] _ptr;
        _ptr = p;
    }

    






    T & operator[](std::ptrdiff_t i) const
    {
        ((_ptr != 0) ? (void)0 : __assert2("c:\\pin35\\extras\\components\\include\\util/scoped-array.hpp", 89, "", "_ptr != 0"));
        ((i >= 0) ? (void)0 : __assert2("c:\\pin35\\extras\\components\\include\\util/scoped-array.hpp", 90, "", "i >= 0"));
        return _ptr[i];
    }

    


    T * Get() const
    {
        return _ptr;
    }

    




    operator bool () const
    {
        return (_ptr != 0);
    }

    


    bool operator! () const
    {
        return (_ptr == 0);
    }

private:
    T *_ptr;

    SCOPED_ARRAY(SCOPED_ARRAY const &);
    SCOPED_ARRAY & operator=(SCOPED_ARRAY const &);
};

} 
#line 129 "c:\\pin35\\extras\\components\\include\\util/scoped-array.hpp"
#line 55 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/strings.hpp"




































#line 1 "C:\\Pin35\\extras\\stlport\\include\\sstream"


























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 





#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\sstream"

#line 30 "C:\\Pin35\\extras\\stlport\\include\\sstream"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ioserr.h"









#line 11 "C:\\Pin35\\extras\\stlport\\include\\stl/_ioserr.h"

#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/_ioserr.h"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\sstream"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"







































namespace std {













template <class _CharT, class _Traits, class _Alloc>
class basic_stringbuf : public basic_streambuf<_CharT, _Traits> {
public:                         
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;

  typedef basic_streambuf<_CharT, _Traits>          _Base;
  typedef basic_stringbuf<_CharT, _Traits, _Alloc>  _Self;
  typedef basic_string<_CharT, _Traits, _Alloc>     _String;

public:                         
  explicit basic_stringbuf(ios_base::openmode __mode
                                      = ios_base::in | ios_base::out);
  explicit basic_stringbuf(const _String& __s, ios_base::openmode __mode
                                      = ios_base::in | ios_base::out);
  virtual ~basic_stringbuf();

public:                         
  _String str() const { return _M_str; }
  void str(const _String& __s);

protected:                      
  virtual int_type underflow();
  virtual int_type uflow();
  virtual int_type pbackfail(int_type __c);
  virtual int_type overflow(int_type __c);
  int_type pbackfail() {return pbackfail(_Traits::eof());}
  int_type overflow() {return overflow(_Traits::eof());}

  virtual streamsize xsputn(const char_type* __s, streamsize __n);
  virtual streamsize _M_xsputnc(char_type __c, streamsize __n);

  virtual _Base* setbuf(_CharT* __buf, streamsize __n);
  virtual pos_type seekoff(off_type __off, ios_base::seekdir __dir,
                           ios_base::openmode __mode
                                      = ios_base::in | ios_base::out);
  virtual pos_type seekpos(pos_type __pos, ios_base::openmode __mode
                                      = ios_base::in | ios_base::out);

private:                        
  void _M_set_ptrs();
  static _CharT* _S_start(const _String& __str) { return const_cast<_CharT*>(__str.data()); }
  static _CharT* _S_finish(const _String& __str) { return const_cast<_CharT*>(__str.data()) + __str.size(); }

private:
  ios_base::openmode _M_mode;
  _String _M_str;
};






#line 112 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"




template <class _CharT, class _Traits, class _Alloc>
class basic_istringstream : public basic_istream<_CharT, _Traits> {
public:                         
  typedef typename _Traits::char_type   char_type;
  typedef typename _Traits::int_type    int_type;
  typedef typename _Traits::pos_type    pos_type;
  typedef typename _Traits::off_type    off_type;
  typedef _Traits traits_type;

  typedef basic_ios<_CharT, _Traits>                _Basic_ios;
  typedef basic_istream<_CharT, _Traits>            _Base;
  typedef basic_string<_CharT, _Traits, _Alloc>     _String;
  typedef basic_stringbuf<_CharT, _Traits, _Alloc>  _Buf;

public:                         
  basic_istringstream(ios_base::openmode __mode = ios_base::in);
  basic_istringstream(const _String& __str,
                      ios_base::openmode __mode = ios_base::in);
  ~basic_istringstream();

public:                         

  basic_stringbuf<_CharT, _Traits, _Alloc>* rdbuf() const
    { return const_cast<_Buf*>(&_M_buf); }

  _String str() const { return _M_buf.str(); }
  void str(const _String& __s) { _M_buf.str(__s); }

private:
  basic_stringbuf<_CharT, _Traits, _Alloc> _M_buf;






#line 153 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"
};





template <class _CharT, class _Traits, class _Alloc>
class basic_ostringstream : public basic_ostream<_CharT, _Traits> {
public:                         
  typedef typename _Traits::char_type   char_type;
  typedef typename _Traits::int_type    int_type;
  typedef typename _Traits::pos_type    pos_type;
  typedef typename _Traits::off_type    off_type;
  typedef _Traits traits_type;

  typedef basic_ios<_CharT, _Traits>                _Basic_ios;
  typedef basic_ostream<_CharT, _Traits>            _Base;
  typedef basic_string<_CharT, _Traits, _Alloc>     _String;
  typedef basic_stringbuf<_CharT, _Traits, _Alloc>  _Buf;

public:                         
  basic_ostringstream(ios_base::openmode __mode = ios_base::out);
  basic_ostringstream(const _String& __str,
                      ios_base::openmode __mode = ios_base::out);
  ~basic_ostringstream();

public:                         

  basic_stringbuf<_CharT, _Traits, _Alloc>* rdbuf() const
    { return const_cast<_Buf*>(&_M_buf); }

  _String str() const { return _M_buf.str(); }
    void str(const _String& __s) { _M_buf.str(__s); } 


private:
  basic_stringbuf<_CharT, _Traits, _Alloc> _M_buf;






#line 197 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"
};





template <class _CharT, class _Traits, class _Alloc>
class basic_stringstream : public basic_iostream<_CharT, _Traits> {
public:                         
  typedef typename _Traits::char_type char_type;
  typedef typename _Traits::int_type  int_type;
  typedef typename _Traits::pos_type  pos_type;
  typedef typename _Traits::off_type  off_type;
  typedef _Traits  traits_type;

  typedef basic_ios<_CharT, _Traits>                 _Basic_ios;
  typedef basic_iostream<_CharT, _Traits>            _Base;
  typedef basic_string<_CharT, _Traits, _Alloc>      _String;
  typedef basic_stringbuf<_CharT, _Traits, _Alloc>  _Buf;

  typedef ios_base::openmode openmode;

public:                         
  basic_stringstream(openmode __mod = ios_base::in | ios_base::out);
  basic_stringstream(const _String& __str,
                     openmode __mod = ios_base::in | ios_base::out);
  ~basic_stringstream();

public:                         

  basic_stringbuf<_CharT, _Traits, _Alloc>* rdbuf() const
    { return const_cast<_Buf*>(&_M_buf); }

  _String str() const { return _M_buf.str(); }
    void str(const _String& __s) { _M_buf.str(__s); }

private:
  basic_stringbuf<_CharT, _Traits, _Alloc> _M_buf;






#line 242 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"
};











#line 255 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.c"





























#line 31 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.c"


#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.c"

namespace std {







template <class _CharT, class _Traits, class _Alloc>
basic_stringbuf<_CharT, _Traits, _Alloc>
  ::basic_stringbuf(ios_base::openmode __mode)
    : basic_streambuf<_CharT, _Traits>(), _M_mode(__mode), _M_str()
{}

template <class _CharT, class _Traits, class _Alloc>
basic_stringbuf<_CharT, _Traits, _Alloc>
  ::basic_stringbuf(const basic_string<_CharT, _Traits, _Alloc>& __s, ios_base::openmode __mode)
    : basic_streambuf<_CharT, _Traits>(), _M_mode(__mode), _M_str(__s)
{
  _M_set_ptrs();
}

template <class _CharT, class _Traits, class _Alloc>
basic_stringbuf<_CharT, _Traits, _Alloc>::~basic_stringbuf()
{}


template <class _CharT, class _Traits, class _Alloc>
void
basic_stringbuf<_CharT, _Traits, _Alloc>::str(const basic_string<_CharT, _Traits, _Alloc>& __s)
{
  _M_str = __s;
  _M_set_ptrs();
}

template <class _CharT, class _Traits, class _Alloc>
void
basic_stringbuf<_CharT, _Traits, _Alloc>::_M_set_ptrs()
{
  _CharT* __data_ptr = _S_start(_M_str);
  _CharT* __data_end = _S_finish(_M_str);
  
  if (_M_mode & ios_base::in) {
    this->setg(__data_ptr, (_M_mode & ios_base::ate) ? __data_end : __data_ptr, __data_end);
  }

  
  if (_M_mode & ios_base::out) {
    if ( _M_mode & (ios_base::app | ios_base::ate) ) {
      this->setp( __data_end, __data_end );
    } else {
      this->setp( __data_ptr, __data_end );
      this->pbump((int)_M_str.size()); 
    }
    
  }
}


template <class _CharT, class _Traits, class _Alloc>
typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
basic_stringbuf<_CharT, _Traits, _Alloc>::underflow() {
  return this->gptr() != this->egptr()
    ? _Traits::to_int_type(*this->gptr())
    : _Traits::eof();
}


template <class _CharT, class _Traits, class _Alloc>
typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
basic_stringbuf<_CharT, _Traits, _Alloc>::uflow() {
  if (this->gptr() != this->egptr()) {
    int_type __c = _Traits::to_int_type(*this->gptr());
    this->gbump(1);
    return __c;
  }
  else
    return _Traits::eof();
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
basic_stringbuf<_CharT, _Traits, _Alloc>::pbackfail(int_type __c) {
  if (this->gptr() != this->eback()) {
    if (!_Traits::eq_int_type(__c, _Traits::eof())) {
      if (_Traits::eq(_Traits::to_char_type(__c), this->gptr()[-1])) {
        this->gbump(-1);
        return __c;
      }
      else if (_M_mode & ios_base::out) {
        this->gbump(-1);
        *this->gptr() = _Traits::to_char_type(__c);
        return __c;
      }
      else
        return _Traits::eof();
    }
    else {
      this->gbump(-1);
      return _Traits::not_eof(__c);
    }
  }
  else
    return _Traits::eof();
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type basic_stringbuf<_CharT, _Traits, _Alloc>::overflow(int_type __c)
{
  if (!_Traits::eq_int_type(__c, _Traits::eof())) {
    if (_M_mode & ios_base::out) {
      if ( this->pptr() < this->epptr() ) { 
        _M_str.push_back( _Traits::to_char_type(__c) );
        this->pbump(1);
      } else if ( _M_mode & ios_base::in ) {
        ptrdiff_t __offset = this->gptr() - this->eback();
        _M_str.push_back(_Traits::to_char_type(__c));
        _CharT* __data_ptr = _S_start(_M_str);
        this->setg(__data_ptr, __data_ptr + __offset, _S_finish(_M_str));
        this->setp(__data_ptr, _S_finish(_M_str));
        this->pbump((int)_M_str.size());
      } else {
        _M_str.push_back( _Traits::to_char_type(__c) );
        this->setp(_S_start(_M_str), _S_finish(_M_str));
        this->pbump((int)_M_str.size());
      }
      return __c;
    }
    return _Traits::eof(); 
  }
  return _Traits::not_eof(__c); 
}

template <class _CharT, class _Traits, class _Alloc>
streamsize
basic_stringbuf<_CharT, _Traits, _Alloc>::xsputn(const char_type* __s,
                                                 streamsize __n) {
  streamsize __nwritten = 0;

  if ((_M_mode & ios_base::out) && __n > 0) {
    
    
    if ( !_M_str.empty() && this->pbase() == _S_start(_M_str)) {
      ptrdiff_t __avail = _S_finish(_M_str) - this->pptr();
      if (__avail > __n) {
        _Traits::copy(this->pptr(), __s, static_cast<size_t>(__n));
        this->pbump((int)__n);
        return __n;
      } else {
        _Traits::copy(this->pptr(), __s, __avail);
        __nwritten += __avail;
        __n -= __avail;
        __s += __avail;
      }
    }

    
    _CharT* __data_ptr;
    if (_M_mode & ios_base::in) {
      ptrdiff_t __get_offset = this->gptr() - this->eback();
      _M_str.append(__s, __s + static_cast<ptrdiff_t>(__n));
      __data_ptr = _S_start(_M_str);
      this->setg(__data_ptr, __data_ptr + __get_offset, _S_finish(_M_str));
    } else {
      _M_str.append(__s, __s + static_cast<ptrdiff_t>(__n));
      __data_ptr = _S_start(_M_str);
    }

    this->setp(__data_ptr, _S_finish(_M_str));
    this->pbump((int)_M_str.size());
    __nwritten += __n;
  }

  return __nwritten;
}

template <class _CharT, class _Traits, class _Alloc>
streamsize
basic_stringbuf<_CharT, _Traits, _Alloc>::_M_xsputnc(char_type __c,
                                                     streamsize __n) {
  streamsize __nwritten = 0;

  if ((_M_mode & ios_base::out) && __n > 0) {
    
    
    if (this->pbase() == _S_start(_M_str)) {
      ptrdiff_t __avail = _S_finish(_M_str) - this->pptr();
      if (__avail > __n) {
        _Traits::assign(this->pptr(), static_cast<size_t>(__n), __c);
        this->pbump(static_cast<int>(__n));
        return __n;
      }
      else {
        _Traits::assign(this->pptr(), __avail, __c);
        __nwritten += __avail;
        __n -= __avail;
      }
    }

    
    size_t __app_size = sizeof(streamsize) > sizeof(size_t) ? static_cast<size_t>((min)(__n, static_cast<streamsize>(_M_str.max_size())))
                                                            : static_cast<size_t>(__n);
    _CharT* __data_ptr;
    if (this->_M_mode & ios_base::in) {
      ptrdiff_t __get_offset = this->gptr() - this->eback();
      _M_str.append(__app_size, __c);
      __data_ptr = _S_start(_M_str);
      this->setg(__data_ptr, __data_ptr + __get_offset, _S_finish(_M_str));
    } else {
      _M_str.append(__app_size, __c);
      __data_ptr = _S_start(_M_str);
    }

    this->setp(__data_ptr, _S_finish(_M_str));
    this->pbump((int)_M_str.size());
    __nwritten += __app_size;
  }

  return __nwritten;
}





template <class _CharT, class _Traits, class _Alloc>
basic_streambuf<_CharT, _Traits>*
basic_stringbuf<_CharT, _Traits, _Alloc>::setbuf(_CharT*, streamsize __n) {
  if (__n > 0) {
    bool __do_get_area = false;
    bool __do_put_area = false;
    ptrdiff_t __offg = 0;
    ptrdiff_t __offp = 0;

    if (this->pbase() == _S_start(_M_str)) {
      __do_put_area = true;
      __offp = this->pptr() - this->pbase();
    }

    if (this->eback() == _S_start(_M_str)) {
      __do_get_area = true;
      __offg = this->gptr() - this->eback();
    }

    _M_str.reserve(sizeof(streamsize) > sizeof(size_t) ? static_cast<size_t>((min)(__n, static_cast<streamsize>(_M_str.max_size())))
                                                       : static_cast<size_t>(__n));

    _CharT* __data_ptr = _S_start(_M_str);

    if (__do_get_area) {
      this->setg(__data_ptr, __data_ptr + __offg, _S_finish(_M_str));
    }

    if (__do_put_area) {
      this->setp(__data_ptr, _S_finish(_M_str));
      this->pbump((int)__offp);
    }
  }

  return this;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
basic_stringbuf<_CharT, _Traits, _Alloc>
  ::seekoff(off_type __off,
            ios_base::seekdir __dir,
            ios_base::openmode __mode) {
  __mode &= _M_mode;

  bool __imode  = (__mode & ios_base::in) != 0;
  bool __omode = (__mode & ios_base::out) != 0;

  if ( !(__imode || __omode) )
    return pos_type(off_type(-1));

  if ( (__imode && (this->gptr() == 0)) || (__omode && (this->pptr() == 0)) )
    return pos_type(off_type(-1));

  streamoff __newoff;
  switch(__dir) {
    case ios_base::beg:
      __newoff = 0;
      break;
    case ios_base::end:
      __newoff = _M_str.size();
      break;
    case ios_base::cur:
      __newoff = __imode ? this->gptr() - this->eback() : this->pptr() - this->pbase();
      if ( __off == 0 ) {
        return pos_type(__newoff);
      }
      break;
    default:
      return pos_type(off_type(-1));
  }

  __off += __newoff;

  if (__imode) {
    ptrdiff_t __n = this->egptr() - this->eback();

    if (__off < 0 || __off > __n)
      return pos_type(off_type(-1));
    this->setg(this->eback(), this->eback() + static_cast<ptrdiff_t>(__off),
                              this->eback() + static_cast<ptrdiff_t>(__n));
  }

  if (__omode) {
    ptrdiff_t __n = this->epptr() - this->pbase();

    if (__off < 0 || __off > __n)
      return pos_type(off_type(-1));
    this->setp(this->pbase(), this->pbase() + __n);
    this->pbump((int)__off);
  }

  return pos_type(__off);
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
basic_stringbuf<_CharT, _Traits, _Alloc>
  ::seekpos(pos_type __pos, ios_base::openmode __mode) {
  __mode &= _M_mode;

  bool __imode = (__mode & ios_base::in) != 0;
  bool __omode = (__mode & ios_base::out) != 0;

  if ( !(__imode || __omode) )
    return pos_type(off_type(-1));

  if ( (__imode && (this->gptr() == 0)) || (__omode && (this->pptr() == 0)) )
    return pos_type(off_type(-1));

  const off_type __n = __pos - pos_type(off_type(0));

  if (__imode) {
    if (__n < 0 || __n > this->egptr() - this->eback())
      return pos_type(off_type(-1));
    this->setg(this->eback(), this->eback() + static_cast<ptrdiff_t>(__n), this->egptr());
  }

  if (__omode) {
    if (__n < 0 || size_t(__n) > _M_str.size())
      return pos_type(off_type(-1));

    this->setp(_S_start(_M_str), _S_finish(_M_str));
    this->pbump((int)__n);
  }

  return __pos;
}




template <class _CharT, class _Traits, class _Alloc>
basic_istringstream<_CharT, _Traits, _Alloc>
  ::basic_istringstream(ios_base::openmode __mode)
    : basic_istream<_CharT, _Traits>(0),
      _M_buf(__mode | ios_base::in) {
  this->init(&_M_buf);
}

template <class _CharT, class _Traits, class _Alloc>
basic_istringstream<_CharT, _Traits, _Alloc>
  ::basic_istringstream(const _String& __str,ios_base::openmode __mode)
    : basic_istream<_CharT, _Traits>(0),
      _M_buf(__str, __mode | ios_base::in) {
  this->init(&_M_buf);
}

template <class _CharT, class _Traits, class _Alloc>
basic_istringstream<_CharT, _Traits, _Alloc>::~basic_istringstream()
{}




template <class _CharT, class _Traits, class _Alloc>
basic_ostringstream<_CharT, _Traits, _Alloc>
  ::basic_ostringstream(ios_base::openmode __mode)
    : basic_ostream<_CharT, _Traits>(0),
      _M_buf(__mode | ios_base::out) {
  this->init(&_M_buf);
}

template <class _CharT, class _Traits, class _Alloc>
basic_ostringstream<_CharT, _Traits, _Alloc>
  ::basic_ostringstream(const _String& __str, ios_base::openmode __mode)
    : basic_ostream<_CharT, _Traits>(0),
      _M_buf(__str, __mode | ios_base::out) {
  this->init(&_M_buf);
}

template <class _CharT, class _Traits, class _Alloc>
basic_ostringstream<_CharT, _Traits, _Alloc>::~basic_ostringstream()
{}




template <class _CharT, class _Traits, class _Alloc>
basic_stringstream<_CharT, _Traits, _Alloc>
  ::basic_stringstream(ios_base::openmode __mode)
    : basic_iostream<_CharT, _Traits>(0), _M_buf(__mode) {
   this->init(&_M_buf);
}

template <class _CharT, class _Traits, class _Alloc>
basic_stringstream<_CharT, _Traits, _Alloc>
  ::basic_stringstream(const _String& __str, ios_base::openmode __mode)
    : basic_iostream<_CharT, _Traits>(0), _M_buf(__str, __mode) {
  this->init(&_M_buf);
}

template <class _CharT, class _Traits, class _Alloc>
basic_stringstream<_CharT, _Traits, _Alloc>::~basic_stringstream()
{}

}




#line 462 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.c"




#line 260 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"
#line 261 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"

#line 263 "C:\\Pin35\\extras\\stlport\\include\\stl/_sstream.h"




#line 37 "C:\\Pin35\\extras\\stlport\\include\\sstream"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\sstream"
#line 39 "C:\\Pin35\\extras\\stlport\\include\\sstream"







#line 47 "C:\\Pin35\\extras\\stlport\\include\\sstream"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 50 "C:\\Pin35\\extras\\stlport\\include\\sstream"

#line 52 "C:\\Pin35\\extras\\stlport\\include\\sstream"

#line 54 "C:\\Pin35\\extras\\stlport\\include\\sstream"




#line 38 "c:\\pin35\\extras\\components\\include\\util/strings.hpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\iomanip"






















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 





#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 24 "C:\\Pin35\\extras\\stlport\\include\\iomanip"

#line 26 "C:\\Pin35\\extras\\stlport\\include\\iomanip"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_ioserr.h"









#line 11 "C:\\Pin35\\extras\\stlport\\include\\stl/_ioserr.h"

#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/_ioserr.h"
#line 30 "C:\\Pin35\\extras\\stlport\\include\\iomanip"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_iomanip.h"

























namespace std {

namespace priv {





template <class _Arg>
struct _Ios_Manip_1 {
   typedef _Arg (ios_base::*__f_ptr_type)(_Arg);

  _Ios_Manip_1(__f_ptr_type __f, const _Arg& __arg)
    : _M_f(__f), _M_arg(__arg) {}

  void operator()(ios_base& __ios) const
  { (__ios.*_M_f)(_M_arg); }

  __f_ptr_type _M_f;
  _Arg _M_arg;
};


struct _Ios_Setf_Manip {
  ios_base::fmtflags _M_flag;
  ios_base::fmtflags _M_mask;
  bool _M_two_args;

  _Ios_Setf_Manip(ios_base::fmtflags __f)
    : _M_flag(__f), _M_mask(0), _M_two_args(false) {}

  _Ios_Setf_Manip(ios_base::fmtflags __f, ios_base::fmtflags __m)
    : _M_flag(__f), _M_mask(__m), _M_two_args(true) {}

  void operator()(ios_base& __ios) const {
    if (_M_two_args)
      __ios.setf(_M_flag, _M_mask);
    else
      __ios.setf(_M_flag);
  }
};

}

template <class _CharT, class _Traits, class _Arg>
inline basic_istream<_CharT, _Traits>& __cdecl
operator>>(basic_istream<_CharT, _Traits>& __istr,
           const ::std::priv:: _Ios_Manip_1<_Arg>& __f) {
  __f(__istr);
  return __istr;
}

template <class _CharT, class _Traits, class _Arg>
inline basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const ::std::priv:: _Ios_Manip_1<_Arg>& __f) {
  __f(__os);
  return __os;
}

template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>& __cdecl
operator>>(basic_istream<_CharT, _Traits>& __istr,
           const ::std::priv:: _Ios_Setf_Manip& __f) {
  __f(__istr);
  return __istr;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const ::std::priv:: _Ios_Setf_Manip& __f) {
  __f(__os);
  return __os;
}



inline ::std::priv:: _Ios_Setf_Manip __cdecl resetiosflags(ios_base::fmtflags __mask)
{ return ::std::priv:: _Ios_Setf_Manip(0, __mask); }

inline ::std::priv:: _Ios_Setf_Manip __cdecl setiosflags(ios_base::fmtflags __flag)
{ return ::std::priv:: _Ios_Setf_Manip(__flag); }

inline ::std::priv:: _Ios_Setf_Manip __cdecl setbase(int __n) {
  ios_base::fmtflags __base = __n == 8  ? ios_base::oct :
                              __n == 10 ? ios_base::dec :
                              __n == 16 ? ios_base::hex :
                              ios_base::fmtflags(0);
  return ::std::priv:: _Ios_Setf_Manip(__base, ios_base::basefield);
}

inline ::std::priv:: _Ios_Manip_1<streamsize> __cdecl
setprecision(int __n) {
  ::std::priv:: _Ios_Manip_1<streamsize>::__f_ptr_type __f = &ios_base::precision;
  return ::std::priv:: _Ios_Manip_1<streamsize>(__f, __n);
}

inline ::std::priv:: _Ios_Manip_1<streamsize>  __cdecl
setw(int __n) {
  ::std::priv:: _Ios_Manip_1<streamsize>::__f_ptr_type __f = &ios_base::width;  
  return ::std::priv:: _Ios_Manip_1<streamsize>(__f, __n);
}




namespace priv {

template <class _CharT>
struct _Setfill_Manip {
  _Setfill_Manip(_CharT __c) : _M_c(__c) {}
  _CharT _M_c;
};

}

template <class _CharT, class _CharT2, class _Traits>
inline basic_ostream<_CharT, _Traits>& __cdecl
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const ::std::priv:: _Setfill_Manip<_CharT2>& __m) {
  __os.fill(__m._M_c);
  return __os;
}

template <class _CharT, class _CharT2, class _Traits>
inline basic_istream<_CharT, _Traits>& __cdecl
operator>>(basic_istream<_CharT, _Traits>& __is,
           const ::std::priv:: _Setfill_Manip<_CharT2>& __m) {
  __is.fill(__m._M_c);
  return __is;
}

template <class _CharT>
inline ::std::priv:: _Setfill_Manip<_CharT> __cdecl setfill(_CharT __c)
{ return ::std::priv:: _Setfill_Manip<_CharT>(__c); }

}

#line 166 "C:\\Pin35\\extras\\stlport\\include\\stl/_iomanip.h"
#line 33 "C:\\Pin35\\extras\\stlport\\include\\iomanip"
#line 34 "C:\\Pin35\\extras\\stlport\\include\\iomanip"
#line 35 "C:\\Pin35\\extras\\stlport\\include\\iomanip"







#line 43 "C:\\Pin35\\extras\\stlport\\include\\iomanip"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 46 "C:\\Pin35\\extras\\stlport\\include\\iomanip"

#line 48 "C:\\Pin35\\extras\\stlport\\include\\iomanip"

#line 50 "C:\\Pin35\\extras\\stlport\\include\\iomanip"




#line 39 "c:\\pin35\\extras\\components\\include\\util/strings.hpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\cctype"




















#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 





#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 22 "C:\\Pin35\\extras\\stlport\\include\\cctype"
#line 23 "C:\\Pin35\\extras\\stlport\\include\\cctype"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cctype.h"
























#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cctype.h"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"


























#line 28 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"


#line 31 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"



#line 39 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/ctype.h"










































#line 1 "C:\\Pin35\\extras\\crt\\include\\sys/cdefs.h"



































































































































































































































































































































































































































































































































































































#line 44 "C:\\Pin35\\extras\\crt\\include/ctype.h"
#line 1 "C:\\Pin35\\extras\\crt\\include\\xlocale.h"




































#line 45 "C:\\Pin35\\extras\\crt\\include/ctype.h"












extern "C" {

extern const char	*_ctype_;


int	isalnum(int);
int	isalpha(int);
int	iscntrl(int);
int	isdigit(int);
int	isgraph(int);
int	islower(int);
int	isprint(int);
int	ispunct(int);
int	isspace(int);
int	isupper(int);
int	isxdigit(int);
int	tolower(int);
int	toupper(int);

int isalnum_l(int, locale_t);
int isalpha_l(int, locale_t);
int isblank_l(int, locale_t);
int iscntrl_l(int, locale_t);
int isdigit_l(int, locale_t);
int isgraph_l(int, locale_t);
int islower_l(int, locale_t);
int isprint_l(int, locale_t);
int ispunct_l(int, locale_t);
int isspace_l(int, locale_t);
int isupper_l(int, locale_t);
int isxdigit_l(int, locale_t);
int tolower_l(int, locale_t);
int toupper_l(int, locale_t);


int	isblank(int);
#line 95 "C:\\Pin35\\extras\\crt\\include/ctype.h"


int	isascii(int);
int	toascii(int);
int	_tolower(int);
int	_toupper(int);
#line 102 "C:\\Pin35\\extras\\crt\\include/ctype.h"

#line 104 "C:\\Pin35\\extras\\crt\\include/ctype.h"

}

#line 108 "C:\\Pin35\\extras\\crt\\include/ctype.h"
#line 40 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"
#line 41 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"




#line 46 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"





















































#line 100 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"

#line 102 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"








#line 111 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"

#line 113 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"

#line 115 "C:\\Pin35\\extras\\stlport\\include\\ctype.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_cctype.h"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/_cctype.h"



namespace std {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
#line 47 "C:\\Pin35\\extras\\stlport\\include\\stl/_cctype.h"
#line 48 "C:\\Pin35\\extras\\stlport\\include\\stl/_cctype.h"

#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/_cctype.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\cctype"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\cctype"
#line 29 "C:\\Pin35\\extras\\stlport\\include\\cctype"







#line 37 "C:\\Pin35\\extras\\stlport\\include\\cctype"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 40 "C:\\Pin35\\extras\\stlport\\include\\cctype"

#line 42 "C:\\Pin35\\extras\\stlport\\include\\cctype"

#line 44 "C:\\Pin35\\extras\\stlport\\include\\cctype"




#line 40 "c:\\pin35\\extras\\components\\include\\util/strings.hpp"


namespace UTIL {










template<typename T> std::string GetDecString(T val, int width = 0)
{
    std::ostringstream s;
    s << std::dec << std::setfill('0') << std::setw(width) << val;
    return s.str();
}










template<typename T> std::wstring GetDecStringW(T val, int width = 0)
{
    std::wostringstream s;
    s << std::dec << std::setfill(L'0') << std::setw(width) << val;
    return s.str();
}











template<typename T> std::wstring GetHexStringW(T val, bool showBase = true,
    int width = 0)
{
    std::wostringstream s;
    if (showBase)
        s << L"0x";
    s << std::hex << std::noshowbase << std::setfill(L'0') << std::setw(width) << val;
    return s.str();
}











template<typename T> std::string GetHexString(T val, bool showBase = true,
    int width = 0)
{
    std::ostringstream s;
    if (showBase)
        s << "0x";
    s << std::hex << std::noshowbase << std::setfill('0') << std::setw(width) << val;
    return s.str();
}



































template<typename InputIterator, typename T> InputIterator ParseUnsigned(
    InputIterator first, InputIterator last, unsigned base, T *val)
{
    
    
    if (base > 37)
        return first;

    
    
    InputIterator it = first;
    while (it != last && std::isspace(*it))
        it++;
    if (it == last)
        return first;
    InputIterator itAfterWs = it;

    
    
    bool zeroPending = false;
    if (*it == '0')
    {
        zeroPending = true;
        it++;
        if (it == last)
        {
            *val = 0;
            return it;
        }
    }

    
    
    if ((base == 16 || base == 0) && zeroPending && (*it == 'x' || *it == 'X'))
    {
        InputIterator it2 = it++;
        if (it == last || !std::isxdigit(*it))
        {
            
            
            
            *val = 0;
            return it2;
        }
        base = 16;
    }

    if (base == 0)
        base = (zeroPending) ? 8 : 10;

    
    
    T myVal = 0;
    while (it != last)
    {
        char c = std::tolower(*it);
        unsigned digit;
        if (c >= '0' && c <= '9')
            digit = c - '0';
        else if (c >= 'a' && c <= 'z')
            digit = 10 + c - 'a';
        else
            break;
        if (digit >= base)
            break;
        T newVal = myVal * base + digit;

        
        
        if (((newVal - digit) / base) != myVal)
            return first;
        myVal = newVal;
        it++;
    }

    
    
    if (it == itAfterWs)
        return first;
    *val = myVal;
    return it;
}

} 
#line 235 "c:\\pin35\\extras\\components\\include\\util/strings.hpp"
#line 56 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\util/singleton.hpp"






































namespace UTIL {














template <typename T> class  STATIC_SINGLETON
{
public:
    


    static T * GetInstance() 
    {
        if (m_pInstance == 0) 
        {
            m_pInstance = Create();
        }
        return m_pInstance;
    }

private:
    


    static T * Create()
    {
        
        
        
        
        
        
        

        static UINT8 storage[sizeof(T) + __alignof(T)];
        return new((void *)RoundUp(&(storage[0]), __alignof(T))) T();
    }

private:
    static T * m_pInstance;
};





template<typename T> T * STATIC_SINGLETON<T>::m_pInstance = STATIC_SINGLETON<T>::GetInstance();

} 
#line 99 "c:\\pin35\\extras\\components\\include\\util/singleton.hpp"
#line 57 "c:\\pin35\\extras\\components\\include\\util.hpp"

#line 59 "c:\\pin35\\extras\\components\\include\\util.hpp"
#line 38 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"






































namespace ATOMIC {







class  NULLSTATS
{
  public:
    






    void Backoff(UINT32 iterations) {}
};

} 
#line 62 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"
#line 39 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/private/backoff-impl.hpp"





































extern "C" void ATOMIC_SpinDelay(UINT32 delay);

#line 41 "c:\\pin35\\extras\\components\\include\\atomic/private/backoff-impl.hpp"
#line 40 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"


namespace ATOMIC {

























template<typename STATS=NULLSTATS> class  EXPONENTIAL_BACKOFF
{
  public:
    



    EXPONENTIAL_BACKOFF(UINT32 freeIterations = 1, STATS *stats = 0)
    :
        _freeIterations(freeIterations), _iteration(0), _stats(stats)
    {}

    ~EXPONENTIAL_BACKOFF()
    {
        if (_stats && _iteration > _freeIterations)
            _stats->Backoff(_iteration - _freeIterations);
    }

    


    void Reset()
    {
        if (_stats && _iteration > _freeIterations)
            _stats->Backoff(_iteration - _freeIterations);
        _iteration = 0;
    }

    



    void Delay()
    {
        if (_iteration++ < _freeIterations)
            return;

        UINT32 fixed = 1 << (_iteration - 1 - _freeIterations);
        UINT32 mask = fixed - 1;
        UINT32 random = (reinterpret_cast<PTRINT>(&random) >> 4) & mask;
        UINT32 delay = fixed + random;

        ATOMIC_SpinDelay(delay);
    }

    


    UINT32 GetIterationCount()
    {
        return _iteration;
    }

  private:
    const UINT32 _freeIterations; 
    UINT32 _iteration;            
    STATS *_stats;                      
};

} 
#line 129 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
#line 38 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops-enum.hpp"




































namespace ATOMIC {







enum BARRIER_CS
{
    BARRIER_CS_NONE,   
    BARRIER_CS_PREV,   
    BARRIER_CS_NEXT    
};





enum BARRIER_SWAP
{
    BARRIER_SWAP_NONE,   
    BARRIER_SWAP_PREV,   
    BARRIER_SWAP_NEXT    
};




enum BARRIER_ST
{
    BARRIER_ST_NONE,   
    BARRIER_ST_PREV    
};





enum BARRIER_LD
{
    BARRIER_LD_NONE,   
    BARRIER_LD_NEXT    
};

} 
#line 84 "c:\\pin35\\extras\\components\\include\\atomic/ops-enum.hpp"
#line 39 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/private/ops-common-impl.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
































































































































#line 38 "c:\\pin35\\extras\\components\\include\\atomic/private/ops-common-impl.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops-enum.hpp"



















































































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/private/ops-common-impl.hpp"


namespace ATOMIC {







namespace OPS_IMPL
{
    template<unsigned size> static inline void CompareAndSwap(volatile void *location, const void *oldVal,
        void *newVal, BARRIER_CS ignored);

    template<unsigned size> static inline void Load(volatile const void *location, void *val, BARRIER_LD ignored);


    

    template<typename T> inline void SwapByCompareAndSwap(volatile void *location, void *oldVal,
        const void *newVal, BARRIER_SWAP barrier)
    {
        T oldv;
        T newv;
        T val = *static_cast<const T *>(newVal);

        BARRIER_CS myBarrier =
            (barrier == BARRIER_SWAP_NONE) ? BARRIER_CS_NONE :
            (barrier == BARRIER_SWAP_PREV) ? BARRIER_CS_PREV :
            BARRIER_CS_NEXT;

        EXPONENTIAL_BACKOFF<> backoff;
        do
        {
            backoff.Delay();
            Load<sizeof(T)>(location, static_cast<void *>(&oldv), BARRIER_LD_NONE);
            newv = val;
            CompareAndSwap<sizeof(T)>(location, static_cast<const void *>(&oldv), static_cast<void *>(&newv), myBarrier);
        }
        while (newv != oldv);

        *static_cast<T *>(oldVal) = oldv;
    }


    

    template<typename T> static inline void IncrementByCompareAndSwap(volatile void *location,
        const void *inc, void *oldVal, BARRIER_CS barrier)
    {
        T oldv;
        T newv;
        T increment = *static_cast<const T *>(inc);

        EXPONENTIAL_BACKOFF<> backoff;
        do
        {
            backoff.Delay();
            Load<sizeof(T)>(location, static_cast<void *>(&oldv), BARRIER_LD_NONE);
            newv = oldv + increment;
            CompareAndSwap<sizeof(T)>(location, static_cast<const void *>(&oldv), static_cast<void *>(&newv), barrier);
        }
        while (newv != oldv);

        *static_cast<T *>(oldVal) = oldv;
    }
}


} 
#line 111 "c:\\pin35\\extras\\components\\include\\atomic/private/ops-common-impl.hpp"
#line 40 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/private/backoff-impl.hpp"








































#line 41 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"


#line 1 "c:\\pin35\\extras\\components\\include\\atomic/private/ia32/ops-impl.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops-enum.hpp"



















































































#line 38 "c:\\pin35\\extras\\components\\include\\atomic/private/ia32/ops-impl.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/private/ops-common-impl.hpp"














































































































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/private/ia32/ops-impl.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/private/ia32/ops-impl-ia32-asm.hpp"





































extern "C" void ATOMIC_CompareAndSwap8(volatile void *location, const void *oldVal, void *newVal);
extern "C" void ATOMIC_CompareAndSwap16(volatile void *location, const void *oldVal, void *newVal);
extern "C" void ATOMIC_CompareAndSwap32(volatile void *location, const void *oldVal, void *newVal);
extern "C" void ATOMIC_CompareAndSwap64(volatile void *location, const void *oldVal, void *newVal);
extern "C" void ATOMIC_Swap8(volatile void *location, void *oldVal, const void *newVal);
extern "C" void ATOMIC_Swap16(volatile void *location, void *oldVal, const void *newVal);
extern "C" void ATOMIC_Swap32(volatile void *location, void *oldVal, const void *newVal);
extern "C" void ATOMIC_Copy64(volatile const void *from, volatile void *to);
extern "C" void ATOMIC_Increment8(volatile void *location, const void *inc, void *oldVal);
extern "C" void ATOMIC_Increment16(volatile void *location, const void *inc, void *oldVal);
extern "C" void ATOMIC_Increment32(volatile void *location, const void *inc, void *oldVal);

#line 51 "c:\\pin35\\extras\\components\\include\\atomic/private/ia32/ops-impl-ia32-asm.hpp"
#line 40 "c:\\pin35\\extras\\components\\include\\atomic/private/ia32/ops-impl.hpp"


namespace ATOMIC {





namespace OPS_IMPL
{
    

    template<unsigned size> static inline void CompareAndSwap(volatile void *location, const void *oldVal,
        void *newVal, BARRIER_CS ignored);

    template<> inline void CompareAndSwap<1>(volatile void *location, const void *oldVal, void *newVal,
        BARRIER_CS ignored)
    {
        ATOMIC_CompareAndSwap8(location, oldVal, newVal);
    }

    template<> inline void CompareAndSwap<2>(volatile void *location, const void *oldVal, void *newVal,
        BARRIER_CS ignored)
    {
        ATOMIC_CompareAndSwap16(location, oldVal, newVal);
    }

    template<> inline void CompareAndSwap<4>(volatile void *location, const void *oldVal, void *newVal,
        BARRIER_CS ignored)
    {
        ATOMIC_CompareAndSwap32(location, oldVal, newVal);
    }

    template<> inline void CompareAndSwap<8>(volatile void *location, const void *oldVal, void *newVal,
        BARRIER_CS ignored)
    {
        ATOMIC_CompareAndSwap64(location, oldVal, newVal);
    }

    

    template<unsigned size> static inline void Store(volatile void *location, const void *val, BARRIER_ST ignored);

    template<> inline void Store<1>(volatile void *location, const void *val, BARRIER_ST ignored)
    {
        *static_cast<volatile UINT8*>(location) = *static_cast<const UINT8*>(val);
    }

    template<> inline void Store<2>(volatile void *location, const void *val, BARRIER_ST ignored)
    {
        *static_cast<volatile UINT16*>(location) = *static_cast<const UINT16*>(val);
    }

    template<> inline void Store<4>(volatile void *location, const void *val, BARRIER_ST ignored)
    {
        *static_cast<volatile UINT32*>(location) = *static_cast<const UINT32*>(val);
    }

    template<> inline void Store<8>(volatile void *location, const void *val, BARRIER_ST ignored)
    {
        ATOMIC_Copy64(val, location);
    }


    

    template<unsigned size> static inline void Load(volatile const void *location, void *val, BARRIER_LD ignored);

    template<> inline void Load<1>(volatile const void *location, void *val, BARRIER_LD ignored)
    {
        *static_cast<UINT8*>(val) = *static_cast<volatile const UINT8*>(location);
    }

    template<> inline void Load<2>(volatile const void *location, void *val, BARRIER_LD ignored)
    {
        *static_cast<UINT16*>(val) = *static_cast<volatile const UINT16*>(location);
    }

    template<> inline void Load<4>(volatile const void *location, void *val, BARRIER_LD ignored)
    {
        *static_cast<UINT32*>(val) = *static_cast<volatile const UINT32*>(location);
    }

    template<> inline void Load<8>(volatile const void *location, void *val, BARRIER_LD ignored)
    {
        ATOMIC_Copy64(location, val);
    }


    

    template<unsigned size> static inline void Swap(volatile void *location, void *oldVal,
        const void *newVal, BARRIER_SWAP ignored);

    template<> inline void Swap<1>(volatile void *location, void *oldVal, const void *newVal,
        BARRIER_SWAP ignored)
    {
        ATOMIC_Swap8(location, oldVal, newVal);
    }

    template<> inline void Swap<2>(volatile void *location, void *oldVal, const void *newVal,
        BARRIER_SWAP ignored)
    {
        ATOMIC_Swap16(location, oldVal, newVal);
    }

    template<> inline void Swap<4>(volatile void *location, void *oldVal, const void *newVal,
        BARRIER_SWAP ignored)
    {
        ATOMIC_Swap32(location, oldVal, newVal);
    }

    template<> inline void Swap<8>(volatile void *location, void *oldVal, const void *newVal,
        BARRIER_SWAP ignored)
    {
        
        
        SwapByCompareAndSwap<UINT64>(location, oldVal, newVal, ignored);
    }


    

    template<unsigned size> static inline void Increment(volatile void *location, const void *inc,
        void *oldVal, BARRIER_CS ignored);

    template<> inline void Increment<1>(volatile void *location, const void *inc, void *oldVal,
        BARRIER_CS ignored)
    {
        ATOMIC_Increment8(location, inc, oldVal);
    }

    template<> inline void Increment<2>(volatile void *location, const void *inc, void *oldVal,
        BARRIER_CS ignored)
    {
        ATOMIC_Increment16(location, inc, oldVal);
    }

    template<> inline void Increment<4>(volatile void *location, const void *inc, void *oldVal,
        BARRIER_CS ignored)
    {
        ATOMIC_Increment32(location, inc, oldVal);
    }

    template<> inline void Increment<8>(volatile void *location, const void *inc, void *oldVal,
        BARRIER_CS ignored)
    {
        
        
        IncrementByCompareAndSwap<UINT64>(location, inc, oldVal, ignored);
    }
}


} 
#line 196 "c:\\pin35\\extras\\components\\include\\atomic/private/ia32/ops-impl.hpp"
#line 44 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"


#line 47 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"


namespace ATOMIC {




















class  OPS
{
  public:
    











    template<typename T> static T CompareAndSwap(volatile T *location, T oldVal, T newVal,
        BARRIER_CS barrier = BARRIER_CS_NONE)
    {
        OPS_IMPL::CompareAndSwap<sizeof(T)>(static_cast<volatile void*>(location),
            static_cast<const void*>(&oldVal), static_cast<void*>(&newVal), barrier);
        return newVal;
    }

    











    template<typename T> static bool CompareAndDidSwap(volatile T *location, T oldVal, T newVal,
        BARRIER_CS barrier = BARRIER_CS_NONE)
    {
        OPS_IMPL::CompareAndSwap<sizeof(T)>(static_cast<volatile void*>(location),
            static_cast<const void*>(&oldVal), static_cast<void*>(&newVal), barrier);
        return (newVal == oldVal);
    }

    








    template<typename T> static T Swap(volatile T *location, T  newVal,
        BARRIER_SWAP barrier = BARRIER_SWAP_NONE)
    {
        T oldVal;

        OPS_IMPL::Swap<sizeof(T)>(static_cast<volatile void*>(location),
            static_cast<void*>(&oldVal),
            static_cast<const void*>(&newVal),
            barrier);

        return oldVal;
    }

    







    template<typename T> static void Store(volatile T *location, T val, BARRIER_ST barrier = BARRIER_ST_NONE)
    {
        OPS_IMPL::Store<sizeof(T)>(static_cast<volatile void*>(location), static_cast<const void*>(&val), barrier);
    }

    









    template<typename T> static T Load(volatile const T *location, BARRIER_LD barrier = BARRIER_LD_NONE)
    {
        T val;
        OPS_IMPL::Load<sizeof(T)>(static_cast<volatile const void*>(location), static_cast<void*>(&val), barrier);
        return val;
    }

    








    template<typename T> static T Increment(volatile T *location, T inc,
        BARRIER_CS barrier = BARRIER_CS_NONE)
    {
        T oldVal;
        OPS_IMPL::Increment<sizeof(T)>(static_cast<volatile void*>(location), static_cast<const void*>(&inc),
            static_cast<void*>(&oldVal), barrier);
        return oldVal;
    }

    






    template<typename T> static void MaxValue(volatile T *location, T val)
    {
        EXPONENTIAL_BACKOFF<> backoff;

        T oldVal = Load(location);
        while (oldVal < val && !CompareAndDidSwap(location, oldVal, val))
        {
            backoff.Delay();
            oldVal = Load(location);
        }
    }

    





    static void Delay(unsigned delay)
    {
        ATOMIC_SpinDelay(static_cast<UINT32>(delay));
    }
};

} 
#line 216 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"
#line 69 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"





























































#line 63 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"


#line 66 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"

#line 68 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"







#line 76 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"

#line 78 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"
#line 38 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"























































































































































































































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"





























































#line 40 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
































































































































#line 41 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp"


namespace ATOMIC {


















































template<typename ELEMENT, typename HEAP, unsigned int IndexBits, unsigned int CounterBits, typename WORD,
    typename STATS=NULLSTATS>
 class  LIFO_CTR
{
  public:
    





    LIFO_CTR(HEAP *heap, STATS *stats=0) : _heap(heap), _stats(stats)
    {
        do{ if(!(sizeof(_head) == sizeof(_head._word))) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp",   __FUNCTION__   , 107, std::string("") + "assertion failed: " "sizeof(_head) == sizeof(_head._word)" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);

        _head._word = 0;
    }

    




    void SetStatsNonAtomic(STATS *stats)
    {
        _stats = stats;
    }

    




    void Push(ELEMENT *element)
    {
        HEAD oldHead;
        HEAD newHead;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);
        do
        {
            backoff.Delay();

            oldHead._word = OPS::Load(&_head._word);
            element->_next = _heap->Pointer(oldHead._fields._iElement);
            newHead._fields._iElement = _heap->Index(element);
            newHead._fields._counter = oldHead._fields._counter+1;

            
            
        }
        while (!OPS::CompareAndDidSwap(&_head._word, oldHead._word, newHead._word, BARRIER_CS_PREV));
    }

    






    void PushList(ELEMENT *listHead, ELEMENT *listTail)
    {
        HEAD oldHead;
        HEAD newHead;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);
        do
        {
            backoff.Delay();

            oldHead._word = OPS::Load(&_head._word);
            listTail->_next = _heap->Pointer(oldHead._fields._iElement);
            newHead._fields._iElement = _heap->Index(listHead);
            newHead._fields._counter = oldHead._fields._counter+1;

            
            
        }
        while (!OPS::CompareAndDidSwap(&_head._word, oldHead._word, newHead._word, BARRIER_CS_PREV));
    }

    











    ELEMENT *Pop(bool *isEmpty=0, unsigned maxRetries=0)
    {
        HEAD oldHead;
        HEAD newHead;
        ELEMENT *element;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);

        do
        {
            backoff.Delay();

            oldHead._word = OPS::Load(&_head._word);
            if (oldHead._fields._iElement == 0)
            {
                if (isEmpty)
                    *isEmpty = true;
                return 0;
            }

            element = _heap->Pointer(oldHead._fields._iElement);
            newHead._fields._iElement = _heap->Index(element->_next);
            newHead._fields._counter = oldHead._fields._counter+1;
        }
        while (!OPS::CompareAndDidSwap(&_head._word, oldHead._word, newHead._word, BARRIER_CS_NEXT));

        
        

        return element;
    }

    


    ELEMENT *Head()
    {
        HEAD head;
        head._word = OPS::Load(&_head._word);
        return _heap->Pointer(head._fields._iElement);
    }

    


    const ELEMENT *Head() const
    {
        return const_cast<LIFO_CTR*>(this)->Head();
    }

    





    ELEMENT *Clear()
    {
        HEAD oldHead;
        HEAD newHead;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);

        newHead._fields._iElement = 0;
        do
        {
            backoff.Delay();
            oldHead._word = OPS::Load(&_head._word);
            newHead._fields._counter = oldHead._fields._counter+1;
        }
        while (!OPS::CompareAndDidSwap(&_head._word, oldHead._word, newHead._word, BARRIER_CS_NEXT));

        
        

        return _heap->Pointer(oldHead._fields._iElement);
    }

    






    void AssignNonAtomic(ELEMENT *list)
    {
        HEAD newHead;
        newHead._word = 0;
        newHead._fields._iElement = _heap->Index(list);
        _head._word = newHead._word;
    }

  private:

    
    
    
    
    
    union HEAD
    {
        WORD _word;
        struct
        {
            WORD _iElement : IndexBits;     
            WORD _counter : CounterBits;    
        } _fields;
    };
    volatile HEAD _head;

    HEAP *_heap;    
    STATS *_stats;  
};

} 
#line 301 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp"
#line 70 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"













































































#line 38 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"























































































































































































































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/idset.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"























































































































































































































#line 38 "c:\\pin35\\extras\\components\\include\\atomic/idset.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"





























































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/idset.hpp"


namespace ATOMIC {

























template<UINT32 MaxID, typename STATS=NULLSTATS> class  IDSET
{
  public:
    




    IDSET(STATS *stats=0) : _stats(stats)
    {
        for (UINT32 i = 0;  i < _numElements;  i++)
            _bits[i] = 0;

        
        
        
        
        const UINT32 MaxIDMod32 = MaxID % 32;
        if (MaxIDMod32)
            _bits[_numElements-1] = ( (1<<((32-MaxIDMod32)%32)) - 1) << MaxIDMod32;
    }

    




    void SetStatsNonAtomic(STATS *stats)
    {
        _stats = stats;
    }

    





    UINT32 GetID()
    {
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);

        for (UINT32 i = 0;  i < _numElements;  i++)
        {
            UINT32 val = OPS::Load(&_bits[i]);

            while (val != 0xffffffff)
            {
                UINT32 bit = 0;
                for (UINT32 tval = val;  tval & 1;  tval >>= 1)
                    bit++;

                UINT32 newval = val | (1 << bit);
                if (OPS::CompareAndDidSwap(&_bits[i], val, newval))
                    return i*sizeof(UINT32) + bit + 1;

                backoff.Delay();
                val = OPS::Load(&_bits[i]);
            }
        }

        return 0;
    }

    




    void ReleaseID(UINT32 id)
    {
        id--;
        UINT32 i = id >> 5;
        UINT32 bit = 1 << (id & 0x1f);

        UINT32 val;
        UINT32 newval;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);

        do {
            backoff.Delay();
            val = OPS::Load(&_bits[i]);
            newval = val & ~bit;
        } while (!OPS::CompareAndDidSwap(&_bits[i], val, newval));
    }

    




    bool IsIDInUse(UINT32 id)
    {
      id--;
      UINT32 i = id >> 5;
      UINT32 bit = 1 << (id & 0x1f);
      UINT32 val = OPS::Load(&_bits[i]);
      return ((val&bit) != 0);
    }

  private:
    static const UINT32 _numElements = (MaxID + 8*sizeof(UINT32)-1) / (8*sizeof(UINT32));
    volatile UINT32 _bits[_numElements];

    STATS *_stats;  
};

} 
#line 176 "c:\\pin35\\extras\\components\\include\\atomic/idset.hpp"
#line 40 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
































































































































#line 41 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"





























































#line 42 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp"


namespace ATOMIC {




































template<typename ELEMENT, unsigned int LowBits,  
         typename STATS=NULLSTATS> class  LIFO_PTR
{
  public:
    




    LIFO_PTR(STATS *stats=0) : _idGenerator(stats), _stats(stats)
    {
        _head = 0;
    }

    




    void SetStatsNonAtomic(STATS *stats)
    {
        _idGenerator.SetStatsNonAtomic(stats);
        _stats = stats;
    }

    




    void Push(ELEMENT *element)
    {
        
        
        PTRINT intElement = reinterpret_cast<PTRINT>(element);
        do{ if(!(((intElement >> LowBits) << LowBits) == intElement)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp",   __FUNCTION__   , 116, std::string("") + "assertion failed: " "((intElement >> LowBits) << LowBits) == intElement" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);

        PTRINT oldHead;
        PTRINT newHead;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);
        do
        {
            backoff.Delay();

            oldHead = OPS::Load(&_head);
            element->_next = reinterpret_cast<ELEMENT*>((oldHead >> LowBits) << LowBits);   
            newHead = intElement;

            
            
        }
        while (!OPS::CompareAndDidSwap(&_head, oldHead, newHead, BARRIER_CS_PREV));
    }

    






    void PushList(ELEMENT *listHead, ELEMENT *listTail)
    {
        ((void)0);

        PTRINT oldHead;
        PTRINT newHead;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);

        do
        {
            backoff.Delay();

            oldHead = OPS::Load(&_head);
            listTail->_next = reinterpret_cast<ELEMENT*>((oldHead >> LowBits) << LowBits);   
            newHead = reinterpret_cast<PTRINT>(listHead);

            
            
        }
        while (!OPS::CompareAndDidSwap(&_head, oldHead, newHead, BARRIER_CS_PREV));
    }

    

















    ELEMENT *PopInternal(bool *isEmpty=0)
    {
        
        
        
        UINT32 myID;
        if (!(myID = _idGenerator.GetID()))
        {
            if (isEmpty)
                *isEmpty = false;
            return 0;
        }

        PTRINT oldHead;
        PTRINT midHead;
        PTRINT newHead;
        ELEMENT *oldHeadPtr;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);
        do
        {
            PTRINT oldHeadBare;

            
            
            do
            {
                backoff.Delay();
                oldHead = OPS::Load(&_head);
                if (!oldHead)
                {
                    _idGenerator.ReleaseID(myID);
                    if (isEmpty)
                        *isEmpty = true;
                    return 0;
                }

                oldHeadBare = (oldHead >> LowBits) << LowBits;
                midHead = oldHeadBare | myID;
            }
            while (!OPS::CompareAndDidSwap(&_head, oldHead, midHead));

            
            
            
            
            
            
            
            
            
            oldHeadPtr = reinterpret_cast<ELEMENT*>(oldHeadBare);
            newHead = reinterpret_cast<PTRINT>(oldHeadPtr->_next);
        }
        while (!OPS::CompareAndDidSwap(&_head, midHead, newHead, BARRIER_CS_NEXT));

        
        

        _idGenerator.ReleaseID(myID);
        return oldHeadPtr;
    }

    






























    ELEMENT *Pop(bool *isEmpty=0, unsigned maxRetries=0)
    {
        bool isEmptyLocal;
        bool *isEmptyPtr = isEmpty ? isEmpty : &(isEmptyLocal);
        ELEMENT *element = PopInternal(isEmptyPtr);
        if (element)
        {
            return (element);
        }
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);
        unsigned int numTried = 0;
        while (!element && !(*isEmptyPtr) && (numTried<maxRetries))
        {
             numTried++;
             backoff.Delay();
             element = PopInternal(isEmptyPtr);
             if (element)
             {
                 return (element);
             }
        }
        return (0);
    }

    


    ELEMENT *Head()
    {
        PTRINT head = OPS::Load(&_head);
        head = (head >> LowBits) << LowBits;
        return reinterpret_cast<ELEMENT*>(head);
    }

    


    const ELEMENT *Head() const
    {
        return const_cast<LIFO_PTR*>(this)->Head();
    }

    





    ELEMENT *Clear()
    {
        PTRINT oldHead;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);

        do
        {
            backoff.Delay();
            oldHead = OPS::Load(&_head);
        }
        while (!OPS::CompareAndDidSwap<PTRINT>(&_head, oldHead, 0, BARRIER_CS_NEXT));

        
        

        oldHead = (oldHead >> LowBits) << LowBits;
        return reinterpret_cast<ELEMENT*>(oldHead);
    }

    






    void AssignNonAtomic(ELEMENT *list)
    {
        ((void)0);

        _head = reinterpret_cast<PTRINT>(list);
    }

  private:
    








    bool CheckList(ELEMENT *head, ELEMENT *tail)
    {
        ELEMENT *last = 0;
        for (ELEMENT *el = head;  el;  el = el->_next)
        {
            PTRINT intEl = reinterpret_cast<PTRINT>(el);
            if (((intEl >> LowBits) << LowBits) != intEl)
                return false;
            last = el;
        }

        if (tail && tail != last)
            return false;
        return true;
    }

  private:
    volatile PTRINT _head;     

    
    
    
    static const UINT32 MaxID = (1 << LowBits) - 1;
    IDSET<MaxID, STATS> _idGenerator;

    STATS *_stats;  
};

} 
#line 396 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ptr.hpp"
#line 71 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/fixed-lifo.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\util/numberbits.hpp"

































































































#line 38 "c:\\pin35\\extras\\components\\include\\atomic/fixed-lifo.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"













































































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/fixed-lifo.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/lifo-ctr.hpp"












































































































































































































































































































#line 40 "c:\\pin35\\extras\\components\\include\\atomic/fixed-lifo.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"





























































#line 41 "c:\\pin35\\extras\\components\\include\\atomic/fixed-lifo.hpp"


namespace ATOMIC {




































template<typename OBJECT, unsigned int Capacity, unsigned int CounterBits=32, typename STATS=NULLSTATS>
 class  FIXED_LIFO
{
  public:
    


    FIXED_LIFO(STATS *stats=0) : _activeQueue(&_elementHeap, stats), _freeQueue(&_elementHeap, stats)
    {
        ClearNonAtomic();
    }

    




    void SetStatsNonAtomic(STATS *stats)
    {
        _activeQueue.SetStatsNonAtomic(stats);
        _freeQueue.SetStatsNonAtomic(stats);
    }

    


    void ClearNonAtomic()
    {
        unsigned int i = 0;
        for (i = 0;  i+1 < Capacity;  i++)
            _elementHeap._elements[i]._next = &_elementHeap._elements[i+1];
        _elementHeap._elements[i]._next = 0;

        _activeQueue.AssignNonAtomic(0);
        _freeQueue.AssignNonAtomic(&_elementHeap._elements[0]);
    }

    








    FIXED_LIFO& operator=(const FIXED_LIFO &src)
    {
        unsigned int i;

        
        
        for (i = 0;  i < Capacity-1;  i++)
            _elementHeap._elements[i]._next = &_elementHeap._elements[i+1];
        _elementHeap._elements[i]._next = 0;

        
        
        i = 0;
        for (const ELEMENT *element = src._activeQueue.Head();  element;  element = element->_next)
            _elementHeap._elements[i++]._obj = element->_obj;
        if (i > 0)
            _elementHeap._elements[i-1]._next = 0;
        do{ if(!(i <= Capacity)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("c:\\pin35\\extras\\components\\include\\atomic/fixed-lifo.hpp",   __FUNCTION__   , 143, std::string("") + "assertion failed: " "i <= Capacity" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);

        
        
        if (i > 0)
            _activeQueue.AssignNonAtomic(&_elementHeap._elements[0]);
        else
            _activeQueue.AssignNonAtomic(0);

        if (i < Capacity)
            _freeQueue.AssignNonAtomic(&_elementHeap._elements[i]);
        else
            _freeQueue.AssignNonAtomic(0);

        return *this;
    }

    






    bool Push(const OBJECT &userObj)
    {
        ELEMENT *element = _freeQueue.Pop();
        if (!element)
            return false;

        element->_obj = userObj;

        _activeQueue.Push(element);
        return true;
    }

    






    bool Pop(OBJECT *userObj)
    {
        ELEMENT *element = _activeQueue.Pop();
        if (!element)
            return false;

        *userObj = element->_obj;

        _freeQueue.Push(element);
        return true;
    }

    




    bool Empty() const
    {
        const ELEMENT *head = _activeQueue.Head();
        return (head == 0);
    }

    










    template<typename Container> unsigned MoveToContainer(Container *container)
    {
        unsigned count = 0;

        ELEMENT *element = _activeQueue.Clear();
        while (element)
        {
            container->push_back(element->_obj);
            ELEMENT *next = element->_next;
            _freeQueue.Push(element);
            element = next;
            count++;
        }

        return count;
    }

    













    template<typename Container> void CopyPointersToContainerNonAtomic(Container *container) const
    {
        const ELEMENT *element = _activeQueue.Head();
        while (element)
        {
            container->push_back(&element->_obj);
            element = element->_next;
        }
    }

  private:
    struct ELEMENT
    {
        ELEMENT * volatile _next;
        OBJECT _obj;
    };

    struct ELEMENT_HEAP
    {
        UINT32 Index(const ELEMENT *element) const
        {
            if (!element)
                return 0;
            return (element - _elements) + 1;
        }
    
        ELEMENT *Pointer(UINT32 iElement)
        {
            if (!iElement)
                return 0;
            return &_elements[iElement-1];
        }

        ELEMENT _elements[Capacity];
    };

    ELEMENT_HEAP _elementHeap;

    static const UINT32 CapacityBits = UTIL::NUMBER_BITS<Capacity>::count;

    
    
    
    LIFO_CTR<ELEMENT, ELEMENT_HEAP, CapacityBits, CounterBits, UINT64, STATS> _activeQueue;
    LIFO_CTR<ELEMENT, ELEMENT_HEAP, CapacityBits, CounterBits, UINT64, STATS> _freeQueue;
};

} 
#line 300 "c:\\pin35\\extras\\components\\include\\atomic/fixed-lifo.hpp"
#line 72 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/config.hpp"













































































#line 38 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/ops.hpp"























































































































































































































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
































































































































#line 40 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"





























































#line 41 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp"


namespace ATOMIC {









































template<typename KEY, typename OBJECT, KEY InvalidKey1, KEY InvalidKey2,
    unsigned int Capacity, typename STATS=NULLSTATS>
    class  FIXED_MULTIMAP
{
  public:
    




    FIXED_MULTIMAP(STATS *stats=0) : _highWaterMark(0), _freeLocationHint(0), _stats(stats)
    {
        for (UINT32 i = 0;  i < Capacity;  i++)
            _map[i] = KeyAvailable;
    }

    




    void SetStatsNonAtomic(STATS *stats)
    {
        _stats = stats;
    }

    


    void ClearNonAtomic()
    {
        _highWaterMark = 0;
        _freeLocationHint = 0;

        for (UINT32 i = 0;  i < Capacity;  i++)
            _map[i] = KeyAvailable;
    }

    











    OBJECT *Add(KEY key, const OBJECT &userObj)
    {
        do{ if(!(key != KeyAvailable && key != KeyReserved)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp",   __FUNCTION__   , 137, std::string("") + "assertion failed: " "key != KeyAvailable && key != KeyReserved" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);

        UINT32 highWater = OPS::Load(&_highWaterMark);
        UINT32 freeHint = OPS::Load(&_freeLocationHint);

        for (UINT32 i = freeHint;  i < highWater;  i++)
        {
            if (OPS::Load(&_map[i]) == KeyAvailable && AddAt(i, key, userObj))
                return &_objects[i];
        }
        for (UINT32 i = 0;  i < Capacity;  i++)
        {
            if (OPS::Load(&_map[i]) == KeyAvailable && AddAt(i, key, userObj))
                return &_objects[i];
        }
        return 0;
    }

    














    OBJECT *Find(KEY key)
    {
        do{ if(!(key != KeyAvailable && key != KeyReserved)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp",   __FUNCTION__   , 172, std::string("") + "assertion failed: " "key != KeyAvailable && key != KeyReserved" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);

        UINT32 highWater = OPS::Load(&_highWaterMark);
        for (UINT32 i = 0;  i < highWater;  i++)
        {
            
            
            
            
            if (OPS::Load(&_map[i], BARRIER_LD_NEXT) == key)
                return &_objects[i];
        }
        return 0;
    }

    















    template<typename PRED> OBJECT *FindIf(PRED pred)
    {
        UINT32 highWater = OPS::Load(&_highWaterMark);
        for (UINT32 i = 0;  i < highWater;  i++)
        {
            
            
            
            
            KEY key = OPS::Load(&_map[i], BARRIER_LD_NEXT);
            if (key != KeyAvailable && key != KeyReserved)
            {
                if (pred(key))
                    return &_objects[i];
            }
        }
        return 0;
    }

    










    void Remove(KEY key)
    {
        do{ if(!(key != KeyAvailable && key != KeyReserved)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp",   __FUNCTION__   , 235, std::string("") + "assertion failed: " "key != KeyAvailable && key != KeyReserved" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);

        UINT32 highWater = OPS::Load(&_highWaterMark);
        for (UINT32 i = 0;  i < highWater;  i++)
        {
            if (OPS::Load(&_map[i]) == key)
            {
                RemoveAt(i, key);
                return;
            }
        }
    }

    











    template<typename PRED> void RemoveIf(PRED pred)
    {
        UINT32 highWater = OPS::Load(&_highWaterMark);
        for (UINT32 i = 0;  i < highWater;  i++)
        {
            KEY key = OPS::Load(&_map[i]);
            if (key != KeyAvailable && key != KeyReserved)
            {
                if (pred(key))
                    RemoveAt(i, key);
            }
        }
    }

    












    template<typename BINARY> void ForEach(BINARY func)
    {
        UINT32 highWater = OPS::Load(&_highWaterMark);
        for (UINT32 i = 0;  i < highWater;  i++)
        {
            
            
            
            
            KEY key = OPS::Load(&_map[i], BARRIER_LD_NEXT);
            if (key != KeyAvailable && key != KeyReserved)
                func(key, &_objects[i]);
        }
    }

  private:
    



    bool AddAt(UINT32 index, KEY key, const OBJECT &userObj)
    {
        
        
        
        
        
        
        
        
        if (!OPS::CompareAndDidSwap(&_map[index], KeyAvailable, KeyReserved, BARRIER_CS_NEXT))
            return false;

        
        
        
        
        
        
        
        _objects[index] = userObj;
        OPS::Store(&_map[index], key, BARRIER_ST_PREV);

        
        
        
        
        
        UINT32 highWater;
        EXPONENTIAL_BACKOFF<STATS> backoff(1, _stats);
        do
        {
            backoff.Delay();

            
            
            
            
            
            highWater = OPS::Load(&_highWaterMark);
            if (index < highWater)
                break;
        }
        while (!OPS::CompareAndDidSwap(&_highWaterMark, highWater, index+1));

        OPS::CompareAndSwap(&_freeLocationHint, index, index+1);
        return true;
    }

    


    void RemoveAt(UINT32 index, KEY key)
    {
        
        
        if (!OPS::CompareAndDidSwap(&_map[index], key, KeyReserved))
            return;

        do
        {
            
            
            OPS::Store(&_freeLocationHint, index);

            
            
            
            
            
            
            
            
            UINT32 highWater = OPS::Load(&_highWaterMark);
            if (index != highWater-1 || !OPS::CompareAndDidSwap(&_highWaterMark, highWater, index, BARRIER_CS_NEXT))
            {
                OPS::Store(&_map[index], KeyAvailable);
                break;
            }

            
            
            OPS::Store(&_map[index], KeyAvailable);

            
            
            
            if (index == 0)
                break;
            index--;
        }
        while (OPS::CompareAndDidSwap(&_map[index], KeyAvailable, KeyReserved));
    }

  private:
    static const KEY KeyAvailable = InvalidKey1;  
    static const KEY KeyReserved = InvalidKey2;   

    
    
    KEY _map[Capacity];
    OBJECT _objects[Capacity];

    
    
    volatile UINT32 _highWaterMark;

    
    
    volatile UINT32 _freeLocationHint;

    STATS *_stats;  
};

} 
#line 423 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp"
#line 73 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multiset.hpp"




































#line 1 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multimap.hpp"






































































































































































































































































































































































































































#line 38 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multiset.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/nullstats.hpp"





























































#line 39 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multiset.hpp"


namespace ATOMIC {

































template<typename KEY, KEY InvalidKey1, KEY InvalidKey2, unsigned int Capacity, typename STATS=NULLSTATS>
 class  FIXED_MULTISET
{
  public:
    




    FIXED_MULTISET(STATS *stats=0) : _map(stats) {}

    




    void SetStatsNonAtomic(STATS *stats)                  { _map.SetStatsNonAtomic(stats); }

    


    void ClearNonAtomic()                                 { _map.ClearNonAtomic(); }

    




    void Add(KEY key)                                     { _map.Add(key, EMPTY()); }

    











    bool Find(KEY key)                                    { return (_map.Find(key) != 0); }

    












    template<typename PRED> bool FindIf(PRED pred)        { return (_map.FindIf(pred) != 0); }

    









    void Remove(KEY key)                                  { _map.Remove(key); }

    











    template<typename PRED> void RemoveIf(PRED pred)      { _map.RemoveIf(pred); }

  private:
    struct EMPTY {};
    FIXED_MULTIMAP<KEY, EMPTY, InvalidKey1, InvalidKey2, Capacity, STATS> _map;
};

} 
#line 167 "c:\\pin35\\extras\\components\\include\\atomic/fixed-multiset.hpp"
#line 74 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/idset.hpp"















































































































































































#line 75 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 1 "c:\\pin35\\extras\\components\\include\\atomic/exponential-backoff.hpp"
































































































































#line 76 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"

#line 78 "C:\\Pin35\\extras\\components\\include\\atomic.hpp"
#line 96 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\pinsync.hpp"




































#line 1 "C:\\Pin35\\extras\\crt\\include\\os-apis.h"

















































#line 38 "C:\\Pin35\\source\\include\\pin\\gen\\pinsync.hpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\map"





























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 





#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 31 "C:\\Pin35\\extras\\stlport\\include\\map"

#line 33 "C:\\Pin35\\extras\\stlport\\include\\map"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"








































































namespace std {

namespace priv {

typedef bool _Rb_tree_Color_type;






struct _Rb_tree_node_base {
  typedef _Rb_tree_Color_type _Color_type;
  typedef _Rb_tree_node_base* _Base_ptr;

  _Color_type _M_color;
  _Base_ptr _M_parent;
  _Base_ptr _M_left;
  _Base_ptr _M_right;

  static _Base_ptr __cdecl _S_minimum(_Base_ptr __x) {
    while (__x->_M_left != 0) __x = __x->_M_left;
    return __x;
  }

  static _Base_ptr __cdecl _S_maximum(_Base_ptr __x) {
    while (__x->_M_right != 0) __x = __x->_M_right;
    return __x;
  }
};

template <class _Value>
struct _Rb_tree_node : public _Rb_tree_node_base {
  _Value _M_value_field;
   
};

struct _Rb_tree_base_iterator;

template <class _Dummy>
class _Rb_global {
public:
  typedef _Rb_tree_node_base* _Base_ptr;
  
  static void __cdecl _Rebalance(_Base_ptr __x, _Base_ptr& __root);
  static _Base_ptr __cdecl _Rebalance_for_erase(_Base_ptr __z,
                                                   _Base_ptr& __root,
                                                   _Base_ptr& __leftmost,
                                                   _Base_ptr& __rightmost);
  
  
  static _Base_ptr  __cdecl _M_increment (_Base_ptr);
  static _Base_ptr  __cdecl _M_decrement (_Base_ptr);
  static void       __cdecl _Rotate_left (_Base_ptr __x, _Base_ptr& __root);
  static void       __cdecl _Rotate_right(_Base_ptr __x, _Base_ptr& __root);
};



#line 133 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

typedef _Rb_global<bool> _Rb_global_inst;

struct _Rb_tree_base_iterator {
  typedef _Rb_tree_node_base*        _Base_ptr;
  typedef bidirectional_iterator_tag iterator_category;
  typedef ptrdiff_t                  difference_type;
  _Base_ptr _M_node;
  _Rb_tree_base_iterator() : _M_node(0) {}
  _Rb_tree_base_iterator(_Base_ptr __x) : _M_node(__x) {}
};

template <class _Value, class _Traits>
struct _Rb_tree_iterator : public _Rb_tree_base_iterator {
  typedef _Value value_type;
  typedef typename _Traits::reference  reference;
  typedef typename _Traits::pointer    pointer;
  typedef _Rb_tree_iterator<_Value, _Traits> _Self;
  typedef _Rb_tree_node_base*    _Base_ptr;
  typedef _Rb_tree_node<_Value>* _Link_type;

  typedef typename _Traits::_NonConstTraits _NonConstTraits;
  typedef _Rb_tree_iterator<_Value, _NonConstTraits> iterator;
  typedef typename _Traits::_ConstTraits _ConstTraits;
  typedef _Rb_tree_iterator<_Value, _ConstTraits> const_iterator;

  _Rb_tree_iterator() {}

  


  explicit
#line 166 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"
  _Rb_tree_iterator(_Base_ptr __x) : _Rb_tree_base_iterator(__x) {}
  
  _Rb_tree_iterator(const iterator& __it) : _Rb_tree_base_iterator(__it._M_node) {}

  reference operator*() const {
    return static_cast<_Link_type>(_M_node)->_M_value_field;
  }

  pointer operator->() const { return &(operator*()); }

  _Self& operator++() {
    _M_node = _Rb_global_inst::_M_increment(_M_node);
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    ++(*this);
    return __tmp;
  }

  _Self& operator--() {
    _M_node = _Rb_global_inst::_M_decrement(_M_node);
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    --(*this);
    return __tmp;
  }

  bool operator == (const_iterator __rhs) const {
    return _M_node == __rhs._M_node;
  }
  bool operator != (const_iterator __rhs) const {
    return _M_node != __rhs._M_node;
  }
};


}
template <class _Value, class _Traits>
struct __type_traits<::std::priv:: _Rb_tree_iterator<_Value, _Traits> > {
  typedef __false_type   has_trivial_default_constructor;
  typedef __true_type    has_trivial_copy_constructor;
  typedef __true_type    has_trivial_assignment_operator;
  typedef __true_type    has_trivial_destructor;
  typedef __false_type   is_POD_type;
};
namespace priv {
#line 216 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"











#line 228 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"



template <class _Tp, class _Alloc>
class _Rb_tree_base {
public:
  typedef _Rb_tree_node_base _Node_base;
  typedef _Rb_tree_node<_Tp> _Node;
  
  typedef _Alloc allocator_type;
private:
  typedef _Rb_tree_base<_Tp, _Alloc> _Self;
  typedef typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator_type;
  typedef _STLP_alloc_proxy<_Node_base, _Node, _M_node_allocator_type> _AllocProxy;

public:
  allocator_type get_allocator() const {
    return _M_header;
  }

protected:
  _Rb_tree_base(const allocator_type& __a) :
    _M_header(__a, _Node_base() ) {
    _M_empty_initialize();
  }


  _Rb_tree_base(__move_source<_Self> src) :
    _M_header(__move_source<_AllocProxy>(src.get()._M_header)) {
    _M_rebind(&src.get()._M_header._M_data);
    src.get()._M_empty_initialize();
  }
#line 261 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

  void _M_empty_initialize() {
    _M_header._M_data._M_color = false; 
                                                 
    _M_header._M_data._M_parent = 0;
    _M_header._M_data._M_left = &_M_header._M_data;
    _M_header._M_data._M_right = &_M_header._M_data;
  }

  void _M_rebind(_Node_base *__static_node) {
    if (_M_header._M_data._M_parent != 0) {
      _M_header._M_data._M_parent->_M_parent = &_M_header._M_data;
    }
    if (_M_header._M_data._M_right == __static_node) {
      _M_header._M_data._M_right = &_M_header._M_data;
    }
    if (_M_header._M_data._M_left == __static_node) {
      _M_header._M_data._M_left = &_M_header._M_data;
    }
  }

  _AllocProxy _M_header;
};



#line 288 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits,
          class _Alloc = allocator<_Value> >
class _Rb_tree : public _Rb_tree_base<_Value, _Alloc> {
  typedef _Rb_tree_base<_Value, _Alloc> _Base;
  typedef _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc> _Self;
protected:
  typedef _Rb_tree_node_base * _Base_ptr;
  typedef _Rb_tree_node<_Value> _Node;
  typedef _Node* _Link_type;
  typedef _Rb_tree_Color_type _Color_type;
public:
  typedef _Key key_type;
  typedef _Value value_type;
  typedef typename _Traits::pointer pointer;
  typedef const value_type* const_pointer;
  typedef typename _Traits::reference reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef bidirectional_iterator_tag _Iterator_category;
  typedef typename _Base::allocator_type allocator_type;

protected:

  typedef key_type _KT;
  _Base_ptr _M_create_node(const value_type& __x) {
    _Link_type __tmp = this->_M_header.allocate(1);
     {
      _Copy_Construct(&__tmp->_M_value_field, __x);
    }
    
    _S_left(__tmp) = 0;
    _S_right(__tmp) = 0;
    return __tmp;
  }

  _Base_ptr _M_clone_node(_Base_ptr __x) {
    _Base_ptr __tmp = _M_create_node(_S_value(__x));
    _S_color(__tmp) = _S_color(__x);
    return __tmp;
  }

  size_type _M_node_count; 
  _Compare _M_key_compare;

  _Base_ptr _M_root() const
  { return this->_M_header._M_data._M_parent; }
  _Base_ptr _M_leftmost() const
  { return this->_M_header._M_data._M_left; }
  _Base_ptr _M_rightmost() const
  { return this->_M_header._M_data._M_right; }

  _Base_ptr& _M_root()
  { return this->_M_header._M_data._M_parent; }
  _Base_ptr& _M_leftmost()
  { return this->_M_header._M_data._M_left; }
  _Base_ptr& _M_rightmost()
  { return this->_M_header._M_data._M_right; }

  static _Base_ptr& __cdecl _S_left(_Base_ptr __x)
  { return __x->_M_left; }
  static _Base_ptr& __cdecl _S_right(_Base_ptr __x)
  { return __x->_M_right; }
  static _Base_ptr& __cdecl _S_parent(_Base_ptr __x)
  { return __x->_M_parent; }
  static value_type& __cdecl _S_value(_Base_ptr __x)
  { return static_cast<_Link_type>(__x)->_M_value_field; }
  static const _Key& __cdecl _S_key(_Base_ptr __x)
  { return _KeyOfValue()(_S_value(__x));}
  static _Color_type& __cdecl _S_color(_Base_ptr __x)
  { return (_Color_type&)(__x->_M_color); }

  static _Base_ptr __cdecl _S_minimum(_Base_ptr __x)
  { return _Rb_tree_node_base::_S_minimum(__x); }

  static _Base_ptr __cdecl _S_maximum(_Base_ptr __x)
  { return _Rb_tree_node_base::_S_maximum(__x); }

public:
  typedef typename _Traits::_NonConstTraits _NonConstTraits;
  typedef typename _Traits::_ConstTraits _ConstTraits;
  typedef _Rb_tree_iterator<value_type, _NonConstTraits> iterator;
  typedef _Rb_tree_iterator<value_type, _ConstTraits> const_iterator;
  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;

private:
  iterator _M_insert(_Base_ptr __parent, const value_type& __val, _Base_ptr __on_left = 0, _Base_ptr __on_right = 0);
  _Base_ptr _M_copy(_Base_ptr __x, _Base_ptr __p);
  void _M_erase(_Base_ptr __x);

public:
                                
  _Rb_tree()
    : _Rb_tree_base<_Value, _Alloc>(allocator_type()), _M_node_count(0), _M_key_compare(_Compare())
    {}

  _Rb_tree(const _Compare& __comp)
    : _Rb_tree_base<_Value, _Alloc>(allocator_type()), _M_node_count(0), _M_key_compare(__comp)
    {}

  _Rb_tree(const _Compare& __comp, const allocator_type& __a)
    : _Rb_tree_base<_Value, _Alloc>(__a), _M_node_count(0), _M_key_compare(__comp)
    {}

  _Rb_tree(const _Self& __x)
    : _Rb_tree_base<_Value, _Alloc>(__x.get_allocator()),
      _M_node_count(0), _M_key_compare(__x._M_key_compare) {
    if (__x._M_root() != 0) {
      _S_color(&this->_M_header._M_data) = false;
      _M_root() = _M_copy(__x._M_root(), &this->_M_header._M_data);
      _M_leftmost() = _S_minimum(_M_root());
      _M_rightmost() = _S_maximum(_M_root());
    }
    _M_node_count = __x._M_node_count;
  }


  _Rb_tree(__move_source<_Self> src)
    : _Rb_tree_base<_Value, _Alloc>(__move_source<_Base>(src.get())),
      _M_node_count(src.get()._M_node_count),
      _M_key_compare(_AsMoveSource(src.get()._M_key_compare))
  { src.get()._M_node_count = 0; }
#line 413 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

  ~_Rb_tree() { clear(); }
  _Self& operator=(const _Self& __x);

public:
                                
  _Compare key_comp() const { return _M_key_compare; }

  iterator begin() { return iterator(_M_leftmost()); }
  const_iterator begin() const { return const_iterator(_M_leftmost()); }
  iterator end() { return iterator(&this->_M_header._M_data); }
  const_iterator end() const { return const_iterator(const_cast<_Base_ptr>(&this->_M_header._M_data)); }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const
  { return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const
  { return const_reverse_iterator(begin()); }
  bool empty() const { return _M_node_count == 0; }
  size_type size() const { return _M_node_count; }
  size_type max_size() const { return size_type(-1); }

  void swap(_Self& __t) {
    if (__t.empty()) {
      if (this->empty()) return;
      __t._M_header.swap(this->_M_header);
      __t._M_rebind(&this->_M_header._M_data);
      this->_M_empty_initialize();
    }
    else if (this->empty()) {
      __t.swap(*this);
      return;
    }
    else {
      this->_M_header.swap(__t._M_header);
      this->_M_rebind(&__t._M_header._M_data);
      __t._M_rebind(&this->_M_header._M_data);
    }
    ::std::swap(_M_node_count, __t._M_node_count);
    ::std::swap(_M_key_compare, __t._M_key_compare);
  }

public:
                                
  pair<iterator,bool> insert_unique(const value_type& __x);
  iterator insert_equal(const value_type& __x);

  iterator insert_unique(iterator __pos, const value_type& __x);
  iterator insert_equal(iterator __pos, const value_type& __x);


  template<class _II> void insert_equal(_II __first, _II __last) {
    for ( ; __first != __last; ++__first)
      insert_equal(*__first);
  }
  template<class _II> void insert_unique(_II __first, _II __last) {
    for ( ; __first != __last; ++__first)
      insert_unique(*__first);
  }

















#line 491 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

  void erase(iterator __pos) {
    _Base_ptr __x = _Rb_global_inst::_Rebalance_for_erase(__pos._M_node,
                                                          this->_M_header._M_data._M_parent,
                                                          this->_M_header._M_data._M_left,
                                                          this->_M_header._M_data._M_right);
    ::std::_Destroy(&_S_value(__x));
    this->_M_header.deallocate(static_cast<_Link_type>(__x), 1);
    --_M_node_count;
  }

  size_type erase(const key_type& __x) {
    pair<iterator,iterator> __p = equal_range(__x);
    size_type __n = ::std::distance(__p.first, __p.second);
    erase(__p.first, __p.second);
    return __n;
  }

  size_type erase_unique(const key_type& __x) {
    iterator __i = find(__x);
    if (__i._M_node != &this->_M_header._M_data) {
      erase(__i);
      return 1;
    }
    return 0;
  }

  void erase(iterator __first, iterator __last) {
    if (__first._M_node == this->_M_header._M_data._M_left && 
        __last._M_node == &this->_M_header._M_data)           
      clear();
    else
      while (__first != __last) erase(__first++);
  }

  void erase(const key_type* __first, const key_type* __last) {
    while (__first != __last) erase(*__first++);
  }

  void clear() {
    if (_M_node_count != 0) {
      _M_erase(_M_root());
      _M_leftmost() = &this->_M_header._M_data;
      _M_root() = 0;
      _M_rightmost() = &this->_M_header._M_data;
      _M_node_count = 0;
    }
  }

public:
                                
  
  iterator find(const _KT& __k) { return iterator(_M_find(__k)); }
  
  const_iterator find(const _KT& __k) const { return const_iterator(_M_find(__k)); }
private:
  
  _Base_ptr _M_find(const _KT& __k) const {
    _Base_ptr __y = const_cast<_Base_ptr>(&this->_M_header._M_data);      
    _Base_ptr __x = _M_root();      

    while (__x != 0)
      if (!_M_key_compare(_S_key(__x), __k))
        __y = __x, __x = _S_left(__x);
      else
        __x = _S_right(__x);

    if (__y != &this->_M_header._M_data) {
      if (_M_key_compare(__k, _S_key(__y))) {
        __y = const_cast<_Base_ptr>(&this->_M_header._M_data);
      }
    }
    return __y;
  }

  
  _Base_ptr _M_lower_bound(const _KT& __k) const {
    _Base_ptr __y = const_cast<_Base_ptr>(&this->_M_header._M_data); 
    _Base_ptr __x = _M_root(); 

    while (__x != 0)
      if (!_M_key_compare(_S_key(__x), __k))
        __y = __x, __x = _S_left(__x);
      else
        __x = _S_right(__x);

    return __y;
  }

  
  _Base_ptr _M_upper_bound(const _KT& __k) const {
    _Base_ptr __y = const_cast<_Base_ptr>(&this->_M_header._M_data); 
    _Base_ptr __x = _M_root(); 

    while (__x != 0)
      if (_M_key_compare(__k, _S_key(__x)))
        __y = __x, __x = _S_left(__x);
      else
        __x = _S_right(__x);

    return __y;
  }

public:
  
  size_type count(const _KT& __x) const {
    pair<const_iterator, const_iterator> __p = equal_range(__x);
    return ::std::distance(__p.first, __p.second);
  }
  
  iterator lower_bound(const _KT& __x) { return iterator(_M_lower_bound(__x)); }
  
  const_iterator lower_bound(const _KT& __x) const { return const_iterator(_M_lower_bound(__x)); }
  
  iterator upper_bound(const _KT& __x) { return iterator(_M_upper_bound(__x)); }
  
  const_iterator upper_bound(const _KT& __x) const { return const_iterator(_M_upper_bound(__x)); }
  
  pair<iterator,iterator> equal_range(const _KT& __x)
  { return pair<iterator, iterator>(lower_bound(__x), upper_bound(__x)); }
  
  pair<const_iterator, const_iterator> equal_range(const _KT& __x) const
  { return pair<const_iterator, const_iterator>(lower_bound(__x), upper_bound(__x)); }
  
  pair<iterator,iterator> equal_range_unique(const _KT& __x) {
    pair<iterator, iterator> __p;
    __p.second = lower_bound(__x);
    if (__p.second._M_node != &this->_M_header._M_data &&
        !_M_key_compare(__x, _S_key(__p.second._M_node))) {
      __p.first = __p.second++;
    }
    else {
      __p.first = __p.second;
    }
    return __p;
  }
  
  pair<const_iterator, const_iterator> equal_range_unique(const _KT& __x) const {
    pair<const_iterator, const_iterator> __p;
    __p.second = lower_bound(__x);
    if (__p.second._M_node != &this->_M_header._M_data &&
        !_M_key_compare(__x, _S_key(__p.second._M_node))) {
      __p.first = __p.second++;
    }
    else {
      __p.first = __p.second;
    }
    return __p;
  }





#line 646 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"
};



#line 651 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

}

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.c"







































#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.c"







#line 49 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.c"


#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.c"

namespace std {

namespace priv {



































































































































































































































































#line 316 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.c"


template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>&
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::operator=(
  const _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x) {
  if (this != &__x) {
    
    clear();
    _M_node_count = 0;
    _M_key_compare = __x._M_key_compare;
    if (__x._M_root() == 0) {
      _M_root() = 0;
      _M_leftmost() = &this->_M_header._M_data;
      _M_rightmost() = &this->_M_header._M_data;
    }
    else {
      _M_root() = _M_copy(__x._M_root(), &this->_M_header._M_data);
      _M_leftmost() = _S_minimum(_M_root());
      _M_rightmost() = _S_maximum(_M_root());
      _M_node_count = __x._M_node_count;
    }
  }
  return *this;
}





template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::_M_insert(_Rb_tree_node_base * __parent,
                                                                      const _Value& __val,
                                                                      _Rb_tree_node_base * __on_left,
                                                                      _Rb_tree_node_base * __on_right) {
  
  
  _Base_ptr __new_node;

  if ( __parent == &this->_M_header._M_data ) {
    __new_node = _M_create_node(__val);
    _S_left(__parent) = __new_node;   
    _M_root() = __new_node;
    _M_rightmost() = __new_node;
  }
  else if ( __on_right == 0 &&     
           ( __on_left != 0 ||     
             _M_key_compare( _KeyOfValue()(__val), _S_key(__parent) ) ) ) {
    __new_node = _M_create_node(__val);
    _S_left(__parent) = __new_node;
    if (__parent == _M_leftmost())
      _M_leftmost() = __new_node;   
  }
  else {
    __new_node = _M_create_node(__val);
    _S_right(__parent) = __new_node;
    if (__parent == _M_rightmost())
      _M_rightmost() = __new_node;  
  }
  _S_parent(__new_node) = __parent;
  _Rb_global_inst::_Rebalance(__new_node, this->_M_header._M_data._M_parent);
  ++_M_node_count;
  return iterator(__new_node);
}

template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_equal(const _Value& __val) {
  _Base_ptr __y = &this->_M_header._M_data;
  _Base_ptr __x = _M_root();
  while (__x != 0) {
    __y = __x;
    if (_M_key_compare(_KeyOfValue()(__val), _S_key(__x))) {
      __x = _S_left(__x);
    }
    else
      __x = _S_right(__x);
  }
  return _M_insert(__y, __val, __x);
}


template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
pair<typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator, bool>
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_unique(const _Value& __val) {
  _Base_ptr __y = &this->_M_header._M_data;
  _Base_ptr __x = _M_root();
  bool __comp = true;
  while (__x != 0) {
    __y = __x;
    __comp = _M_key_compare(_KeyOfValue()(__val), _S_key(__x));
    __x = __comp ? _S_left(__x) : _S_right(__x);
  }
  iterator __j = iterator(__y);
  if (__comp) {
    if (__j == begin())
      return pair<iterator,bool>(_M_insert(__y, __val,  __y), true);
    else
      --__j;
  }
  if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__val))) {
    return pair<iterator,bool>(_M_insert(__y, __val, __x), true);
  }
  return pair<iterator,bool>(__j, false);
}



template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_unique(iterator __position,
                                                                          const _Value& __val) {
  if (__position._M_node == this->_M_header._M_data._M_left) { 

    
    if (empty())
      return insert_unique(__val).first;

    if (_M_key_compare(_KeyOfValue()(__val), _S_key(__position._M_node))) {
      return _M_insert(__position._M_node, __val, __position._M_node);
    }
    
    else {
      bool __comp_pos_v = _M_key_compare( _S_key(__position._M_node), _KeyOfValue()(__val) );

      if (__comp_pos_v == false)  
        return __position;
      

      
      
      iterator __after = __position;
      ++__after;

      
      
      if (__after._M_node == &this->_M_header._M_data)
        
        
        
        return _M_insert(__position._M_node, __val, 0, __position._M_node);

      

      
      
      if (_M_key_compare( _KeyOfValue()(__val), _S_key(__after._M_node) )) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      }
      else {
        return insert_unique(__val).first;
      }
    }
  }
  else if (__position._M_node == &this->_M_header._M_data) { 
    if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__val))) {
        
        
        return _M_insert(_M_rightmost(), __val, 0, __position._M_node); 
    }
    else
      return insert_unique(__val).first;
  }
  else {
    iterator __before = __position;
    --__before;

    bool __comp_v_pos = _M_key_compare(_KeyOfValue()(__val), _S_key(__position._M_node));

    if (__comp_v_pos
        && _M_key_compare( _S_key(__before._M_node), _KeyOfValue()(__val) )) {

      if (_S_right(__before._M_node) == 0)
        return _M_insert(__before._M_node, __val, 0, __before._M_node); 
      else
        return _M_insert(__position._M_node, __val, __position._M_node);
      
    }
    else {
      
      iterator __after = __position;
      ++__after;
      
      bool __comp_pos_v = !__comp_v_pos;  
      
      
      
      
      if (!__comp_v_pos) {
        __comp_pos_v = _M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__val));
      }

      if ( (!__comp_v_pos) 
          && __comp_pos_v
          && (__after._M_node == &this->_M_header._M_data ||
              _M_key_compare( _KeyOfValue()(__val), _S_key(__after._M_node) ))) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      } else {
        
        if (__comp_v_pos == __comp_pos_v)
          return __position;
        else
          return insert_unique(__val).first;
      }
    }
  }
}

template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_equal(iterator __position,
                                                                         const _Value& __val) {
  if (__position._M_node == this->_M_header._M_data._M_left) { 

    
    if (size() <= 0)
        return insert_equal(__val);

    if (!_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__val)))
      return _M_insert(__position._M_node, __val, __position._M_node);
    else {
      
      if (__position._M_node->_M_left == __position._M_node)
        
        return _M_insert(__position._M_node, __val);

      
      
      
      iterator __after = __position;
      ++__after;

      
      
      
      
      if ( __after._M_node == &this->_M_header._M_data ||
           !_M_key_compare( _S_key(__after._M_node), _KeyOfValue()(__val) ) ) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      }
      else { 
        return insert_equal(__val);
      }
    }
  }
  else if (__position._M_node == &this->_M_header._M_data) { 
    if (!_M_key_compare(_KeyOfValue()(__val), _S_key(_M_rightmost())))
      return _M_insert(_M_rightmost(), __val, 0, __position._M_node); 
    else {
      return insert_equal(__val);
    }
  }
  else {
    iterator __before = __position;
    --__before;
    
    
    
    
    
    bool __comp_pos_v = _M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__val));
    if (!__comp_pos_v &&
        !_M_key_compare(_KeyOfValue()(__val), _S_key(__before._M_node))) {
      if (_S_right(__before._M_node) == 0)
        return _M_insert(__before._M_node, __val, 0, __before._M_node); 
      else
        return _M_insert(__position._M_node, __val, __position._M_node);
    }
    else {
      
      
      iterator __after = __position;
      ++__after;

      if (__comp_pos_v &&
          ( __after._M_node == &this->_M_header._M_data ||
            !_M_key_compare( _S_key(__after._M_node), _KeyOfValue()(__val) ) ) ) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      }
      else { 
        return insert_equal(__val);
      }
    }
  }
}

template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
_Rb_tree_node_base*
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::_M_copy(_Rb_tree_node_base* __x,
                                                                    _Rb_tree_node_base* __p) {
  
  _Base_ptr __top = _M_clone_node(__x);
  _S_parent(__top) = __p;

   {
    if (_S_right(__x))
      _S_right(__top) = _M_copy(_S_right(__x), __top);
    __p = __top;
    __x = _S_left(__x);

    while (__x != 0) {
      _Base_ptr __y = _M_clone_node(__x);
      _S_left(__p) = __y;
      _S_parent(__y) = __p;
      if (_S_right(__x))
        _S_right(__y) = _M_copy(_S_right(__x), __y);
      __p = __y;
      __x = _S_left(__x);
    }
  }
  

  return __top;
}


template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
void
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>::_M_erase(_Rb_tree_node_base *__x) {
  
  while (__x != 0) {
    _M_erase(_S_right(__x));
    _Base_ptr __y = _S_left(__x);
    ::std::_Destroy(&_S_value(__x));
    this->_M_header.deallocate(static_cast<_Link_type>(__x),1);
    __x = __y;
  }
}



















































#line 717 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.c"

}
}






#line 727 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.c"




#line 658 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"
#line 659 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"



#line 663 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

namespace std {



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"





template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
inline bool __cdecl operator==(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x,
                                  const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}
#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"

template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
inline bool __cdecl operator<(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x,
                                 const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool __cdecl operator!=(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {return !(__x == __y);}template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool __cdecl operator>(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {return __y < __x;}template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool __cdecl operator<=(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) { return !(__y < __x);}template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool __cdecl operator>=(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) { return !(__x < __y);}


template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
inline void __cdecl swap(::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x,
                            ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {
  __x.swap(__y);
}
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"
#line 669 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"




template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
struct __move_traits<::std::priv:: _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc> >
  : ::std::priv:: __move_traits_help2<_Compare, _Alloc> {};
#line 677 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"

}

#line 681 "C:\\Pin35\\extras\\stlport\\include\\stl/_tree.h"




#line 35 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"
#line 36 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

namespace std {


namespace priv { template <class _Tp> struct _MapTraitsT; template <class _Tp> struct _ConstMapTraitsT : public ::std::_Const_traits<_Tp> { typedef _ConstMapTraitsT<_Tp> _ConstTraits; typedef _MapTraitsT<_Tp> _NonConstTraits; }; template <class _Tp> struct _MapTraitsT : public ::std::_Nonconst_traits<_Tp> { typedef _ConstMapTraitsT<_Tp> _ConstTraits; typedef _MapTraitsT<_Tp> _NonConstTraits; }; }

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Alloc = allocator< pair < const _Key, _Tp > > >
class map


#line 48 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"
{
  typedef map<_Key, _Tp, _Compare, _Alloc> _Self;
public:



  typedef _Key                  key_type;
  typedef _Tp                   data_type;
  typedef _Tp                   mapped_type;
  typedef pair<const _Key, _Tp> value_type;
  typedef _Compare              key_compare;

  class value_compare
    : public binary_function<value_type, value_type, bool> {
  friend class map<_Key,_Tp,_Compare,_Alloc>;
  protected :
    
    _Compare comp;
    value_compare(_Compare __c) : comp(__c) {}
  public:
    bool operator()(const value_type& __x, const value_type& __y) const
    { return comp(__x.first, __y.first); }
  };

protected:
  typedef ::std::priv:: _MapTraitsT<value_type> _MapTraits;

public:
  
  typedef ::std::priv:: _Rb_tree<key_type, key_compare,
                              value_type, ::std::priv:: _Select1st< value_type >,
                              _MapTraits, _Alloc> _Rep_type;

  typedef typename _Rep_type::pointer pointer;
  typedef typename _Rep_type::const_pointer const_pointer;
  typedef typename _Rep_type::reference reference;
  typedef typename _Rep_type::const_reference const_reference;
  typedef typename _Rep_type::iterator iterator;
  typedef typename _Rep_type::const_iterator const_iterator;
  typedef typename _Rep_type::reverse_iterator reverse_iterator;
  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename _Rep_type::size_type size_type;
  typedef typename _Rep_type::difference_type difference_type;
  typedef typename _Rep_type::allocator_type allocator_type;

private:
  _Rep_type _M_t;  
  typedef key_type _KT;

public:
  
  map() : _M_t(_Compare(), allocator_type()) {}

  explicit map(const _Compare& __comp,
               const allocator_type& __a = allocator_type())




#line 108 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"
    : _M_t(__comp, __a) {}


  template <class _InputIterator>
  map(_InputIterator __first, _InputIterator __last)
    : _M_t(_Compare(), allocator_type())
    { _M_t.insert_unique(__first, __last); }

  template <class _InputIterator>
  map(_InputIterator __first, _InputIterator __last, const _Compare& __comp,
      const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }





#line 126 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"


















#line 145 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

  map(const _Self& __x) : _M_t(__x._M_t) {}


  map(__move_source<_Self> src)
    : _M_t(__move_source<_Rep_type>(src.get()._M_t)) {}
#line 152 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

  _Self& operator=(const _Self& __x) {
    _M_t = __x._M_t;
    return *this;
  }

  
  key_compare key_comp() const { return _M_t.key_comp(); }
  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }
  allocator_type get_allocator() const { return _M_t.get_allocator(); }

  iterator begin() { return _M_t.begin(); }
  const_iterator begin() const { return _M_t.begin(); }
  iterator end() { return _M_t.end(); }
  const_iterator end() const { return _M_t.end(); }
  reverse_iterator rbegin() { return _M_t.rbegin(); }
  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }
  reverse_iterator rend() { return _M_t.rend(); }
  const_reverse_iterator rend() const { return _M_t.rend(); }
  bool empty() const { return _M_t.empty(); }
  size_type size() const { return _M_t.size(); }
  size_type max_size() const { return _M_t.max_size(); }
  
  _Tp& operator[](const _KT& __k) {
    iterator __i = lower_bound(__k);
    
    if (__i == end() || key_comp()(__k, (*__i).first))
      __i = insert(__i, value_type(__k, _Tp()));
    return (*__i).second;
  }
  void swap(_Self& __x) { _M_t.swap(__x._M_t); }


#line 186 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

  
  pair<iterator,bool> insert(const value_type& __x)
  { return _M_t.insert_unique(__x); }
  iterator insert(iterator __pos, const value_type& __x)
  { return _M_t.insert_unique(__pos, __x); }

  template <class _InputIterator>
  void insert(_InputIterator __first, _InputIterator __last)
  { _M_t.insert_unique(__first, __last); }





#line 202 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

  void erase(iterator __pos) { _M_t.erase(__pos); }
  size_type erase(const key_type& __x) { return _M_t.erase_unique(__x); }
  void erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }
  void clear() { _M_t.clear(); }

  
  
  iterator find(const _KT& __x) { return _M_t.find(__x); }
  
  const_iterator find(const _KT& __x) const { return _M_t.find(__x); }
  
  size_type count(const _KT& __x) const { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
  
  iterator lower_bound(const _KT& __x) { return _M_t.lower_bound(__x); }
  
  const_iterator lower_bound(const _KT& __x) const { return _M_t.lower_bound(__x); }
  
  iterator upper_bound(const _KT& __x) { return _M_t.upper_bound(__x); }
  
  const_iterator upper_bound(const _KT& __x) const { return _M_t.upper_bound(__x); }

  
  pair<iterator,iterator> equal_range(const _KT& __x)
  { return _M_t.equal_range_unique(__x); }
  
  pair<const_iterator,const_iterator> equal_range(const _KT& __x) const
  { return _M_t.equal_range_unique(__x); }
};


namespace priv { template <class _Tp> struct _MultimapTraitsT; template <class _Tp> struct _ConstMultimapTraitsT : public ::std::_Const_traits<_Tp> { typedef _ConstMultimapTraitsT<_Tp> _ConstTraits; typedef _MultimapTraitsT<_Tp> _NonConstTraits; }; template <class _Tp> struct _MultimapTraitsT : public ::std::_Nonconst_traits<_Tp> { typedef _ConstMultimapTraitsT<_Tp> _ConstTraits; typedef _MultimapTraitsT<_Tp> _NonConstTraits; }; }

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Alloc = allocator< pair < const _Key, _Tp > > >
class multimap


#line 241 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"
{
  typedef multimap<_Key, _Tp, _Compare, _Alloc> _Self;
public:



  typedef _Key                  key_type;
  typedef _Tp                   data_type;
  typedef _Tp                   mapped_type;
  typedef pair<const _Key, _Tp> value_type;
  typedef _Compare              key_compare;

  class value_compare : public binary_function<value_type, value_type, bool> {
    friend class multimap<_Key,_Tp,_Compare,_Alloc>;
  protected:
    
    _Compare comp;
    value_compare(_Compare __c) : comp(__c) {}
  public:
    bool operator()(const value_type& __x, const value_type& __y) const
    { return comp(__x.first, __y.first); }
  };

protected:
  
  typedef ::std::priv:: _MultimapTraitsT<value_type> _MultimapTraits;

public:
  
  typedef ::std::priv:: _Rb_tree<key_type, key_compare,
                              value_type, ::std::priv:: _Select1st< value_type >,
                              _MultimapTraits, _Alloc> _Rep_type;

  typedef typename _Rep_type::pointer pointer;
  typedef typename _Rep_type::const_pointer const_pointer;
  typedef typename _Rep_type::reference reference;
  typedef typename _Rep_type::const_reference const_reference;
  typedef typename _Rep_type::iterator iterator;
  typedef typename _Rep_type::const_iterator const_iterator;
  typedef typename _Rep_type::reverse_iterator reverse_iterator;
  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename _Rep_type::size_type size_type;
  typedef typename _Rep_type::difference_type difference_type;
  typedef typename _Rep_type::allocator_type allocator_type;

private:
  _Rep_type _M_t;  
  typedef key_type _KT;

public:
  
  multimap() : _M_t(_Compare(), allocator_type()) { }
  explicit multimap(const _Compare& __comp,
                    const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { }


  template <class _InputIterator>
  multimap(_InputIterator __first, _InputIterator __last)
    : _M_t(_Compare(), allocator_type())
    { _M_t.insert_equal(__first, __last); }






  template <class _InputIterator>
  multimap(_InputIterator __first, _InputIterator __last,
           const _Compare& __comp,
           const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
















#line 330 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

  multimap(const _Self& __x) : _M_t(__x._M_t) {}


  multimap(__move_source<_Self> src)
    : _M_t(__move_source<_Rep_type>(src.get()._M_t)) {}
#line 337 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

  _Self& operator=(const _Self& __x) {
    _M_t = __x._M_t;
    return *this;
  }

  

  key_compare key_comp() const { return _M_t.key_comp(); }
  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }
  allocator_type get_allocator() const { return _M_t.get_allocator(); }

  iterator begin() { return _M_t.begin(); }
  const_iterator begin() const { return _M_t.begin(); }
  iterator end() { return _M_t.end(); }
  const_iterator end() const { return _M_t.end(); }
  reverse_iterator rbegin() { return _M_t.rbegin(); }
  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }
  reverse_iterator rend() { return _M_t.rend(); }
  const_reverse_iterator rend() const { return _M_t.rend(); }
  bool empty() const { return _M_t.empty(); }
  size_type size() const { return _M_t.size(); }
  size_type max_size() const { return _M_t.max_size(); }
  void swap(_Self& __x) { _M_t.swap(__x._M_t); }


#line 364 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

  
  iterator insert(const value_type& __x) { return _M_t.insert_equal(__x); }
  iterator insert(iterator __pos, const value_type& __x) { return _M_t.insert_equal(__pos, __x); }

  template <class _InputIterator>
  void insert(_InputIterator __first, _InputIterator __last)
  { _M_t.insert_equal(__first, __last); }





#line 378 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"
  void erase(iterator __pos) { _M_t.erase(__pos); }
  size_type erase(const key_type& __x) { return _M_t.erase(__x); }
  void erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }
  void clear() { _M_t.clear(); }

  

  
  iterator find(const _KT& __x) { return _M_t.find(__x); }
  
  const_iterator find(const _KT& __x) const { return _M_t.find(__x); }
  
  size_type count(const _KT& __x) const { return _M_t.count(__x); }
  
  iterator lower_bound(const _KT& __x) { return _M_t.lower_bound(__x); }
  
  const_iterator lower_bound(const _KT& __x) const { return _M_t.lower_bound(__x); }
  
  iterator upper_bound(const _KT& __x) { return _M_t.upper_bound(__x); }
  
  const_iterator upper_bound(const _KT& __x) const { return _M_t.upper_bound(__x); }
  
  pair<iterator,iterator> equal_range(const _KT& __x)
  { return _M_t.equal_range(__x); }
  
  pair<const_iterator,const_iterator> equal_range(const _KT& __x) const
  { return _M_t.equal_range(__x); }
};



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"





template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool __cdecl operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,
                                  const map<_Key,_Tp,_Compare,_Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}
#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"

template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool __cdecl operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,
                                 const map<_Key,_Tp,_Compare,_Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) {return !(__x == __y);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) {return __y < __x;}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__y < __x);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__x < __y);}


template <class _Key, class _Tp, class _Compare, class _Alloc>
inline void __cdecl swap(map<_Key,_Tp,_Compare,_Alloc>& __x,
                            map<_Key,_Tp,_Compare,_Alloc>& __y) {
  __x.swap(__y);
}
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"
#line 410 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"





template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool __cdecl operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                                  const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}
#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"

template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool __cdecl operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                                 const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {return !(__x == __y);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {return __y < __x;}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__y < __x);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool __cdecl operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__x < __y);}


template <class _Key, class _Tp, class _Compare, class _Alloc>
inline void __cdecl swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                            multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
  __x.swap(__y);
}
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"
#line 413 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"




template <class _Key, class _Tp, class _Compare, class _Alloc>
struct __move_traits<map<_Key,_Tp,_Compare,_Alloc> > :
  ::std::priv:: __move_traits_aux<typename map<_Key,_Tp,_Compare,_Alloc>::_Rep_type>
{};

template <class _Key, class _Tp, class _Compare, class _Alloc>
struct __move_traits<multimap<_Key,_Tp,_Compare,_Alloc> > :
  ::std::priv:: __move_traits_aux<typename multimap<_Key,_Tp,_Compare,_Alloc>::_Rep_type>
{};
#line 427 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"

}

#line 431 "C:\\Pin35\\extras\\stlport\\include\\stl/_map.h"





#line 37 "C:\\Pin35\\extras\\stlport\\include\\map"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\map"
#line 39 "C:\\Pin35\\extras\\stlport\\include\\map"







#line 47 "C:\\Pin35\\extras\\stlport\\include\\map"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 50 "C:\\Pin35\\extras\\stlport\\include\\map"

#line 52 "C:\\Pin35\\extras\\stlport\\include\\map"

#line 54 "C:\\Pin35\\extras\\stlport\\include\\map"




#line 39 "C:\\Pin35\\source\\include\\pin\\gen\\pinsync.hpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\string"



























































#line 40 "C:\\Pin35\\source\\include\\pin\\gen\\pinsync.hpp"

namespace PINVM {



class ILOCK 
{
public:
    


    virtual ~ILOCK() {}

    


    virtual void Lock() = 0;

    


    virtual void Unlock() = 0;

    




    virtual bool TryLock() = 0;
};




class PINSYNC_LOCK 
{
public:
    


    PINSYNC_LOCK() { OS_MutexInit(&_impl); }

    




    bool Initialize() { OS_MutexInit(&_impl); return true; }

    


    void Destroy() { OS_MutexDestroy(&_impl); }

    



    void Reset() { OS_MutexUnlock(&_impl); }

    


    void Lock() { OS_MutexLock(&_impl); }

    


    void Unlock() { OS_MutexUnlock(&_impl); }

    




    bool TryLock() {return OS_MutexTryLock(&_impl); }

private:
    OS_MUTEX_TYPE _impl;
};




typedef struct
{
public:
    




    bool Initialize() { OS_MutexInit(&_impl); return true; }

    


    void Destroy() { OS_MutexDestroy(&_impl); }

    



    void Reset() { OS_MutexUnlock(&_impl); }

    


    void Lock() { OS_MutexLock(&_impl); }

    


    void Unlock() { OS_MutexUnlock(&_impl); }

    




    bool TryLock() {return OS_MutexTryLock(&_impl); }

    OS_MUTEX_TYPE _impl;
} PINSYNC_POD_LOCK;




typedef PINSYNC_POD_LOCK PINSYNC_SAFEPOD_LOCK;




class PINSYNC_RWLOCK 
{
public:
    


    PINSYNC_RWLOCK() { OS_RWLockInitialize(&_impl); }

    


    ~PINSYNC_RWLOCK() { Destroy(); }

    




    bool Initialize() { OS_RWLockInitialize(&_impl); return true;}

    


    void Destroy() { OS_RWLockDestroy(&_impl); }

    



    void Reset() { Destroy(); Initialize(); }

    



    void ReadLock() { OS_RWLockAcquireRead(&_impl); }

    




    void WriteLock() { OS_RWLockAcquireWrite(&_impl); }

    


    void Unlock() { OS_RWLockRelease(&_impl); }

    





    bool TryReadLock() { return OS_RWLockTryAcquireRead(&_impl); }

    





    bool TryWriteLock() { return OS_RWLockTryAcquireWrite(&_impl); }

private:
    OS_APIS_RW_LOCK_T _impl;
};




typedef struct
{
public:
    




    bool Initialize() { OS_RWLockInitialize(&_impl); return true;}

    


    void Destroy() { OS_RWLockDestroy(&_impl); }

    



    void Reset() { OS_RWLockRelease(&_impl); }

    



    void ReadLock() { OS_RWLockAcquireRead(&_impl); }

    




    void WriteLock() { OS_RWLockAcquireWrite(&_impl); }

    


    void Unlock() { OS_RWLockRelease(&_impl); }

    





    bool TryReadLock() { return OS_RWLockTryAcquireRead(&_impl); }

    





    bool TryWriteLock() { return OS_RWLockTryAcquireWrite(&_impl); }

    OS_APIS_RW_LOCK_T _impl;
} PINSYNC_POD_RWLOCK;





































































































































































































































































































































































































































































class PINSYNC_SEMAPHORE 
{
public:
    


    PINSYNC_SEMAPHORE() { OS_MutexInit(&_impl); Clear(); }

    


    ~PINSYNC_SEMAPHORE() { Destroy(); }

    




    bool Initialize() { OS_MutexInit(&_impl); Clear(); return true; }

    


    void Destroy() {OS_MutexDestroy(&_impl); }

    





    void Set() { _isSet = true; OS_MutexUnlock(&_impl); }

    


    void Clear() { _isSet = false; OS_MutexTryLock(&_impl); }

    





    bool IsSet() { return _isSet; }

    



    void Wait() { OS_MutexLock(&_impl); OS_MutexUnlock(&_impl); }

    









    bool TimedWait(unsigned timeout)
    {
        bool res = OS_MutexTimedLock(&_impl, timeout);
        if (res) OS_MutexUnlock(&_impl);
        return res;
    }

private:
    OS_MUTEX_TYPE _impl;

    






    volatile bool _isSet;
};





typedef struct
{
public:
    




    bool Initialize() { OS_MutexInit(&_impl); Clear(); return true; }

    


    void Destroy() {OS_MutexDestroy(&_impl); Clear(); }

    





    void Set() { OS_MutexUnlock(&_impl); }

    


    void Clear() { OS_MutexTryLock(&_impl); }

    





    bool IsSet() { return !OS_MutexIsLocked(&_impl); }

    



    void Wait() { OS_MutexLock(&_impl); OS_MutexUnlock(&_impl); }

    









    bool TimedWait(unsigned timeout)
    {
        bool res = OS_MutexTimedLock(&_impl, timeout);
        if (res) OS_MutexUnlock(&_impl);
        return res;
    }

    OS_MUTEX_TYPE _impl;
} PINSYNC_POD_SEMAPHORE;

} 

#line 906 "C:\\Pin35\\source\\include\\pin\\gen\\pinsync.hpp"
#line 97 "c:\\pin35\\source\\include\\pin\\level_base.PLH"

extern "C" {
#line 1 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-iclass-enum.h"





































#line 1 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"










































#line 44 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"


#line 47 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"


#line 50 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"


#line 53 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"
























#line 78 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"



#line 82 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"
    
#line 84 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"

#line 39 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-iclass-enum.h"
typedef enum {
  XED_ICLASS_INVALID,
  XED_ICLASS_AAA,
  XED_ICLASS_AAD,
  XED_ICLASS_AAM,
  XED_ICLASS_AAS,
  XED_ICLASS_ADC,
  XED_ICLASS_ADCX,
  XED_ICLASS_ADC_LOCK,
  XED_ICLASS_ADD,
  XED_ICLASS_ADDPD,
  XED_ICLASS_ADDPS,
  XED_ICLASS_ADDSD,
  XED_ICLASS_ADDSS,
  XED_ICLASS_ADDSUBPD,
  XED_ICLASS_ADDSUBPS,
  XED_ICLASS_ADD_LOCK,
  XED_ICLASS_ADOX,
  XED_ICLASS_AESDEC,
  XED_ICLASS_AESDECLAST,
  XED_ICLASS_AESENC,
  XED_ICLASS_AESENCLAST,
  XED_ICLASS_AESIMC,
  XED_ICLASS_AESKEYGENASSIST,
  XED_ICLASS_AND,
  XED_ICLASS_ANDN,
  XED_ICLASS_ANDNPD,
  XED_ICLASS_ANDNPS,
  XED_ICLASS_ANDPD,
  XED_ICLASS_ANDPS,
  XED_ICLASS_AND_LOCK,
  XED_ICLASS_ARPL,
  XED_ICLASS_BEXTR,
  XED_ICLASS_BEXTR_XOP,
  XED_ICLASS_BLCFILL,
  XED_ICLASS_BLCI,
  XED_ICLASS_BLCIC,
  XED_ICLASS_BLCMSK,
  XED_ICLASS_BLCS,
  XED_ICLASS_BLENDPD,
  XED_ICLASS_BLENDPS,
  XED_ICLASS_BLENDVPD,
  XED_ICLASS_BLENDVPS,
  XED_ICLASS_BLSFILL,
  XED_ICLASS_BLSI,
  XED_ICLASS_BLSIC,
  XED_ICLASS_BLSMSK,
  XED_ICLASS_BLSR,
  XED_ICLASS_BNDCL,
  XED_ICLASS_BNDCN,
  XED_ICLASS_BNDCU,
  XED_ICLASS_BNDLDX,
  XED_ICLASS_BNDMK,
  XED_ICLASS_BNDMOV,
  XED_ICLASS_BNDSTX,
  XED_ICLASS_BOUND,
  XED_ICLASS_BSF,
  XED_ICLASS_BSR,
  XED_ICLASS_BSWAP,
  XED_ICLASS_BT,
  XED_ICLASS_BTC,
  XED_ICLASS_BTC_LOCK,
  XED_ICLASS_BTR,
  XED_ICLASS_BTR_LOCK,
  XED_ICLASS_BTS,
  XED_ICLASS_BTS_LOCK,
  XED_ICLASS_BZHI,
  XED_ICLASS_CALL_FAR,
  XED_ICLASS_CALL_NEAR,
  XED_ICLASS_CBW,
  XED_ICLASS_CDQ,
  XED_ICLASS_CDQE,
  XED_ICLASS_CLAC,
  XED_ICLASS_CLC,
  XED_ICLASS_CLD,
  XED_ICLASS_CLFLUSH,
  XED_ICLASS_CLFLUSHOPT,
  XED_ICLASS_CLGI,
  XED_ICLASS_CLI,
  XED_ICLASS_CLRSSBSY,
  XED_ICLASS_CLTS,
  XED_ICLASS_CLWB,
  XED_ICLASS_CLZERO,
  XED_ICLASS_CMC,
  XED_ICLASS_CMOVB,
  XED_ICLASS_CMOVBE,
  XED_ICLASS_CMOVL,
  XED_ICLASS_CMOVLE,
  XED_ICLASS_CMOVNB,
  XED_ICLASS_CMOVNBE,
  XED_ICLASS_CMOVNL,
  XED_ICLASS_CMOVNLE,
  XED_ICLASS_CMOVNO,
  XED_ICLASS_CMOVNP,
  XED_ICLASS_CMOVNS,
  XED_ICLASS_CMOVNZ,
  XED_ICLASS_CMOVO,
  XED_ICLASS_CMOVP,
  XED_ICLASS_CMOVS,
  XED_ICLASS_CMOVZ,
  XED_ICLASS_CMP,
  XED_ICLASS_CMPPD,
  XED_ICLASS_CMPPS,
  XED_ICLASS_CMPSB,
  XED_ICLASS_CMPSD,
  XED_ICLASS_CMPSD_XMM,
  XED_ICLASS_CMPSQ,
  XED_ICLASS_CMPSS,
  XED_ICLASS_CMPSW,
  XED_ICLASS_CMPXCHG,
  XED_ICLASS_CMPXCHG16B,
  XED_ICLASS_CMPXCHG16B_LOCK,
  XED_ICLASS_CMPXCHG8B,
  XED_ICLASS_CMPXCHG8B_LOCK,
  XED_ICLASS_CMPXCHG_LOCK,
  XED_ICLASS_COMISD,
  XED_ICLASS_COMISS,
  XED_ICLASS_CPUID,
  XED_ICLASS_CQO,
  XED_ICLASS_CRC32,
  XED_ICLASS_CVTDQ2PD,
  XED_ICLASS_CVTDQ2PS,
  XED_ICLASS_CVTPD2DQ,
  XED_ICLASS_CVTPD2PI,
  XED_ICLASS_CVTPD2PS,
  XED_ICLASS_CVTPI2PD,
  XED_ICLASS_CVTPI2PS,
  XED_ICLASS_CVTPS2DQ,
  XED_ICLASS_CVTPS2PD,
  XED_ICLASS_CVTPS2PI,
  XED_ICLASS_CVTSD2SI,
  XED_ICLASS_CVTSD2SS,
  XED_ICLASS_CVTSI2SD,
  XED_ICLASS_CVTSI2SS,
  XED_ICLASS_CVTSS2SD,
  XED_ICLASS_CVTSS2SI,
  XED_ICLASS_CVTTPD2DQ,
  XED_ICLASS_CVTTPD2PI,
  XED_ICLASS_CVTTPS2DQ,
  XED_ICLASS_CVTTPS2PI,
  XED_ICLASS_CVTTSD2SI,
  XED_ICLASS_CVTTSS2SI,
  XED_ICLASS_CWD,
  XED_ICLASS_CWDE,
  XED_ICLASS_DAA,
  XED_ICLASS_DAS,
  XED_ICLASS_DEC,
  XED_ICLASS_DEC_LOCK,
  XED_ICLASS_DIV,
  XED_ICLASS_DIVPD,
  XED_ICLASS_DIVPS,
  XED_ICLASS_DIVSD,
  XED_ICLASS_DIVSS,
  XED_ICLASS_DPPD,
  XED_ICLASS_DPPS,
  XED_ICLASS_EMMS,
  XED_ICLASS_ENCLS,
  XED_ICLASS_ENCLU,
  XED_ICLASS_ENDBR32,
  XED_ICLASS_ENDBR64,
  XED_ICLASS_ENTER,
  XED_ICLASS_EXTRACTPS,
  XED_ICLASS_EXTRQ,
  XED_ICLASS_F2XM1,
  XED_ICLASS_FABS,
  XED_ICLASS_FADD,
  XED_ICLASS_FADDP,
  XED_ICLASS_FBLD,
  XED_ICLASS_FBSTP,
  XED_ICLASS_FCHS,
  XED_ICLASS_FCMOVB,
  XED_ICLASS_FCMOVBE,
  XED_ICLASS_FCMOVE,
  XED_ICLASS_FCMOVNB,
  XED_ICLASS_FCMOVNBE,
  XED_ICLASS_FCMOVNE,
  XED_ICLASS_FCMOVNU,
  XED_ICLASS_FCMOVU,
  XED_ICLASS_FCOM,
  XED_ICLASS_FCOMI,
  XED_ICLASS_FCOMIP,
  XED_ICLASS_FCOMP,
  XED_ICLASS_FCOMPP,
  XED_ICLASS_FCOS,
  XED_ICLASS_FDECSTP,
  XED_ICLASS_FDISI8087_NOP,
  XED_ICLASS_FDIV,
  XED_ICLASS_FDIVP,
  XED_ICLASS_FDIVR,
  XED_ICLASS_FDIVRP,
  XED_ICLASS_FEMMS,
  XED_ICLASS_FENI8087_NOP,
  XED_ICLASS_FFREE,
  XED_ICLASS_FFREEP,
  XED_ICLASS_FIADD,
  XED_ICLASS_FICOM,
  XED_ICLASS_FICOMP,
  XED_ICLASS_FIDIV,
  XED_ICLASS_FIDIVR,
  XED_ICLASS_FILD,
  XED_ICLASS_FIMUL,
  XED_ICLASS_FINCSTP,
  XED_ICLASS_FIST,
  XED_ICLASS_FISTP,
  XED_ICLASS_FISTTP,
  XED_ICLASS_FISUB,
  XED_ICLASS_FISUBR,
  XED_ICLASS_FLD,
  XED_ICLASS_FLD1,
  XED_ICLASS_FLDCW,
  XED_ICLASS_FLDENV,
  XED_ICLASS_FLDL2E,
  XED_ICLASS_FLDL2T,
  XED_ICLASS_FLDLG2,
  XED_ICLASS_FLDLN2,
  XED_ICLASS_FLDPI,
  XED_ICLASS_FLDZ,
  XED_ICLASS_FMUL,
  XED_ICLASS_FMULP,
  XED_ICLASS_FNCLEX,
  XED_ICLASS_FNINIT,
  XED_ICLASS_FNOP,
  XED_ICLASS_FNSAVE,
  XED_ICLASS_FNSTCW,
  XED_ICLASS_FNSTENV,
  XED_ICLASS_FNSTSW,
  XED_ICLASS_FPATAN,
  XED_ICLASS_FPREM,
  XED_ICLASS_FPREM1,
  XED_ICLASS_FPTAN,
  XED_ICLASS_FRNDINT,
  XED_ICLASS_FRSTOR,
  XED_ICLASS_FSCALE,
  XED_ICLASS_FSETPM287_NOP,
  XED_ICLASS_FSIN,
  XED_ICLASS_FSINCOS,
  XED_ICLASS_FSQRT,
  XED_ICLASS_FST,
  XED_ICLASS_FSTP,
  XED_ICLASS_FSTPNCE,
  XED_ICLASS_FSUB,
  XED_ICLASS_FSUBP,
  XED_ICLASS_FSUBR,
  XED_ICLASS_FSUBRP,
  XED_ICLASS_FTST,
  XED_ICLASS_FUCOM,
  XED_ICLASS_FUCOMI,
  XED_ICLASS_FUCOMIP,
  XED_ICLASS_FUCOMP,
  XED_ICLASS_FUCOMPP,
  XED_ICLASS_FWAIT,
  XED_ICLASS_FXAM,
  XED_ICLASS_FXCH,
  XED_ICLASS_FXRSTOR,
  XED_ICLASS_FXRSTOR64,
  XED_ICLASS_FXSAVE,
  XED_ICLASS_FXSAVE64,
  XED_ICLASS_FXTRACT,
  XED_ICLASS_FYL2X,
  XED_ICLASS_FYL2XP1,
  XED_ICLASS_GETSEC,
  XED_ICLASS_GF2P8AFFINEINVQB,
  XED_ICLASS_GF2P8AFFINEQB,
  XED_ICLASS_GF2P8MULB,
  XED_ICLASS_HADDPD,
  XED_ICLASS_HADDPS,
  XED_ICLASS_HLT,
  XED_ICLASS_HSUBPD,
  XED_ICLASS_HSUBPS,
  XED_ICLASS_IDIV,
  XED_ICLASS_IMUL,
  XED_ICLASS_IN,
  XED_ICLASS_INC,
  XED_ICLASS_INCSSPD,
  XED_ICLASS_INCSSPQ,
  XED_ICLASS_INC_LOCK,
  XED_ICLASS_INSB,
  XED_ICLASS_INSD,
  XED_ICLASS_INSERTPS,
  XED_ICLASS_INSERTQ,
  XED_ICLASS_INSW,
  XED_ICLASS_INT,
  XED_ICLASS_INT1,
  XED_ICLASS_INT3,
  XED_ICLASS_INTO,
  XED_ICLASS_INVD,
  XED_ICLASS_INVEPT,
  XED_ICLASS_INVLPG,
  XED_ICLASS_INVLPGA,
  XED_ICLASS_INVPCID,
  XED_ICLASS_INVVPID,
  XED_ICLASS_IRET,
  XED_ICLASS_IRETD,
  XED_ICLASS_IRETQ,
  XED_ICLASS_JB,
  XED_ICLASS_JBE,
  XED_ICLASS_JCXZ,
  XED_ICLASS_JECXZ,
  XED_ICLASS_JL,
  XED_ICLASS_JLE,
  XED_ICLASS_JMP,
  XED_ICLASS_JMP_FAR,
  XED_ICLASS_JNB,
  XED_ICLASS_JNBE,
  XED_ICLASS_JNL,
  XED_ICLASS_JNLE,
  XED_ICLASS_JNO,
  XED_ICLASS_JNP,
  XED_ICLASS_JNS,
  XED_ICLASS_JNZ,
  XED_ICLASS_JO,
  XED_ICLASS_JP,
  XED_ICLASS_JRCXZ,
  XED_ICLASS_JS,
  XED_ICLASS_JZ,
  XED_ICLASS_KADDB,
  XED_ICLASS_KADDD,
  XED_ICLASS_KADDQ,
  XED_ICLASS_KADDW,
  XED_ICLASS_KANDB,
  XED_ICLASS_KANDD,
  XED_ICLASS_KANDNB,
  XED_ICLASS_KANDND,
  XED_ICLASS_KANDNQ,
  XED_ICLASS_KANDNW,
  XED_ICLASS_KANDQ,
  XED_ICLASS_KANDW,
  XED_ICLASS_KMOVB,
  XED_ICLASS_KMOVD,
  XED_ICLASS_KMOVQ,
  XED_ICLASS_KMOVW,
  XED_ICLASS_KNOTB,
  XED_ICLASS_KNOTD,
  XED_ICLASS_KNOTQ,
  XED_ICLASS_KNOTW,
  XED_ICLASS_KORB,
  XED_ICLASS_KORD,
  XED_ICLASS_KORQ,
  XED_ICLASS_KORTESTB,
  XED_ICLASS_KORTESTD,
  XED_ICLASS_KORTESTQ,
  XED_ICLASS_KORTESTW,
  XED_ICLASS_KORW,
  XED_ICLASS_KSHIFTLB,
  XED_ICLASS_KSHIFTLD,
  XED_ICLASS_KSHIFTLQ,
  XED_ICLASS_KSHIFTLW,
  XED_ICLASS_KSHIFTRB,
  XED_ICLASS_KSHIFTRD,
  XED_ICLASS_KSHIFTRQ,
  XED_ICLASS_KSHIFTRW,
  XED_ICLASS_KTESTB,
  XED_ICLASS_KTESTD,
  XED_ICLASS_KTESTQ,
  XED_ICLASS_KTESTW,
  XED_ICLASS_KUNPCKBW,
  XED_ICLASS_KUNPCKDQ,
  XED_ICLASS_KUNPCKWD,
  XED_ICLASS_KXNORB,
  XED_ICLASS_KXNORD,
  XED_ICLASS_KXNORQ,
  XED_ICLASS_KXNORW,
  XED_ICLASS_KXORB,
  XED_ICLASS_KXORD,
  XED_ICLASS_KXORQ,
  XED_ICLASS_KXORW,
  XED_ICLASS_LAHF,
  XED_ICLASS_LAR,
  XED_ICLASS_LDDQU,
  XED_ICLASS_LDMXCSR,
  XED_ICLASS_LDS,
  XED_ICLASS_LEA,
  XED_ICLASS_LEAVE,
  XED_ICLASS_LES,
  XED_ICLASS_LFENCE,
  XED_ICLASS_LFS,
  XED_ICLASS_LGDT,
  XED_ICLASS_LGS,
  XED_ICLASS_LIDT,
  XED_ICLASS_LLDT,
  XED_ICLASS_LLWPCB,
  XED_ICLASS_LMSW,
  XED_ICLASS_LODSB,
  XED_ICLASS_LODSD,
  XED_ICLASS_LODSQ,
  XED_ICLASS_LODSW,
  XED_ICLASS_LOOP,
  XED_ICLASS_LOOPE,
  XED_ICLASS_LOOPNE,
  XED_ICLASS_LSL,
  XED_ICLASS_LSS,
  XED_ICLASS_LTR,
  XED_ICLASS_LWPINS,
  XED_ICLASS_LWPVAL,
  XED_ICLASS_LZCNT,
  XED_ICLASS_MASKMOVDQU,
  XED_ICLASS_MASKMOVQ,
  XED_ICLASS_MAXPD,
  XED_ICLASS_MAXPS,
  XED_ICLASS_MAXSD,
  XED_ICLASS_MAXSS,
  XED_ICLASS_MFENCE,
  XED_ICLASS_MINPD,
  XED_ICLASS_MINPS,
  XED_ICLASS_MINSD,
  XED_ICLASS_MINSS,
  XED_ICLASS_MONITOR,
  XED_ICLASS_MOV,
  XED_ICLASS_MOVAPD,
  XED_ICLASS_MOVAPS,
  XED_ICLASS_MOVBE,
  XED_ICLASS_MOVD,
  XED_ICLASS_MOVDDUP,
  XED_ICLASS_MOVDQ2Q,
  XED_ICLASS_MOVDQA,
  XED_ICLASS_MOVDQU,
  XED_ICLASS_MOVHLPS,
  XED_ICLASS_MOVHPD,
  XED_ICLASS_MOVHPS,
  XED_ICLASS_MOVLHPS,
  XED_ICLASS_MOVLPD,
  XED_ICLASS_MOVLPS,
  XED_ICLASS_MOVMSKPD,
  XED_ICLASS_MOVMSKPS,
  XED_ICLASS_MOVNTDQ,
  XED_ICLASS_MOVNTDQA,
  XED_ICLASS_MOVNTI,
  XED_ICLASS_MOVNTPD,
  XED_ICLASS_MOVNTPS,
  XED_ICLASS_MOVNTQ,
  XED_ICLASS_MOVNTSD,
  XED_ICLASS_MOVNTSS,
  XED_ICLASS_MOVQ,
  XED_ICLASS_MOVQ2DQ,
  XED_ICLASS_MOVSB,
  XED_ICLASS_MOVSD,
  XED_ICLASS_MOVSD_XMM,
  XED_ICLASS_MOVSHDUP,
  XED_ICLASS_MOVSLDUP,
  XED_ICLASS_MOVSQ,
  XED_ICLASS_MOVSS,
  XED_ICLASS_MOVSW,
  XED_ICLASS_MOVSX,
  XED_ICLASS_MOVSXD,
  XED_ICLASS_MOVUPD,
  XED_ICLASS_MOVUPS,
  XED_ICLASS_MOVZX,
  XED_ICLASS_MOV_CR,
  XED_ICLASS_MOV_DR,
  XED_ICLASS_MPSADBW,
  XED_ICLASS_MUL,
  XED_ICLASS_MULPD,
  XED_ICLASS_MULPS,
  XED_ICLASS_MULSD,
  XED_ICLASS_MULSS,
  XED_ICLASS_MULX,
  XED_ICLASS_MWAIT,
  XED_ICLASS_NEG,
  XED_ICLASS_NEG_LOCK,
  XED_ICLASS_NOP,
  XED_ICLASS_NOP2,
  XED_ICLASS_NOP3,
  XED_ICLASS_NOP4,
  XED_ICLASS_NOP5,
  XED_ICLASS_NOP6,
  XED_ICLASS_NOP7,
  XED_ICLASS_NOP8,
  XED_ICLASS_NOP9,
  XED_ICLASS_NOT,
  XED_ICLASS_NOT_LOCK,
  XED_ICLASS_OR,
  XED_ICLASS_ORPD,
  XED_ICLASS_ORPS,
  XED_ICLASS_OR_LOCK,
  XED_ICLASS_OUT,
  XED_ICLASS_OUTSB,
  XED_ICLASS_OUTSD,
  XED_ICLASS_OUTSW,
  XED_ICLASS_PABSB,
  XED_ICLASS_PABSD,
  XED_ICLASS_PABSW,
  XED_ICLASS_PACKSSDW,
  XED_ICLASS_PACKSSWB,
  XED_ICLASS_PACKUSDW,
  XED_ICLASS_PACKUSWB,
  XED_ICLASS_PADDB,
  XED_ICLASS_PADDD,
  XED_ICLASS_PADDQ,
  XED_ICLASS_PADDSB,
  XED_ICLASS_PADDSW,
  XED_ICLASS_PADDUSB,
  XED_ICLASS_PADDUSW,
  XED_ICLASS_PADDW,
  XED_ICLASS_PALIGNR,
  XED_ICLASS_PAND,
  XED_ICLASS_PANDN,
  XED_ICLASS_PAUSE,
  XED_ICLASS_PAVGB,
  XED_ICLASS_PAVGUSB,
  XED_ICLASS_PAVGW,
  XED_ICLASS_PBLENDVB,
  XED_ICLASS_PBLENDW,
  XED_ICLASS_PCLMULQDQ,
  XED_ICLASS_PCMPEQB,
  XED_ICLASS_PCMPEQD,
  XED_ICLASS_PCMPEQQ,
  XED_ICLASS_PCMPEQW,
  XED_ICLASS_PCMPESTRI,
  XED_ICLASS_PCMPESTRM,
  XED_ICLASS_PCMPGTB,
  XED_ICLASS_PCMPGTD,
  XED_ICLASS_PCMPGTQ,
  XED_ICLASS_PCMPGTW,
  XED_ICLASS_PCMPISTRI,
  XED_ICLASS_PCMPISTRM,
  XED_ICLASS_PDEP,
  XED_ICLASS_PEXT,
  XED_ICLASS_PEXTRB,
  XED_ICLASS_PEXTRD,
  XED_ICLASS_PEXTRQ,
  XED_ICLASS_PEXTRW,
  XED_ICLASS_PEXTRW_SSE4,
  XED_ICLASS_PF2ID,
  XED_ICLASS_PF2IW,
  XED_ICLASS_PFACC,
  XED_ICLASS_PFADD,
  XED_ICLASS_PFCMPEQ,
  XED_ICLASS_PFCMPGE,
  XED_ICLASS_PFCMPGT,
  XED_ICLASS_PFCPIT1,
  XED_ICLASS_PFMAX,
  XED_ICLASS_PFMIN,
  XED_ICLASS_PFMUL,
  XED_ICLASS_PFNACC,
  XED_ICLASS_PFPNACC,
  XED_ICLASS_PFRCP,
  XED_ICLASS_PFRCPIT2,
  XED_ICLASS_PFRSQIT1,
  XED_ICLASS_PFSQRT,
  XED_ICLASS_PFSUB,
  XED_ICLASS_PFSUBR,
  XED_ICLASS_PHADDD,
  XED_ICLASS_PHADDSW,
  XED_ICLASS_PHADDW,
  XED_ICLASS_PHMINPOSUW,
  XED_ICLASS_PHSUBD,
  XED_ICLASS_PHSUBSW,
  XED_ICLASS_PHSUBW,
  XED_ICLASS_PI2FD,
  XED_ICLASS_PI2FW,
  XED_ICLASS_PINSRB,
  XED_ICLASS_PINSRD,
  XED_ICLASS_PINSRQ,
  XED_ICLASS_PINSRW,
  XED_ICLASS_PMADDUBSW,
  XED_ICLASS_PMADDWD,
  XED_ICLASS_PMAXSB,
  XED_ICLASS_PMAXSD,
  XED_ICLASS_PMAXSW,
  XED_ICLASS_PMAXUB,
  XED_ICLASS_PMAXUD,
  XED_ICLASS_PMAXUW,
  XED_ICLASS_PMINSB,
  XED_ICLASS_PMINSD,
  XED_ICLASS_PMINSW,
  XED_ICLASS_PMINUB,
  XED_ICLASS_PMINUD,
  XED_ICLASS_PMINUW,
  XED_ICLASS_PMOVMSKB,
  XED_ICLASS_PMOVSXBD,
  XED_ICLASS_PMOVSXBQ,
  XED_ICLASS_PMOVSXBW,
  XED_ICLASS_PMOVSXDQ,
  XED_ICLASS_PMOVSXWD,
  XED_ICLASS_PMOVSXWQ,
  XED_ICLASS_PMOVZXBD,
  XED_ICLASS_PMOVZXBQ,
  XED_ICLASS_PMOVZXBW,
  XED_ICLASS_PMOVZXDQ,
  XED_ICLASS_PMOVZXWD,
  XED_ICLASS_PMOVZXWQ,
  XED_ICLASS_PMULDQ,
  XED_ICLASS_PMULHRSW,
  XED_ICLASS_PMULHRW,
  XED_ICLASS_PMULHUW,
  XED_ICLASS_PMULHW,
  XED_ICLASS_PMULLD,
  XED_ICLASS_PMULLW,
  XED_ICLASS_PMULUDQ,
  XED_ICLASS_POP,
  XED_ICLASS_POPA,
  XED_ICLASS_POPAD,
  XED_ICLASS_POPCNT,
  XED_ICLASS_POPF,
  XED_ICLASS_POPFD,
  XED_ICLASS_POPFQ,
  XED_ICLASS_POR,
  XED_ICLASS_PREFETCHNTA,
  XED_ICLASS_PREFETCHT0,
  XED_ICLASS_PREFETCHT1,
  XED_ICLASS_PREFETCHT2,
  XED_ICLASS_PREFETCHW,
  XED_ICLASS_PREFETCHWT1,
  XED_ICLASS_PREFETCH_EXCLUSIVE,
  XED_ICLASS_PREFETCH_RESERVED,
  XED_ICLASS_PSADBW,
  XED_ICLASS_PSHUFB,
  XED_ICLASS_PSHUFD,
  XED_ICLASS_PSHUFHW,
  XED_ICLASS_PSHUFLW,
  XED_ICLASS_PSHUFW,
  XED_ICLASS_PSIGNB,
  XED_ICLASS_PSIGND,
  XED_ICLASS_PSIGNW,
  XED_ICLASS_PSLLD,
  XED_ICLASS_PSLLDQ,
  XED_ICLASS_PSLLQ,
  XED_ICLASS_PSLLW,
  XED_ICLASS_PSRAD,
  XED_ICLASS_PSRAW,
  XED_ICLASS_PSRLD,
  XED_ICLASS_PSRLDQ,
  XED_ICLASS_PSRLQ,
  XED_ICLASS_PSRLW,
  XED_ICLASS_PSUBB,
  XED_ICLASS_PSUBD,
  XED_ICLASS_PSUBQ,
  XED_ICLASS_PSUBSB,
  XED_ICLASS_PSUBSW,
  XED_ICLASS_PSUBUSB,
  XED_ICLASS_PSUBUSW,
  XED_ICLASS_PSUBW,
  XED_ICLASS_PSWAPD,
  XED_ICLASS_PTEST,
  XED_ICLASS_PTWRITE,
  XED_ICLASS_PUNPCKHBW,
  XED_ICLASS_PUNPCKHDQ,
  XED_ICLASS_PUNPCKHQDQ,
  XED_ICLASS_PUNPCKHWD,
  XED_ICLASS_PUNPCKLBW,
  XED_ICLASS_PUNPCKLDQ,
  XED_ICLASS_PUNPCKLQDQ,
  XED_ICLASS_PUNPCKLWD,
  XED_ICLASS_PUSH,
  XED_ICLASS_PUSHA,
  XED_ICLASS_PUSHAD,
  XED_ICLASS_PUSHF,
  XED_ICLASS_PUSHFD,
  XED_ICLASS_PUSHFQ,
  XED_ICLASS_PXOR,
  XED_ICLASS_RCL,
  XED_ICLASS_RCPPS,
  XED_ICLASS_RCPSS,
  XED_ICLASS_RCR,
  XED_ICLASS_RDFSBASE,
  XED_ICLASS_RDGSBASE,
  XED_ICLASS_RDMSR,
  XED_ICLASS_RDPID,
  XED_ICLASS_RDPKRU,
  XED_ICLASS_RDPMC,
  XED_ICLASS_RDRAND,
  XED_ICLASS_RDSEED,
  XED_ICLASS_RDSSPD,
  XED_ICLASS_RDSSPQ,
  XED_ICLASS_RDTSC,
  XED_ICLASS_RDTSCP,
  XED_ICLASS_REPE_CMPSB,
  XED_ICLASS_REPE_CMPSD,
  XED_ICLASS_REPE_CMPSQ,
  XED_ICLASS_REPE_CMPSW,
  XED_ICLASS_REPE_SCASB,
  XED_ICLASS_REPE_SCASD,
  XED_ICLASS_REPE_SCASQ,
  XED_ICLASS_REPE_SCASW,
  XED_ICLASS_REPNE_CMPSB,
  XED_ICLASS_REPNE_CMPSD,
  XED_ICLASS_REPNE_CMPSQ,
  XED_ICLASS_REPNE_CMPSW,
  XED_ICLASS_REPNE_SCASB,
  XED_ICLASS_REPNE_SCASD,
  XED_ICLASS_REPNE_SCASQ,
  XED_ICLASS_REPNE_SCASW,
  XED_ICLASS_REP_INSB,
  XED_ICLASS_REP_INSD,
  XED_ICLASS_REP_INSW,
  XED_ICLASS_REP_LODSB,
  XED_ICLASS_REP_LODSD,
  XED_ICLASS_REP_LODSQ,
  XED_ICLASS_REP_LODSW,
  XED_ICLASS_REP_MOVSB,
  XED_ICLASS_REP_MOVSD,
  XED_ICLASS_REP_MOVSQ,
  XED_ICLASS_REP_MOVSW,
  XED_ICLASS_REP_OUTSB,
  XED_ICLASS_REP_OUTSD,
  XED_ICLASS_REP_OUTSW,
  XED_ICLASS_REP_STOSB,
  XED_ICLASS_REP_STOSD,
  XED_ICLASS_REP_STOSQ,
  XED_ICLASS_REP_STOSW,
  XED_ICLASS_RET_FAR,
  XED_ICLASS_RET_NEAR,
  XED_ICLASS_ROL,
  XED_ICLASS_ROR,
  XED_ICLASS_RORX,
  XED_ICLASS_ROUNDPD,
  XED_ICLASS_ROUNDPS,
  XED_ICLASS_ROUNDSD,
  XED_ICLASS_ROUNDSS,
  XED_ICLASS_RSM,
  XED_ICLASS_RSQRTPS,
  XED_ICLASS_RSQRTSS,
  XED_ICLASS_RSTORSSP,
  XED_ICLASS_SAHF,
  XED_ICLASS_SALC,
  XED_ICLASS_SAR,
  XED_ICLASS_SARX,
  XED_ICLASS_SAVESSP,
  XED_ICLASS_SBB,
  XED_ICLASS_SBB_LOCK,
  XED_ICLASS_SCASB,
  XED_ICLASS_SCASD,
  XED_ICLASS_SCASQ,
  XED_ICLASS_SCASW,
  XED_ICLASS_SETB,
  XED_ICLASS_SETBE,
  XED_ICLASS_SETL,
  XED_ICLASS_SETLE,
  XED_ICLASS_SETNB,
  XED_ICLASS_SETNBE,
  XED_ICLASS_SETNL,
  XED_ICLASS_SETNLE,
  XED_ICLASS_SETNO,
  XED_ICLASS_SETNP,
  XED_ICLASS_SETNS,
  XED_ICLASS_SETNZ,
  XED_ICLASS_SETO,
  XED_ICLASS_SETP,
  XED_ICLASS_SETS,
  XED_ICLASS_SETSSBSY,
  XED_ICLASS_SETZ,
  XED_ICLASS_SFENCE,
  XED_ICLASS_SGDT,
  XED_ICLASS_SHA1MSG1,
  XED_ICLASS_SHA1MSG2,
  XED_ICLASS_SHA1NEXTE,
  XED_ICLASS_SHA1RNDS4,
  XED_ICLASS_SHA256MSG1,
  XED_ICLASS_SHA256MSG2,
  XED_ICLASS_SHA256RNDS2,
  XED_ICLASS_SHL,
  XED_ICLASS_SHLD,
  XED_ICLASS_SHLX,
  XED_ICLASS_SHR,
  XED_ICLASS_SHRD,
  XED_ICLASS_SHRX,
  XED_ICLASS_SHUFPD,
  XED_ICLASS_SHUFPS,
  XED_ICLASS_SIDT,
  XED_ICLASS_SKINIT,
  XED_ICLASS_SLDT,
  XED_ICLASS_SLWPCB,
  XED_ICLASS_SMSW,
  XED_ICLASS_SQRTPD,
  XED_ICLASS_SQRTPS,
  XED_ICLASS_SQRTSD,
  XED_ICLASS_SQRTSS,
  XED_ICLASS_STAC,
  XED_ICLASS_STC,
  XED_ICLASS_STD,
  XED_ICLASS_STGI,
  XED_ICLASS_STI,
  XED_ICLASS_STMXCSR,
  XED_ICLASS_STOSB,
  XED_ICLASS_STOSD,
  XED_ICLASS_STOSQ,
  XED_ICLASS_STOSW,
  XED_ICLASS_STR,
  XED_ICLASS_SUB,
  XED_ICLASS_SUBPD,
  XED_ICLASS_SUBPS,
  XED_ICLASS_SUBSD,
  XED_ICLASS_SUBSS,
  XED_ICLASS_SUB_LOCK,
  XED_ICLASS_SWAPGS,
  XED_ICLASS_SYSCALL,
  XED_ICLASS_SYSCALL_AMD,
  XED_ICLASS_SYSENTER,
  XED_ICLASS_SYSEXIT,
  XED_ICLASS_SYSRET,
  XED_ICLASS_SYSRET_AMD,
  XED_ICLASS_T1MSKC,
  XED_ICLASS_TEST,
  XED_ICLASS_TZCNT,
  XED_ICLASS_TZMSK,
  XED_ICLASS_UCOMISD,
  XED_ICLASS_UCOMISS,
  XED_ICLASS_UD0,
  XED_ICLASS_UD1,
  XED_ICLASS_UD2,
  XED_ICLASS_UNPCKHPD,
  XED_ICLASS_UNPCKHPS,
  XED_ICLASS_UNPCKLPD,
  XED_ICLASS_UNPCKLPS,
  XED_ICLASS_V4FMADDPS,
  XED_ICLASS_V4FMADDSS,
  XED_ICLASS_V4FNMADDPS,
  XED_ICLASS_V4FNMADDSS,
  XED_ICLASS_VADDPD,
  XED_ICLASS_VADDPS,
  XED_ICLASS_VADDSD,
  XED_ICLASS_VADDSS,
  XED_ICLASS_VADDSUBPD,
  XED_ICLASS_VADDSUBPS,
  XED_ICLASS_VAESDEC,
  XED_ICLASS_VAESDECLAST,
  XED_ICLASS_VAESENC,
  XED_ICLASS_VAESENCLAST,
  XED_ICLASS_VAESIMC,
  XED_ICLASS_VAESKEYGENASSIST,
  XED_ICLASS_VALIGND,
  XED_ICLASS_VALIGNQ,
  XED_ICLASS_VANDNPD,
  XED_ICLASS_VANDNPS,
  XED_ICLASS_VANDPD,
  XED_ICLASS_VANDPS,
  XED_ICLASS_VBLENDMPD,
  XED_ICLASS_VBLENDMPS,
  XED_ICLASS_VBLENDPD,
  XED_ICLASS_VBLENDPS,
  XED_ICLASS_VBLENDVPD,
  XED_ICLASS_VBLENDVPS,
  XED_ICLASS_VBROADCASTF128,
  XED_ICLASS_VBROADCASTF32X2,
  XED_ICLASS_VBROADCASTF32X4,
  XED_ICLASS_VBROADCASTF32X8,
  XED_ICLASS_VBROADCASTF64X2,
  XED_ICLASS_VBROADCASTF64X4,
  XED_ICLASS_VBROADCASTI128,
  XED_ICLASS_VBROADCASTI32X2,
  XED_ICLASS_VBROADCASTI32X4,
  XED_ICLASS_VBROADCASTI32X8,
  XED_ICLASS_VBROADCASTI64X2,
  XED_ICLASS_VBROADCASTI64X4,
  XED_ICLASS_VBROADCASTSD,
  XED_ICLASS_VBROADCASTSS,
  XED_ICLASS_VCMPPD,
  XED_ICLASS_VCMPPS,
  XED_ICLASS_VCMPSD,
  XED_ICLASS_VCMPSS,
  XED_ICLASS_VCOMISD,
  XED_ICLASS_VCOMISS,
  XED_ICLASS_VCOMPRESSPD,
  XED_ICLASS_VCOMPRESSPS,
  XED_ICLASS_VCVTDQ2PD,
  XED_ICLASS_VCVTDQ2PS,
  XED_ICLASS_VCVTPD2DQ,
  XED_ICLASS_VCVTPD2PS,
  XED_ICLASS_VCVTPD2QQ,
  XED_ICLASS_VCVTPD2UDQ,
  XED_ICLASS_VCVTPD2UQQ,
  XED_ICLASS_VCVTPH2PS,
  XED_ICLASS_VCVTPS2DQ,
  XED_ICLASS_VCVTPS2PD,
  XED_ICLASS_VCVTPS2PH,
  XED_ICLASS_VCVTPS2QQ,
  XED_ICLASS_VCVTPS2UDQ,
  XED_ICLASS_VCVTPS2UQQ,
  XED_ICLASS_VCVTQQ2PD,
  XED_ICLASS_VCVTQQ2PS,
  XED_ICLASS_VCVTSD2SI,
  XED_ICLASS_VCVTSD2SS,
  XED_ICLASS_VCVTSD2USI,
  XED_ICLASS_VCVTSI2SD,
  XED_ICLASS_VCVTSI2SS,
  XED_ICLASS_VCVTSS2SD,
  XED_ICLASS_VCVTSS2SI,
  XED_ICLASS_VCVTSS2USI,
  XED_ICLASS_VCVTTPD2DQ,
  XED_ICLASS_VCVTTPD2QQ,
  XED_ICLASS_VCVTTPD2UDQ,
  XED_ICLASS_VCVTTPD2UQQ,
  XED_ICLASS_VCVTTPS2DQ,
  XED_ICLASS_VCVTTPS2QQ,
  XED_ICLASS_VCVTTPS2UDQ,
  XED_ICLASS_VCVTTPS2UQQ,
  XED_ICLASS_VCVTTSD2SI,
  XED_ICLASS_VCVTTSD2USI,
  XED_ICLASS_VCVTTSS2SI,
  XED_ICLASS_VCVTTSS2USI,
  XED_ICLASS_VCVTUDQ2PD,
  XED_ICLASS_VCVTUDQ2PS,
  XED_ICLASS_VCVTUQQ2PD,
  XED_ICLASS_VCVTUQQ2PS,
  XED_ICLASS_VCVTUSI2SD,
  XED_ICLASS_VCVTUSI2SS,
  XED_ICLASS_VDBPSADBW,
  XED_ICLASS_VDIVPD,
  XED_ICLASS_VDIVPS,
  XED_ICLASS_VDIVSD,
  XED_ICLASS_VDIVSS,
  XED_ICLASS_VDPPD,
  XED_ICLASS_VDPPS,
  XED_ICLASS_VERR,
  XED_ICLASS_VERW,
  XED_ICLASS_VEXP2PD,
  XED_ICLASS_VEXP2PS,
  XED_ICLASS_VEXPANDPD,
  XED_ICLASS_VEXPANDPS,
  XED_ICLASS_VEXTRACTF128,
  XED_ICLASS_VEXTRACTF32X4,
  XED_ICLASS_VEXTRACTF32X8,
  XED_ICLASS_VEXTRACTF64X2,
  XED_ICLASS_VEXTRACTF64X4,
  XED_ICLASS_VEXTRACTI128,
  XED_ICLASS_VEXTRACTI32X4,
  XED_ICLASS_VEXTRACTI32X8,
  XED_ICLASS_VEXTRACTI64X2,
  XED_ICLASS_VEXTRACTI64X4,
  XED_ICLASS_VEXTRACTPS,
  XED_ICLASS_VFIXUPIMMPD,
  XED_ICLASS_VFIXUPIMMPS,
  XED_ICLASS_VFIXUPIMMSD,
  XED_ICLASS_VFIXUPIMMSS,
  XED_ICLASS_VFMADD132PD,
  XED_ICLASS_VFMADD132PS,
  XED_ICLASS_VFMADD132SD,
  XED_ICLASS_VFMADD132SS,
  XED_ICLASS_VFMADD213PD,
  XED_ICLASS_VFMADD213PS,
  XED_ICLASS_VFMADD213SD,
  XED_ICLASS_VFMADD213SS,
  XED_ICLASS_VFMADD231PD,
  XED_ICLASS_VFMADD231PS,
  XED_ICLASS_VFMADD231SD,
  XED_ICLASS_VFMADD231SS,
  XED_ICLASS_VFMADDPD,
  XED_ICLASS_VFMADDPS,
  XED_ICLASS_VFMADDSD,
  XED_ICLASS_VFMADDSS,
  XED_ICLASS_VFMADDSUB132PD,
  XED_ICLASS_VFMADDSUB132PS,
  XED_ICLASS_VFMADDSUB213PD,
  XED_ICLASS_VFMADDSUB213PS,
  XED_ICLASS_VFMADDSUB231PD,
  XED_ICLASS_VFMADDSUB231PS,
  XED_ICLASS_VFMADDSUBPD,
  XED_ICLASS_VFMADDSUBPS,
  XED_ICLASS_VFMSUB132PD,
  XED_ICLASS_VFMSUB132PS,
  XED_ICLASS_VFMSUB132SD,
  XED_ICLASS_VFMSUB132SS,
  XED_ICLASS_VFMSUB213PD,
  XED_ICLASS_VFMSUB213PS,
  XED_ICLASS_VFMSUB213SD,
  XED_ICLASS_VFMSUB213SS,
  XED_ICLASS_VFMSUB231PD,
  XED_ICLASS_VFMSUB231PS,
  XED_ICLASS_VFMSUB231SD,
  XED_ICLASS_VFMSUB231SS,
  XED_ICLASS_VFMSUBADD132PD,
  XED_ICLASS_VFMSUBADD132PS,
  XED_ICLASS_VFMSUBADD213PD,
  XED_ICLASS_VFMSUBADD213PS,
  XED_ICLASS_VFMSUBADD231PD,
  XED_ICLASS_VFMSUBADD231PS,
  XED_ICLASS_VFMSUBADDPD,
  XED_ICLASS_VFMSUBADDPS,
  XED_ICLASS_VFMSUBPD,
  XED_ICLASS_VFMSUBPS,
  XED_ICLASS_VFMSUBSD,
  XED_ICLASS_VFMSUBSS,
  XED_ICLASS_VFNMADD132PD,
  XED_ICLASS_VFNMADD132PS,
  XED_ICLASS_VFNMADD132SD,
  XED_ICLASS_VFNMADD132SS,
  XED_ICLASS_VFNMADD213PD,
  XED_ICLASS_VFNMADD213PS,
  XED_ICLASS_VFNMADD213SD,
  XED_ICLASS_VFNMADD213SS,
  XED_ICLASS_VFNMADD231PD,
  XED_ICLASS_VFNMADD231PS,
  XED_ICLASS_VFNMADD231SD,
  XED_ICLASS_VFNMADD231SS,
  XED_ICLASS_VFNMADDPD,
  XED_ICLASS_VFNMADDPS,
  XED_ICLASS_VFNMADDSD,
  XED_ICLASS_VFNMADDSS,
  XED_ICLASS_VFNMSUB132PD,
  XED_ICLASS_VFNMSUB132PS,
  XED_ICLASS_VFNMSUB132SD,
  XED_ICLASS_VFNMSUB132SS,
  XED_ICLASS_VFNMSUB213PD,
  XED_ICLASS_VFNMSUB213PS,
  XED_ICLASS_VFNMSUB213SD,
  XED_ICLASS_VFNMSUB213SS,
  XED_ICLASS_VFNMSUB231PD,
  XED_ICLASS_VFNMSUB231PS,
  XED_ICLASS_VFNMSUB231SD,
  XED_ICLASS_VFNMSUB231SS,
  XED_ICLASS_VFNMSUBPD,
  XED_ICLASS_VFNMSUBPS,
  XED_ICLASS_VFNMSUBSD,
  XED_ICLASS_VFNMSUBSS,
  XED_ICLASS_VFPCLASSPD,
  XED_ICLASS_VFPCLASSPS,
  XED_ICLASS_VFPCLASSSD,
  XED_ICLASS_VFPCLASSSS,
  XED_ICLASS_VFRCZPD,
  XED_ICLASS_VFRCZPS,
  XED_ICLASS_VFRCZSD,
  XED_ICLASS_VFRCZSS,
  XED_ICLASS_VGATHERDPD,
  XED_ICLASS_VGATHERDPS,
  XED_ICLASS_VGATHERPF0DPD,
  XED_ICLASS_VGATHERPF0DPS,
  XED_ICLASS_VGATHERPF0QPD,
  XED_ICLASS_VGATHERPF0QPS,
  XED_ICLASS_VGATHERPF1DPD,
  XED_ICLASS_VGATHERPF1DPS,
  XED_ICLASS_VGATHERPF1QPD,
  XED_ICLASS_VGATHERPF1QPS,
  XED_ICLASS_VGATHERQPD,
  XED_ICLASS_VGATHERQPS,
  XED_ICLASS_VGETEXPPD,
  XED_ICLASS_VGETEXPPS,
  XED_ICLASS_VGETEXPSD,
  XED_ICLASS_VGETEXPSS,
  XED_ICLASS_VGETMANTPD,
  XED_ICLASS_VGETMANTPS,
  XED_ICLASS_VGETMANTSD,
  XED_ICLASS_VGETMANTSS,
  XED_ICLASS_VGF2P8AFFINEINVQB,
  XED_ICLASS_VGF2P8AFFINEQB,
  XED_ICLASS_VGF2P8MULB,
  XED_ICLASS_VHADDPD,
  XED_ICLASS_VHADDPS,
  XED_ICLASS_VHSUBPD,
  XED_ICLASS_VHSUBPS,
  XED_ICLASS_VINSERTF128,
  XED_ICLASS_VINSERTF32X4,
  XED_ICLASS_VINSERTF32X8,
  XED_ICLASS_VINSERTF64X2,
  XED_ICLASS_VINSERTF64X4,
  XED_ICLASS_VINSERTI128,
  XED_ICLASS_VINSERTI32X4,
  XED_ICLASS_VINSERTI32X8,
  XED_ICLASS_VINSERTI64X2,
  XED_ICLASS_VINSERTI64X4,
  XED_ICLASS_VINSERTPS,
  XED_ICLASS_VLDDQU,
  XED_ICLASS_VLDMXCSR,
  XED_ICLASS_VMASKMOVDQU,
  XED_ICLASS_VMASKMOVPD,
  XED_ICLASS_VMASKMOVPS,
  XED_ICLASS_VMAXPD,
  XED_ICLASS_VMAXPS,
  XED_ICLASS_VMAXSD,
  XED_ICLASS_VMAXSS,
  XED_ICLASS_VMCALL,
  XED_ICLASS_VMCLEAR,
  XED_ICLASS_VMFUNC,
  XED_ICLASS_VMINPD,
  XED_ICLASS_VMINPS,
  XED_ICLASS_VMINSD,
  XED_ICLASS_VMINSS,
  XED_ICLASS_VMLAUNCH,
  XED_ICLASS_VMLOAD,
  XED_ICLASS_VMMCALL,
  XED_ICLASS_VMOVAPD,
  XED_ICLASS_VMOVAPS,
  XED_ICLASS_VMOVD,
  XED_ICLASS_VMOVDDUP,
  XED_ICLASS_VMOVDQA,
  XED_ICLASS_VMOVDQA32,
  XED_ICLASS_VMOVDQA64,
  XED_ICLASS_VMOVDQU,
  XED_ICLASS_VMOVDQU16,
  XED_ICLASS_VMOVDQU32,
  XED_ICLASS_VMOVDQU64,
  XED_ICLASS_VMOVDQU8,
  XED_ICLASS_VMOVHLPS,
  XED_ICLASS_VMOVHPD,
  XED_ICLASS_VMOVHPS,
  XED_ICLASS_VMOVLHPS,
  XED_ICLASS_VMOVLPD,
  XED_ICLASS_VMOVLPS,
  XED_ICLASS_VMOVMSKPD,
  XED_ICLASS_VMOVMSKPS,
  XED_ICLASS_VMOVNTDQ,
  XED_ICLASS_VMOVNTDQA,
  XED_ICLASS_VMOVNTPD,
  XED_ICLASS_VMOVNTPS,
  XED_ICLASS_VMOVQ,
  XED_ICLASS_VMOVSD,
  XED_ICLASS_VMOVSHDUP,
  XED_ICLASS_VMOVSLDUP,
  XED_ICLASS_VMOVSS,
  XED_ICLASS_VMOVUPD,
  XED_ICLASS_VMOVUPS,
  XED_ICLASS_VMPSADBW,
  XED_ICLASS_VMPTRLD,
  XED_ICLASS_VMPTRST,
  XED_ICLASS_VMREAD,
  XED_ICLASS_VMRESUME,
  XED_ICLASS_VMRUN,
  XED_ICLASS_VMSAVE,
  XED_ICLASS_VMULPD,
  XED_ICLASS_VMULPS,
  XED_ICLASS_VMULSD,
  XED_ICLASS_VMULSS,
  XED_ICLASS_VMWRITE,
  XED_ICLASS_VMXOFF,
  XED_ICLASS_VMXON,
  XED_ICLASS_VORPD,
  XED_ICLASS_VORPS,
  XED_ICLASS_VP4DPWSSD,
  XED_ICLASS_VP4DPWSSDS,
  XED_ICLASS_VPABSB,
  XED_ICLASS_VPABSD,
  XED_ICLASS_VPABSQ,
  XED_ICLASS_VPABSW,
  XED_ICLASS_VPACKSSDW,
  XED_ICLASS_VPACKSSWB,
  XED_ICLASS_VPACKUSDW,
  XED_ICLASS_VPACKUSWB,
  XED_ICLASS_VPADDB,
  XED_ICLASS_VPADDD,
  XED_ICLASS_VPADDQ,
  XED_ICLASS_VPADDSB,
  XED_ICLASS_VPADDSW,
  XED_ICLASS_VPADDUSB,
  XED_ICLASS_VPADDUSW,
  XED_ICLASS_VPADDW,
  XED_ICLASS_VPALIGNR,
  XED_ICLASS_VPAND,
  XED_ICLASS_VPANDD,
  XED_ICLASS_VPANDN,
  XED_ICLASS_VPANDND,
  XED_ICLASS_VPANDNQ,
  XED_ICLASS_VPANDQ,
  XED_ICLASS_VPAVGB,
  XED_ICLASS_VPAVGW,
  XED_ICLASS_VPBLENDD,
  XED_ICLASS_VPBLENDMB,
  XED_ICLASS_VPBLENDMD,
  XED_ICLASS_VPBLENDMQ,
  XED_ICLASS_VPBLENDMW,
  XED_ICLASS_VPBLENDVB,
  XED_ICLASS_VPBLENDW,
  XED_ICLASS_VPBROADCASTB,
  XED_ICLASS_VPBROADCASTD,
  XED_ICLASS_VPBROADCASTMB2Q,
  XED_ICLASS_VPBROADCASTMW2D,
  XED_ICLASS_VPBROADCASTQ,
  XED_ICLASS_VPBROADCASTW,
  XED_ICLASS_VPCLMULQDQ,
  XED_ICLASS_VPCMOV,
  XED_ICLASS_VPCMPB,
  XED_ICLASS_VPCMPD,
  XED_ICLASS_VPCMPEQB,
  XED_ICLASS_VPCMPEQD,
  XED_ICLASS_VPCMPEQQ,
  XED_ICLASS_VPCMPEQW,
  XED_ICLASS_VPCMPESTRI,
  XED_ICLASS_VPCMPESTRM,
  XED_ICLASS_VPCMPGTB,
  XED_ICLASS_VPCMPGTD,
  XED_ICLASS_VPCMPGTQ,
  XED_ICLASS_VPCMPGTW,
  XED_ICLASS_VPCMPISTRI,
  XED_ICLASS_VPCMPISTRM,
  XED_ICLASS_VPCMPQ,
  XED_ICLASS_VPCMPUB,
  XED_ICLASS_VPCMPUD,
  XED_ICLASS_VPCMPUQ,
  XED_ICLASS_VPCMPUW,
  XED_ICLASS_VPCMPW,
  XED_ICLASS_VPCOMB,
  XED_ICLASS_VPCOMD,
  XED_ICLASS_VPCOMPRESSB,
  XED_ICLASS_VPCOMPRESSD,
  XED_ICLASS_VPCOMPRESSQ,
  XED_ICLASS_VPCOMPRESSW,
  XED_ICLASS_VPCOMQ,
  XED_ICLASS_VPCOMUB,
  XED_ICLASS_VPCOMUD,
  XED_ICLASS_VPCOMUQ,
  XED_ICLASS_VPCOMUW,
  XED_ICLASS_VPCOMW,
  XED_ICLASS_VPCONFLICTD,
  XED_ICLASS_VPCONFLICTQ,
  XED_ICLASS_VPDPBUSD,
  XED_ICLASS_VPDPBUSDS,
  XED_ICLASS_VPDPWSSD,
  XED_ICLASS_VPDPWSSDS,
  XED_ICLASS_VPERM2F128,
  XED_ICLASS_VPERM2I128,
  XED_ICLASS_VPERMB,
  XED_ICLASS_VPERMD,
  XED_ICLASS_VPERMI2B,
  XED_ICLASS_VPERMI2D,
  XED_ICLASS_VPERMI2PD,
  XED_ICLASS_VPERMI2PS,
  XED_ICLASS_VPERMI2Q,
  XED_ICLASS_VPERMI2W,
  XED_ICLASS_VPERMIL2PD,
  XED_ICLASS_VPERMIL2PS,
  XED_ICLASS_VPERMILPD,
  XED_ICLASS_VPERMILPS,
  XED_ICLASS_VPERMPD,
  XED_ICLASS_VPERMPS,
  XED_ICLASS_VPERMQ,
  XED_ICLASS_VPERMT2B,
  XED_ICLASS_VPERMT2D,
  XED_ICLASS_VPERMT2PD,
  XED_ICLASS_VPERMT2PS,
  XED_ICLASS_VPERMT2Q,
  XED_ICLASS_VPERMT2W,
  XED_ICLASS_VPERMW,
  XED_ICLASS_VPEXPANDB,
  XED_ICLASS_VPEXPANDD,
  XED_ICLASS_VPEXPANDQ,
  XED_ICLASS_VPEXPANDW,
  XED_ICLASS_VPEXTRB,
  XED_ICLASS_VPEXTRD,
  XED_ICLASS_VPEXTRQ,
  XED_ICLASS_VPEXTRW,
  XED_ICLASS_VPGATHERDD,
  XED_ICLASS_VPGATHERDQ,
  XED_ICLASS_VPGATHERQD,
  XED_ICLASS_VPGATHERQQ,
  XED_ICLASS_VPHADDBD,
  XED_ICLASS_VPHADDBQ,
  XED_ICLASS_VPHADDBW,
  XED_ICLASS_VPHADDD,
  XED_ICLASS_VPHADDDQ,
  XED_ICLASS_VPHADDSW,
  XED_ICLASS_VPHADDUBD,
  XED_ICLASS_VPHADDUBQ,
  XED_ICLASS_VPHADDUBW,
  XED_ICLASS_VPHADDUDQ,
  XED_ICLASS_VPHADDUWD,
  XED_ICLASS_VPHADDUWQ,
  XED_ICLASS_VPHADDW,
  XED_ICLASS_VPHADDWD,
  XED_ICLASS_VPHADDWQ,
  XED_ICLASS_VPHMINPOSUW,
  XED_ICLASS_VPHSUBBW,
  XED_ICLASS_VPHSUBD,
  XED_ICLASS_VPHSUBDQ,
  XED_ICLASS_VPHSUBSW,
  XED_ICLASS_VPHSUBW,
  XED_ICLASS_VPHSUBWD,
  XED_ICLASS_VPINSRB,
  XED_ICLASS_VPINSRD,
  XED_ICLASS_VPINSRQ,
  XED_ICLASS_VPINSRW,
  XED_ICLASS_VPLZCNTD,
  XED_ICLASS_VPLZCNTQ,
  XED_ICLASS_VPMACSDD,
  XED_ICLASS_VPMACSDQH,
  XED_ICLASS_VPMACSDQL,
  XED_ICLASS_VPMACSSDD,
  XED_ICLASS_VPMACSSDQH,
  XED_ICLASS_VPMACSSDQL,
  XED_ICLASS_VPMACSSWD,
  XED_ICLASS_VPMACSSWW,
  XED_ICLASS_VPMACSWD,
  XED_ICLASS_VPMACSWW,
  XED_ICLASS_VPMADCSSWD,
  XED_ICLASS_VPMADCSWD,
  XED_ICLASS_VPMADD52HUQ,
  XED_ICLASS_VPMADD52LUQ,
  XED_ICLASS_VPMADDUBSW,
  XED_ICLASS_VPMADDWD,
  XED_ICLASS_VPMASKMOVD,
  XED_ICLASS_VPMASKMOVQ,
  XED_ICLASS_VPMAXSB,
  XED_ICLASS_VPMAXSD,
  XED_ICLASS_VPMAXSQ,
  XED_ICLASS_VPMAXSW,
  XED_ICLASS_VPMAXUB,
  XED_ICLASS_VPMAXUD,
  XED_ICLASS_VPMAXUQ,
  XED_ICLASS_VPMAXUW,
  XED_ICLASS_VPMINSB,
  XED_ICLASS_VPMINSD,
  XED_ICLASS_VPMINSQ,
  XED_ICLASS_VPMINSW,
  XED_ICLASS_VPMINUB,
  XED_ICLASS_VPMINUD,
  XED_ICLASS_VPMINUQ,
  XED_ICLASS_VPMINUW,
  XED_ICLASS_VPMOVB2M,
  XED_ICLASS_VPMOVD2M,
  XED_ICLASS_VPMOVDB,
  XED_ICLASS_VPMOVDW,
  XED_ICLASS_VPMOVM2B,
  XED_ICLASS_VPMOVM2D,
  XED_ICLASS_VPMOVM2Q,
  XED_ICLASS_VPMOVM2W,
  XED_ICLASS_VPMOVMSKB,
  XED_ICLASS_VPMOVQ2M,
  XED_ICLASS_VPMOVQB,
  XED_ICLASS_VPMOVQD,
  XED_ICLASS_VPMOVQW,
  XED_ICLASS_VPMOVSDB,
  XED_ICLASS_VPMOVSDW,
  XED_ICLASS_VPMOVSQB,
  XED_ICLASS_VPMOVSQD,
  XED_ICLASS_VPMOVSQW,
  XED_ICLASS_VPMOVSWB,
  XED_ICLASS_VPMOVSXBD,
  XED_ICLASS_VPMOVSXBQ,
  XED_ICLASS_VPMOVSXBW,
  XED_ICLASS_VPMOVSXDQ,
  XED_ICLASS_VPMOVSXWD,
  XED_ICLASS_VPMOVSXWQ,
  XED_ICLASS_VPMOVUSDB,
  XED_ICLASS_VPMOVUSDW,
  XED_ICLASS_VPMOVUSQB,
  XED_ICLASS_VPMOVUSQD,
  XED_ICLASS_VPMOVUSQW,
  XED_ICLASS_VPMOVUSWB,
  XED_ICLASS_VPMOVW2M,
  XED_ICLASS_VPMOVWB,
  XED_ICLASS_VPMOVZXBD,
  XED_ICLASS_VPMOVZXBQ,
  XED_ICLASS_VPMOVZXBW,
  XED_ICLASS_VPMOVZXDQ,
  XED_ICLASS_VPMOVZXWD,
  XED_ICLASS_VPMOVZXWQ,
  XED_ICLASS_VPMULDQ,
  XED_ICLASS_VPMULHRSW,
  XED_ICLASS_VPMULHUW,
  XED_ICLASS_VPMULHW,
  XED_ICLASS_VPMULLD,
  XED_ICLASS_VPMULLQ,
  XED_ICLASS_VPMULLW,
  XED_ICLASS_VPMULTISHIFTQB,
  XED_ICLASS_VPMULUDQ,
  XED_ICLASS_VPOPCNTB,
  XED_ICLASS_VPOPCNTD,
  XED_ICLASS_VPOPCNTQ,
  XED_ICLASS_VPOPCNTW,
  XED_ICLASS_VPOR,
  XED_ICLASS_VPORD,
  XED_ICLASS_VPORQ,
  XED_ICLASS_VPPERM,
  XED_ICLASS_VPROLD,
  XED_ICLASS_VPROLQ,
  XED_ICLASS_VPROLVD,
  XED_ICLASS_VPROLVQ,
  XED_ICLASS_VPRORD,
  XED_ICLASS_VPRORQ,
  XED_ICLASS_VPRORVD,
  XED_ICLASS_VPRORVQ,
  XED_ICLASS_VPROTB,
  XED_ICLASS_VPROTD,
  XED_ICLASS_VPROTQ,
  XED_ICLASS_VPROTW,
  XED_ICLASS_VPSADBW,
  XED_ICLASS_VPSCATTERDD,
  XED_ICLASS_VPSCATTERDQ,
  XED_ICLASS_VPSCATTERQD,
  XED_ICLASS_VPSCATTERQQ,
  XED_ICLASS_VPSHAB,
  XED_ICLASS_VPSHAD,
  XED_ICLASS_VPSHAQ,
  XED_ICLASS_VPSHAW,
  XED_ICLASS_VPSHLB,
  XED_ICLASS_VPSHLD,
  XED_ICLASS_VPSHLDD,
  XED_ICLASS_VPSHLDQ,
  XED_ICLASS_VPSHLDVD,
  XED_ICLASS_VPSHLDVQ,
  XED_ICLASS_VPSHLDVW,
  XED_ICLASS_VPSHLDW,
  XED_ICLASS_VPSHLQ,
  XED_ICLASS_VPSHLW,
  XED_ICLASS_VPSHRDD,
  XED_ICLASS_VPSHRDQ,
  XED_ICLASS_VPSHRDVD,
  XED_ICLASS_VPSHRDVQ,
  XED_ICLASS_VPSHRDVW,
  XED_ICLASS_VPSHRDW,
  XED_ICLASS_VPSHUFB,
  XED_ICLASS_VPSHUFBITQMB,
  XED_ICLASS_VPSHUFD,
  XED_ICLASS_VPSHUFHW,
  XED_ICLASS_VPSHUFLW,
  XED_ICLASS_VPSIGNB,
  XED_ICLASS_VPSIGND,
  XED_ICLASS_VPSIGNW,
  XED_ICLASS_VPSLLD,
  XED_ICLASS_VPSLLDQ,
  XED_ICLASS_VPSLLQ,
  XED_ICLASS_VPSLLVD,
  XED_ICLASS_VPSLLVQ,
  XED_ICLASS_VPSLLVW,
  XED_ICLASS_VPSLLW,
  XED_ICLASS_VPSRAD,
  XED_ICLASS_VPSRAQ,
  XED_ICLASS_VPSRAVD,
  XED_ICLASS_VPSRAVQ,
  XED_ICLASS_VPSRAVW,
  XED_ICLASS_VPSRAW,
  XED_ICLASS_VPSRLD,
  XED_ICLASS_VPSRLDQ,
  XED_ICLASS_VPSRLQ,
  XED_ICLASS_VPSRLVD,
  XED_ICLASS_VPSRLVQ,
  XED_ICLASS_VPSRLVW,
  XED_ICLASS_VPSRLW,
  XED_ICLASS_VPSUBB,
  XED_ICLASS_VPSUBD,
  XED_ICLASS_VPSUBQ,
  XED_ICLASS_VPSUBSB,
  XED_ICLASS_VPSUBSW,
  XED_ICLASS_VPSUBUSB,
  XED_ICLASS_VPSUBUSW,
  XED_ICLASS_VPSUBW,
  XED_ICLASS_VPTERNLOGD,
  XED_ICLASS_VPTERNLOGQ,
  XED_ICLASS_VPTEST,
  XED_ICLASS_VPTESTMB,
  XED_ICLASS_VPTESTMD,
  XED_ICLASS_VPTESTMQ,
  XED_ICLASS_VPTESTMW,
  XED_ICLASS_VPTESTNMB,
  XED_ICLASS_VPTESTNMD,
  XED_ICLASS_VPTESTNMQ,
  XED_ICLASS_VPTESTNMW,
  XED_ICLASS_VPUNPCKHBW,
  XED_ICLASS_VPUNPCKHDQ,
  XED_ICLASS_VPUNPCKHQDQ,
  XED_ICLASS_VPUNPCKHWD,
  XED_ICLASS_VPUNPCKLBW,
  XED_ICLASS_VPUNPCKLDQ,
  XED_ICLASS_VPUNPCKLQDQ,
  XED_ICLASS_VPUNPCKLWD,
  XED_ICLASS_VPXOR,
  XED_ICLASS_VPXORD,
  XED_ICLASS_VPXORQ,
  XED_ICLASS_VRANGEPD,
  XED_ICLASS_VRANGEPS,
  XED_ICLASS_VRANGESD,
  XED_ICLASS_VRANGESS,
  XED_ICLASS_VRCP14PD,
  XED_ICLASS_VRCP14PS,
  XED_ICLASS_VRCP14SD,
  XED_ICLASS_VRCP14SS,
  XED_ICLASS_VRCP28PD,
  XED_ICLASS_VRCP28PS,
  XED_ICLASS_VRCP28SD,
  XED_ICLASS_VRCP28SS,
  XED_ICLASS_VRCPPS,
  XED_ICLASS_VRCPSS,
  XED_ICLASS_VREDUCEPD,
  XED_ICLASS_VREDUCEPS,
  XED_ICLASS_VREDUCESD,
  XED_ICLASS_VREDUCESS,
  XED_ICLASS_VRNDSCALEPD,
  XED_ICLASS_VRNDSCALEPS,
  XED_ICLASS_VRNDSCALESD,
  XED_ICLASS_VRNDSCALESS,
  XED_ICLASS_VROUNDPD,
  XED_ICLASS_VROUNDPS,
  XED_ICLASS_VROUNDSD,
  XED_ICLASS_VROUNDSS,
  XED_ICLASS_VRSQRT14PD,
  XED_ICLASS_VRSQRT14PS,
  XED_ICLASS_VRSQRT14SD,
  XED_ICLASS_VRSQRT14SS,
  XED_ICLASS_VRSQRT28PD,
  XED_ICLASS_VRSQRT28PS,
  XED_ICLASS_VRSQRT28SD,
  XED_ICLASS_VRSQRT28SS,
  XED_ICLASS_VRSQRTPS,
  XED_ICLASS_VRSQRTSS,
  XED_ICLASS_VSCALEFPD,
  XED_ICLASS_VSCALEFPS,
  XED_ICLASS_VSCALEFSD,
  XED_ICLASS_VSCALEFSS,
  XED_ICLASS_VSCATTERDPD,
  XED_ICLASS_VSCATTERDPS,
  XED_ICLASS_VSCATTERPF0DPD,
  XED_ICLASS_VSCATTERPF0DPS,
  XED_ICLASS_VSCATTERPF0QPD,
  XED_ICLASS_VSCATTERPF0QPS,
  XED_ICLASS_VSCATTERPF1DPD,
  XED_ICLASS_VSCATTERPF1DPS,
  XED_ICLASS_VSCATTERPF1QPD,
  XED_ICLASS_VSCATTERPF1QPS,
  XED_ICLASS_VSCATTERQPD,
  XED_ICLASS_VSCATTERQPS,
  XED_ICLASS_VSHUFF32X4,
  XED_ICLASS_VSHUFF64X2,
  XED_ICLASS_VSHUFI32X4,
  XED_ICLASS_VSHUFI64X2,
  XED_ICLASS_VSHUFPD,
  XED_ICLASS_VSHUFPS,
  XED_ICLASS_VSQRTPD,
  XED_ICLASS_VSQRTPS,
  XED_ICLASS_VSQRTSD,
  XED_ICLASS_VSQRTSS,
  XED_ICLASS_VSTMXCSR,
  XED_ICLASS_VSUBPD,
  XED_ICLASS_VSUBPS,
  XED_ICLASS_VSUBSD,
  XED_ICLASS_VSUBSS,
  XED_ICLASS_VTESTPD,
  XED_ICLASS_VTESTPS,
  XED_ICLASS_VUCOMISD,
  XED_ICLASS_VUCOMISS,
  XED_ICLASS_VUNPCKHPD,
  XED_ICLASS_VUNPCKHPS,
  XED_ICLASS_VUNPCKLPD,
  XED_ICLASS_VUNPCKLPS,
  XED_ICLASS_VXORPD,
  XED_ICLASS_VXORPS,
  XED_ICLASS_VZEROALL,
  XED_ICLASS_VZEROUPPER,
  XED_ICLASS_WBINVD,
  XED_ICLASS_WRFSBASE,
  XED_ICLASS_WRGSBASE,
  XED_ICLASS_WRMSR,
  XED_ICLASS_WRPKRU,
  XED_ICLASS_WRSSD,
  XED_ICLASS_WRSSQ,
  XED_ICLASS_WRUSSD,
  XED_ICLASS_WRUSSQ,
  XED_ICLASS_XABORT,
  XED_ICLASS_XADD,
  XED_ICLASS_XADD_LOCK,
  XED_ICLASS_XBEGIN,
  XED_ICLASS_XCHG,
  XED_ICLASS_XEND,
  XED_ICLASS_XGETBV,
  XED_ICLASS_XLAT,
  XED_ICLASS_XOR,
  XED_ICLASS_XORPD,
  XED_ICLASS_XORPS,
  XED_ICLASS_XOR_LOCK,
  XED_ICLASS_XRSTOR,
  XED_ICLASS_XRSTOR64,
  XED_ICLASS_XRSTORS,
  XED_ICLASS_XRSTORS64,
  XED_ICLASS_XSAVE,
  XED_ICLASS_XSAVE64,
  XED_ICLASS_XSAVEC,
  XED_ICLASS_XSAVEC64,
  XED_ICLASS_XSAVEOPT,
  XED_ICLASS_XSAVEOPT64,
  XED_ICLASS_XSAVES,
  XED_ICLASS_XSAVES64,
  XED_ICLASS_XSETBV,
  XED_ICLASS_XTEST,
  XED_ICLASS_LAST
} xed_iclass_enum_t;





 xed_iclass_enum_t str2xed_iclass_enum_t(const char* s);




 const char* xed_iclass_enum_t2str(const xed_iclass_enum_t p);




 xed_iclass_enum_t xed_iclass_enum_t_last(void);
#line 1617 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-iclass-enum.h"

#line 100 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-category-enum.h"





































#line 1 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"




















































































#line 39 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-category-enum.h"
typedef enum {
  XED_CATEGORY_INVALID,
  XED_CATEGORY_3DNOW,
  XED_CATEGORY_AES,
  XED_CATEGORY_AVX,
  XED_CATEGORY_AVX2,
  XED_CATEGORY_AVX2GATHER,
  XED_CATEGORY_AVX512,
  XED_CATEGORY_AVX512_4FMAPS,
  XED_CATEGORY_AVX512_4VNNIW,
  XED_CATEGORY_AVX512_BITALG,
  XED_CATEGORY_AVX512_VBMI,
  XED_CATEGORY_BDW,
  XED_CATEGORY_BINARY,
  XED_CATEGORY_BITBYTE,
  XED_CATEGORY_BLEND,
  XED_CATEGORY_BMI1,
  XED_CATEGORY_BMI2,
  XED_CATEGORY_BROADCAST,
  XED_CATEGORY_CALL,
  XED_CATEGORY_CET,
  XED_CATEGORY_CLFLUSHOPT,
  XED_CATEGORY_CLWB,
  XED_CATEGORY_CLZERO,
  XED_CATEGORY_CMOV,
  XED_CATEGORY_COMPRESS,
  XED_CATEGORY_COND_BR,
  XED_CATEGORY_CONFLICT,
  XED_CATEGORY_CONVERT,
  XED_CATEGORY_DATAXFER,
  XED_CATEGORY_DECIMAL,
  XED_CATEGORY_EXPAND,
  XED_CATEGORY_FCMOV,
  XED_CATEGORY_FLAGOP,
  XED_CATEGORY_FMA4,
  XED_CATEGORY_GATHER,
  XED_CATEGORY_GFNI,
  XED_CATEGORY_IFMA,
  XED_CATEGORY_INTERRUPT,
  XED_CATEGORY_IO,
  XED_CATEGORY_IOSTRINGOP,
  XED_CATEGORY_KMASK,
  XED_CATEGORY_LOGICAL,
  XED_CATEGORY_LOGICAL_FP,
  XED_CATEGORY_LZCNT,
  XED_CATEGORY_MISC,
  XED_CATEGORY_MMX,
  XED_CATEGORY_MPX,
  XED_CATEGORY_NOP,
  XED_CATEGORY_PCLMULQDQ,
  XED_CATEGORY_PKU,
  XED_CATEGORY_POP,
  XED_CATEGORY_PREFETCH,
  XED_CATEGORY_PREFETCHWT1,
  XED_CATEGORY_PT,
  XED_CATEGORY_PUSH,
  XED_CATEGORY_RDPID,
  XED_CATEGORY_RDRAND,
  XED_CATEGORY_RDSEED,
  XED_CATEGORY_RDWRFSGS,
  XED_CATEGORY_RET,
  XED_CATEGORY_ROTATE,
  XED_CATEGORY_SCATTER,
  XED_CATEGORY_SEGOP,
  XED_CATEGORY_SEMAPHORE,
  XED_CATEGORY_SETCC,
  XED_CATEGORY_SGX,
  XED_CATEGORY_SHA,
  XED_CATEGORY_SHIFT,
  XED_CATEGORY_SMAP,
  XED_CATEGORY_SSE,
  XED_CATEGORY_STRINGOP,
  XED_CATEGORY_STTNI,
  XED_CATEGORY_SYSCALL,
  XED_CATEGORY_SYSRET,
  XED_CATEGORY_SYSTEM,
  XED_CATEGORY_TBM,
  XED_CATEGORY_UNCOND_BR,
  XED_CATEGORY_VAES,
  XED_CATEGORY_VBMI2,
  XED_CATEGORY_VFMA,
  XED_CATEGORY_VPCLMULQDQ,
  XED_CATEGORY_VTX,
  XED_CATEGORY_WIDENOP,
  XED_CATEGORY_X87_ALU,
  XED_CATEGORY_XOP,
  XED_CATEGORY_XSAVE,
  XED_CATEGORY_XSAVEOPT,
  XED_CATEGORY_LAST
} xed_category_enum_t;





 xed_category_enum_t str2xed_category_enum_t(const char* s);




 const char* xed_category_enum_t2str(const xed_category_enum_t p);




 xed_category_enum_t xed_category_enum_t_last(void);
#line 146 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-category-enum.h"
#line 101 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
}

namespace LEVEL_BASE
{
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"






class COMMAND_LINE_ARGUMENTS
{
  public:
   


    COMMAND_LINE_ARGUMENTS()
    {
        Enter(0, 0, 0);
    }

   
















    COMMAND_LINE_ARGUMENTS(INT argc, const CHAR * const * argv, const CHAR * delimiter = 0)
    {
        Enter(argc, argv, delimiter);
    }

   







    COMMAND_LINE_ARGUMENTS(const string & commandLine)
    {
        Enter(commandLine);
    }

   




    COMMAND_LINE_ARGUMENTS(const COMMAND_LINE_ARGUMENTS & source)
    {
        Enter(source.m_argc, source.m_argv, 0);
    }

   






    COMMAND_LINE_ARGUMENTS & operator= (const COMMAND_LINE_ARGUMENTS & source)
    {
        
        if(this != &source)
        {
            Clean();
            Enter(source.m_argc, source.m_argv, 0);
        }
        return *this;
    }

   








    COMMAND_LINE_ARGUMENTS & Insert (const COMMAND_LINE_ARGUMENTS & right, INT pos = -1);

    








    COMMAND_LINE_ARGUMENTS & Insert (const string & arg, INT pos = -1);

    









    COMMAND_LINE_ARGUMENTS & InsertAsOneToken (const string & arg, INT pos = -1);

    






    INT FindArgument(const string& argStr) const;

    







    BOOL RemoveArguments(const string& argStr, INT numOfArgs);

   




    INT  Argc() const
    {
        return m_argc;
    }

   




    const CHAR * const * Argv() const
    {
        return m_argv;
    }

    


    string String() const;

   


    ~COMMAND_LINE_ARGUMENTS()
    {
        Clean();
    }

  private:
   


    BOOL Enter(INT argc, const CHAR * const * argv, const CHAR * delimiter);

   


    BOOL Enter(const string & commandLine);

   


    BOOL Clean();

   


    INT FindArraySize(INT argc, const CHAR * const * argv, const CHAR * delimiter);

    


    VOID RemoveArgument(INT index);

  private:
    INT m_argc;       
    CHAR ** m_argv;   
};

                                                                  
extern VOID SetAddress0x(BOOL val);

                                                                  
extern BOOL CharIsSpace(CHAR c);

                                                                  
extern CHAR CharToUpper(CHAR c);

                                                                  
extern string ptrstr(const VOID *val );

                                                                  
extern string StringFromAddrint( ADDRINT l);

                                                                  
extern string StringFromUint64( UINT64 l);

                                                                  
extern string StringDec( UINT64 l, UINT32 digits, CHAR padding);

                                                                  
extern string StringDecSigned( INT64 l, UINT32 digits, CHAR padding);

                                                                  
extern string StringBignum( INT64 l, UINT32 digits, CHAR padding);

                                                                  
extern string Reformat(const string& s, const string& prefix, UINT32 min_line, UINT32 max_line);

                                                                  
extern string StringHex32( UINT32 l, UINT32 digits, BOOL prefix_0x);

                                                                  
extern string StringFlt(FLT64 val , UINT32 precision, UINT32 width);

                                                                  
extern string StringBool(BOOL b);

                                                                  
extern string StringTri(TRI t);

                                                                  
extern INT32 Int32FromString(const string& s);

                                                                  
extern UINT32 Uint32FromString(const string& s);

                                                                  
extern INT64 Int64FromString(const string& s);

                                                                  
extern UINT64 Uint64FromString(const string& s);

                                                                  
extern FLT64 FLT64FromString(const string& s);

                                                                  
extern INT CharToHexDigit(CHAR c);

                                                                  
extern ADDRINT AddrintFromString(const string& str);

                                                                  
extern UINT32 BitCount(ADDRINT val);

                                                                  
extern string ReadLine(istream& inputFile, UINT32 *lineNum);

                                                                  
extern UINT32 Tokenize(const string& line, string *array, UINT32 n);

                                                                  
inline string StringHex( UINT32 l, UINT32 digits, BOOL prefix_0x = 1) {return StringHex32(l, digits, prefix_0x);}

                                                                  
inline string decstr(INT64 val, UINT32 width=0 )  {return StringDecSigned(val,width,' ');}

                                                                  
inline string decstr(INT32 val, UINT32 width=0 )  {return StringDecSigned(val,width,' ');}

                                                                  
inline string decstr(INT16 val, UINT32 width=0 )  {return StringDecSigned(val,width,' ');}

                                                                  
inline string decstr(UINT64 val, UINT32 width=0 )  {return StringDec(val,width,' ');}

                                                                  
inline string decstr(UINT32 val, UINT32 width=0 )  {return StringDec(val,width,' ');}

                                                                  
inline string decstr(UINT16 val, UINT32 width=0 )  {return StringDec(val,width,' ');}

                                                                  
inline string hexstr(INT64 val, UINT32 width=0 )
{
    string ostr;

    ostr = StringHex( INT32((val >> 16) >> 16), width);


#line 300 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    ostr += StringHex( UINT32(val), 8, 0);

    return ostr;
}

                                                                  
inline string hexstr(INT32 val, UINT32 width=0 )  {return StringHex(INT32(val),width);}

                                                                  
inline string hexstr(INT16 val, UINT32 width=0 )  {return StringHex(INT32(val),width);}

                                                                  
inline string hexstr(UINT64 val, UINT32 width=0 )
{
    string ostr;

    ostr = StringHex( UINT32((val >> 16) >> 16), width);


#line 320 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    ostr += StringHex( UINT32(val), 8, 0);

    return ostr;
}

                                                                  
inline string hexstr(VOID *p, UINT32 width=0 )
{



#line 332 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    UINT32 val = reinterpret_cast<UINT32>(p);
    return StringHex(val,width);
#line 335 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
inline string hexstr(const VOID *p, UINT32 width=0 )
{



#line 344 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    UINT32 val = reinterpret_cast<UINT32>(p);
    return StringHex(val,width);
#line 347 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
inline string hexstr(UINT32 val, UINT32 width=0 )  {return StringHex(UINT32(val),width);}

                                                                  
inline string hexstr(UINT16 val, UINT32 width=0 )  {return StringHex(UINT32(val),width);}

                                                                  
inline string fltstr(FLT64 val, UINT32 prec=0,UINT32 width=0 )  {return StringFlt(val,prec,width);}

                                                                  
inline string ljstr(const string& s, UINT32 width, CHAR padding = ' ')
{
    string  ostr(width,padding);
    ostr.replace(0,s.length(),s);
    return ostr;
}

                                                                  
struct DECSTR
{
    DECSTR(UINT32 width = 0) :_w(width){}
    template <typename T> string operator() (const T & t) const {return decstr(t,_w);}
    UINT32 _w;
};

                                                                  
struct HEXSTR
{
    HEXSTR(UINT32 width = 0) :_w(width){}
    template <typename T> string operator() (const T & t) const {return hexstr(t,_w);}
    UINT32 _w;
};

                                                                  
struct FLTSTR
{
    FLTSTR(UINT32 prec=0,UINT32 width=0) :_p(prec), _w(width) {}
    template <typename T> string operator() (const T & t) const {return fltstr(t,_p,_w);}
    UINT32 _p;
    UINT32 _w;
};

                                                                  
template <typename ITER, typename CONV>
    string StringSequence(ITER begin, ITER end,
                          const CONV & conv,
                          const string & delimiter = string(" "))
{
    string str;

    for (ITER it = begin;  it != end;  ++it)
    {
        if (it != begin) {str += delimiter;}
        str += conv(*it);
    }
    return str;
}

                                                                  
inline VOID * Addrint2VoidStar(ADDRINT addr)
{



#line 414 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    return reinterpret_cast<VOID*>(addr);
#line 416 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
inline ADDRINT VoidStar2Addrint(const VOID * addr)
{



#line 425 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    return reinterpret_cast<ADDRINT>(addr);
#line 427 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
inline ADDRINT VoidStar2Addrint(VOID * addr)
{



#line 436 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    return reinterpret_cast<ADDRINT>(addr);
#line 438 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
template <typename T> BOOL IsPowerOf2(T value)
{
    return ((value & (value - 1)) == 0);
}

                                                                  
template <typename T> T RoundToNextPower2(T value)
{
    
    
    
    
    
    
    
    T width = sizeof(T)*8; 
    --value;

    for (T i=1; i < width; i <<= 1) 
    {
        value = (value | value >> i); 
    }
    ++value;
    return value;
}

                                                                  
template <typename T> T RoundUp(T value, size_t alignment)
{
    if (alignment == 0)
    {
        return value;
    }

    value += alignment - 1;
    value /= alignment;
    value *= alignment;

    return value;
}

                                                                  
template <typename T> T * RoundUp(T * ptr, size_t alignment)
{
    return (reinterpret_cast<T *>(RoundUp(reinterpret_cast<ADDRINT>(ptr), alignment)));
}

                                                                  
template <typename T> T RoundUpPowerOf2(T value, size_t alignment)
{
    if (alignment == 0) return value;
    T align_1 = static_cast<T>(alignment - 1);
    do{ if(!((alignment & align_1) == 0)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\util.PH",   __FUNCTION__   , 493, std::string("") + "assertion failed: " "(alignment & align_1) == 0" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
    return ((value + align_1) & ~align_1);
}

                                                                  
template <typename T> T * RoundUpPowerOf2(T * ptr, size_t alignment)
{
    return (reinterpret_cast<T *>(RoundUpPowerOf2(reinterpret_cast<ADDRINT>(ptr), alignment)));
}

                                                                  
template <typename T> T RoundDown(T value, size_t alignment)
{
    if (alignment == 0)
    {
        return value;
    }

    value /= alignment;
    value *= alignment;

    return value;
}

                                                                  
template <typename T> T * RoundDown(T * ptr, size_t alignment)
{
    return (reinterpret_cast<T *>(RoundDown(reinterpret_cast<ADDRINT>(ptr), alignment)));
}

                                                                  
template <typename T> T RoundDownPowerOf2(T value, size_t alignment)
{
    if (alignment == 0) return value;
    T align_1 = static_cast<T>(alignment - 1);
    do{ if(!((alignment & align_1) == 0)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\util.PH",   __FUNCTION__   , 528, std::string("") + "assertion failed: " "(alignment & align_1) == 0" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
    return (value & ~align_1);
}

                                                                  
template <typename T> T * RoundDownPowerOf2(T * ptr, size_t alignment)
{
    return (reinterpret_cast<T *>(RoundDownPowerOf2(reinterpret_cast<ADDRINT>(ptr), alignment)));
}

                                                                  
template<typename T> ADDRINT PointerToInt(const T *ptr)
{




#line 546 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    return reinterpret_cast<ADDRINT>(ptr);
#line 548 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
template<typename T> T *IntToPointer(ADDRINT addr)
{




#line 558 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    return reinterpret_cast<T*>(addr);
#line 560 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
inline INT64 VoidStar2Int(VOID * addr)
{



#line 569 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
    return reinterpret_cast<INT64>(addr);
#line 571 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
inline BOOL UnsignedImmediateFits(const UINT64 value, const UINT32 bits)
{
    return 0 == (value>>bits);
}

                                                                  
inline void RangeCheck(const UINT32 value, const UINT32 bits)
{
    do{ if(!(UnsignedImmediateFits(value, bits))) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\util.PH",   __FUNCTION__   , 583, std::string("") + decstr(bits) + "-bit range overflow in " + hexstr(value) + "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
#line 584 "C:\\Pin35\\source\\include\\pin\\gen\\util.PH"
}

                                                                  
extern BOOL SignedImmediateFits(const INT64 value, const UINT32 origSize, const UINT32 extendedSize);

                                                                  
inline BOOL SignedImmediateFits(const INT64 value, const UINT32 origSize)
{
    return SignedImmediateFits(value, origSize, 8 * sizeof(ADDRINT));
}

                                                                  
extern BOOL HasBaseName(const char *fileName, const char *baseNameToCheckFor);

                                                                  
inline INT32 MEMORY_ReadInt32(ADDRINT  address)
{
    return *reinterpret_cast<INT32*>(address);
}

                                                                  
inline VOID MEMORY_WriteInt32(ADDRINT  address, INT32 value)
{
    *reinterpret_cast<INT32*>(address) = value;
}

                                                                  
inline UINT32 MEMORY_ReadUint32(ADDRINT  address)
{
    return *reinterpret_cast<UINT32*>(address);
}

                                                                  
inline VOID MEMORY_WriteUint32(ADDRINT  address, UINT32 value)
{
    *reinterpret_cast<UINT32*>(address) = value;
}

                                                                  
inline INT64 MEMORY_ReadInt64(ADDRINT  address)
{
    return *reinterpret_cast<INT64*>(address);
}

                                                                  
inline VOID MEMORY_WriteInt64(ADDRINT  address, INT64 value)
{
    *reinterpret_cast<INT64*>(address) = value;
}

                                                                  
inline UINT64 MEMORY_ReadUint64(ADDRINT  address)
{
    return *reinterpret_cast<UINT64*>(address);
}

                                                                  
inline VOID MEMORY_WriteUint64(ADDRINT  address, UINT32 value)
{
    *reinterpret_cast<UINT64*>(address) = value;
}

                                                                  
extern ADDRINT GetPageOfAddr(ADDRINT addr);

                                                                  
extern ADDRINT ProgramEntry(const ImageLoaderInfo * mainImage, const ImageLoaderInfo * loader);

                                                                  
extern string Joinpath(string s1, string s2);

                                                                  
extern string Basename(const string& path);

                                                                  
extern CHAR* CreateTmpFileName(const CHAR* fnameTemplate);

                                                                  
extern const VOID * GetSp();

                                                                  
inline size_t PtrDiff(const VOID * ptr1, const VOID * ptr2)
{
    return (reinterpret_cast<const INT8 *>(ptr1) - reinterpret_cast<const INT8 *>(ptr2));
}

                                                                  
inline VOID * PtrAtOffset(VOID * ptr, size_t offset)
{
    return (reinterpret_cast<INT8 *>(ptr) + offset);
}

                                                                  
inline const VOID * PtrAtOffset(const VOID * ptr, size_t offset)
{
    return (reinterpret_cast<const INT8 *>(ptr) + offset);
}

                                                                  
template <typename T> T * PtrAtOffset(VOID * ptr, size_t offset)
{
    return (reinterpret_cast<T *>(PtrAtOffset(ptr, offset)));
}

                                                                  
template <typename T> const T * PtrAtOffset(const VOID * ptr, size_t offset)
{
    return (reinterpret_cast<const T *>(PtrAtOffset(ptr, offset)));
}

                                                                  
template <typename T> VOID *
 PushDataToStack(VOID * stack, const T * data, size_t alignment = 1, size_t size = sizeof(T))
{
    stack = PtrAtOffset(stack, 0 - size);
    stack = RoundDown(stack , alignment);
    return memcpy(stack, data, size);
}

                                                                  
inline VOID * PushAddrintToStack(VOID * stack, ADDRINT value)
{
    stack = PtrAtOffset(stack, 0 - sizeof(ADDRINT));
    *reinterpret_cast<ADDRINT *>(stack) = value;
    return stack;
}

                                                                  
class MemRange
{
    public:

    

    
    MemRange() {}
    
    MemRange(VOID * base, size_t size) : m_base(base), m_size(size) {}
    MemRange(ADDRINT base, size_t size) : m_base(Addrint2VoidStar(base)), m_size(size) {}
    
    
    MemRange(VOID * base, VOID * end) : m_base(base), m_size(PtrDiff(end, base)) {}

    

    
    BOOL operator == (const MemRange &  range) const
    {
        return ((m_base == range.m_base) && (m_size == range.m_size));
    }
    BOOL operator != (const MemRange &  range) const {return (!(*this == range));}

    

    
    VOID * Base() const {return m_base;}
    MemRange& Base(VOID * base) { m_base = base; return *this;}

    
    size_t Size() const {return  m_size;}
    MemRange& Size(size_t size) { m_size = size; return *this;}

    
    VOID * End() const {return  PtrAtOffset(m_base, m_size);}

    
    VOID * Last() const {return PtrAtOffset(m_base, m_size - 1);}

    




    BOOL IsEmpty() const {return (m_size == 0);}

    







    BOOL Contains(const VOID * addr) const
    {
        return (PtrDiff(addr, m_base) < m_size);
    }

    







    BOOL Contains(const MemRange & range) const
    {
        return  (Contains(range.m_base) && !range.Contains(End()));
    }

    






    BOOL Intersects(const MemRange & range) const
    {
        return  (Contains(range.m_base) || range.Contains(m_base));
    }

    






    BOOL AdjacentTo(const MemRange & range) const
    {
        return  (((range.m_base == End()) && (range.m_base != 0)) ||
                 ((m_base == range.End()) && (m_base != 0)));
    }

    




    BOOL IsCurrentStack() const
    {
        return  (Contains(GetSp()));
    }

    






    MemRange& Align(UINT32 alignment)
    {
        VOID * end  = RoundUp(End(), alignment);
        m_base = RoundDown(m_base, alignment);
        m_size = PtrDiff(end, m_base);
        return *this;
    }

    





    MemRange& AlignUp(UINT32 alignment)
    {
        m_base = RoundUp(m_base, alignment);
        m_size = RoundUp(m_size, alignment);
        return *this;
    }

    





    MemRange& AlignDown(UINT32 alignment)
    {
        VOID * end  = RoundDown(End(), alignment);
        m_size = RoundUp(m_size, alignment);
        m_base = PtrAtOffset(end, 0 - m_size);
        return *this;
    }

    




    MemRange& Shift(size_t offset)
    {
        m_base = PtrAtOffset(m_base, offset);
        return *this;
    }

    






    MemRange& ShiftBase(size_t offset)
    {
        VOID * end  = End();
        m_base = PtrAtOffset(m_base, offset);
        if (end < m_base)
        {
            m_size = 0;
        }
        else
        {
            m_size = PtrDiff(end, m_base);
        }
        return *this;
    }

    




    MemRange& ShiftEnd(size_t offset)
    {
        m_size += offset;
        return *this;
    }

    





    MemRange& Combine(const MemRange & range)
    {
        size_t size;
        if (range.m_base >= m_base)
        {
            size = PtrDiff(range.End(), m_base);
        }
        else
        {
            size = PtrDiff(End(), range.m_base);
            *this = range;
        }
        if (size > m_size)
        {
            m_size = size;
        }
        return *this;
    }

    











    VOID Decompose(const MemRange & range,
                   MemRange * pIntersection,
                   MemRange * pLowDiff,
                   MemRange * pHighDiff) const
    {
        VOID * thisEnd  = End();
        VOID * otherEnd = range.End();

        VOID * intersectionBase;
        VOID * intersectionEnd;

        if (Contains(range.m_base))
        {
            
            intersectionBase = range.m_base;
            intersectionEnd  = (range.Contains(thisEnd) ? thisEnd : otherEnd);
        }
        else if (range.Contains(m_base))
        {
            
            intersectionBase = m_base;
            intersectionEnd  = (Contains(otherEnd) ? otherEnd : thisEnd);
        }
        else if (m_base > range.m_base)
        {
            
            intersectionBase = intersectionEnd = m_base;
        }
        else
        {
            
            intersectionBase = intersectionEnd = thisEnd;
        }

        if (pIntersection != 0)
        {
            *pIntersection = MemRange(intersectionBase, intersectionEnd);
        }
        if (pLowDiff != 0)
        {
            *pLowDiff = MemRange(m_base, intersectionBase);
        }
        if (pHighDiff != 0)
        {
            *pHighDiff = MemRange(intersectionEnd, thisEnd);
        }
    }

    private:
    VOID * m_base;
    size_t m_size;
};

                                                                  
inline string MemRangeToString(const MemRange & range)
{
    return ("[" + hexstr(range.Base()) + " , " + hexstr(range.End()) + "]");
}

                                                                  
extern MemRange MemPageRange(ADDRINT addr);

                                                                  
extern MemRange MemPageRange(const VOID * addr);

                                                                  
class ONCE_STATE
{
  private:
    
    enum
    {
        NO_ONCE,            
        ONCE_RUNNING,       
        ONCE_SUCCESS,       
        ONCE_FAILURE        
    } m_state;

  public:
    
    ONCE_STATE() : m_state(NO_ONCE) {}

    
    
    BOOL Enter()
    {
        if (m_state == NO_ONCE)
        {
            m_state = ONCE_RUNNING;
            return 1;
        }
        return 0;
    }

    
    BOOL Exit(BOOL result = 1)
    {
        m_state = (result ? ONCE_SUCCESS : ONCE_FAILURE);
        return result;
    }

    
    BOOL IsSuccess() const {return (m_state == ONCE_SUCCESS); }
    
    BOOL IsFailure() const {return (m_state == ONCE_FAILURE); }
    
    BOOL IsDone() const {return (IsSuccess() || IsFailure()); }

};

                                                                  
struct OBJECT_DELETER
{
    template<typename T> static VOID Delete(T* p) {delete p;}
};

                                                                  
struct ARRAY_DELETER
{
    template<typename T> static VOID Delete(T* p) {delete [] p;}
};

                                                                  
template<typename T, typename D = OBJECT_DELETER, typename C = INT32> class COUNTED_PTR
{
  public:
    




    COUNTED_PTR() : m_cptr(0){}
    explicit COUNTED_PTR(T * p) : m_cptr((p != 0) ? (new CPTR(p)) : 0) {}
    COUNTED_PTR(const COUNTED_PTR & r) : m_cptr(r.m_cptr) {AddRef();}

    


    ~COUNTED_PTR() {ReleaseRef();}

    


    COUNTED_PTR & operator = (const COUNTED_PTR & r)
    {
        r.AddRef();
        ReleaseRef();
        m_cptr = r.m_cptr;
        return *this;
    }

    VOID Reset()
    {
        ReleaseRef();
        m_cptr = 0;
    }

    VOID Reset(T * p)
    {
        if ((m_cptr != 0) && (p == m_cptr->m_ptr)) {return;}
        ReleaseRef();
        m_cptr = ((p != 0) ? (new CPTR(p)) : 0);
    }


    


    T * Get()           const   {return ((m_cptr != 0) ? m_cptr->m_ptr : 0);}
    T * operator->()    const   {return Get();}
    T & operator*()     const   {return *(Get());}

    


    BOOL operator == (const COUNTED_PTR &  r) const {return (m_cptr == r.m_cptr);}
    BOOL operator != (const COUNTED_PTR &  r) const {return (m_cptr != r.m_cptr);}
    BOOL operator == (const T *  p) const {return (Get() == p);}
    BOOL operator != (const T *  p) const {return (Get() != p);}

  private:

    struct CPTR
    {
        CPTR(T * p) : m_ptr(p), m_count(1) {}
        T *     m_ptr;
        C       m_count;
    }* m_cptr;

    VOID AddRef() const
    {
        if (m_cptr != 0) {++m_cptr->m_count;}
    }

    VOID ReleaseRef()
    {
        if ((m_cptr != 0) && (--m_cptr->m_count == 0))
        {
            D::Delete(m_cptr->m_ptr);
            delete m_cptr;
            m_cptr = 0;
        }
    }
};

                                                                  
template <typename T> struct OPTIONAL_VALUE
{
    BOOL m_hasValue;    
    T m_value;          

    



    VOID Set(const T & value)
    {
        m_hasValue = 1;
        m_value = value;
    }

    




    VOID Set(const T * pValue)
    {
        if (pValue != 0)
        {
            Set(*pValue);
        }
        else
        {
            Reset();
        }
    }

    


    VOID Reset() {m_hasValue = 0;}

    





    BOOL Get(T * pValue) const
    {
        if (m_hasValue && (pValue != 0)) {*pValue = m_value;}
        return m_hasValue;
    }

    


    BOOL HasValue() const {return m_hasValue;}

    



    T & Value() {return m_value;}
    const T & Value() const {return m_value;}

    




    T * ValuePtr() {return ((m_hasValue) ? &m_value : 0);}
    const T * ValuePtr() const {return ((m_hasValue) ? &m_value : 0);}
};

                                                                  
extern STAT_NORM StatRawMmapBytes;

                                                                  
extern STAT_NORM StatReservedBytes;

                                                                  
extern VOID UpdateRawMmapBytes();

                                                                  


#line 106 "c:\\pin35\\source\\include\\pin\\level_base.PLH"

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\knob.PH"






typedef enum
{
    KNOB_MODE_INVALID,
    KNOB_MODE_COMMENT,    
    KNOB_MODE_WRITEONCE,  
    KNOB_MODE_OVERWRITE,  
    KNOB_MODE_ACCUMULATE, 
    KNOB_MODE_APPEND,     
    KNOB_MODE_LAST
} KNOB_MODE;

                                                                  
template<class TYPE> class KNOBVALUE
{
  private:
    TYPE _value;             
    string _value_string;    
    KNOBVALUE<TYPE> * _next; 

    
    KNOBVALUE(const KNOBVALUE &) { do{ if(MessageTypeError.on()) MessageTypeError.MessageNoReturn("KNOBVALUE should not be copied",1,PIN_ERR_INTERNAL,0); }while(0); }
    
    KNOBVALUE& operator=(const KNOBVALUE &) { do{ if(MessageTypeError.on()) MessageTypeError.MessageNoReturn("KNOBVALUE should not be copied",1,PIN_ERR_INTERNAL,0); }while(0); };

  public:
    
    static TYPE FromString(const string & strvalue);
    static string ToString(const TYPE & value, const string & origString)
    {
        return origString;
    }

    
    static TYPE Accumulate(TYPE & lVal, const TYPE & rVal)
    {
        return (lVal += rVal);
    }

    
    static const string Type();

    
    
    
    KNOBVALUE() : _next(0) {}

    
    
    
    const TYPE & Value() const { return _value; }
    const string & ValueString() const { return _value_string; }

    KNOBVALUE * Next() const { return _next; }

    
    
    
    VOID Overwrite(const string & valstring)
    {
        _value = FromString(valstring);
        _value_string = ToString(_value, valstring);
    }
    VOID Accumulate(const string & valstring)
    {
        Accumulate(_value, FromString(valstring));
        _value_string = ToString(_value, valstring);
    }
    VOID Append(KNOBVALUE * next)
    {
        do{ if(!(_next == 0)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\knob.PH",   __FUNCTION__   , 76, std::string("") + "assertion failed: " "_next == NULL" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        _next = next;
    }
};

                                                                  
template<> inline BOOL KNOBVALUE<BOOL>::Accumulate(BOOL & lVal, 
                                                                     const BOOL & rVal)
{
    return (lVal = (lVal || rVal));
}

                                                                  
template<class TYPE> class KNOBVALUE_LIST
{
  private:
    typedef KNOBVALUE<TYPE> listnode;
    listnode _first;  
    UINT32 _numNodes; 

  public:
    
    
    
    KNOBVALUE_LIST(const string & valstring, BOOL hasDefault) : _numNodes(0)
    {
        if (hasDefault)
        {
            Append(valstring);
        }
    }
    ~KNOBVALUE_LIST()
    {
        listnode * next;
        for (listnode * node = _first.Next(); node; node = next)
        {
            next = node->Next();
            delete node;
        }
    }

    
    
    
  private:
    
    KNOBVALUE_LIST(const KNOBVALUE_LIST &) { do{ if(MessageTypeError.on()) MessageTypeError.MessageNoReturn("KNOBVALUE_LIST should not be copied",1,PIN_ERR_INTERNAL,0); }while(0); }
    
    KNOBVALUE_LIST& operator=(const KNOBVALUE_LIST&) { do{ if(MessageTypeError.on()) MessageTypeError.MessageNoReturn("KNOBVALUE_LIST should not be copied",1,PIN_ERR_INTERNAL,0); }while(0); }
    
    
    
    const listnode * Node(const UINT32 index) const { return GetNode(index); }
    listnode * Node(const UINT32 index) { return const_cast<listnode *>(GetNode(index)); }
    const listnode * GetNode(const UINT32 index) const
    {
        do{ if(!(_numNodes > index)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\knob.PH",   __FUNCTION__   , 132, std::string("") + "access index out of range"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);

        const listnode * node = & _first;
        for (UINT32 i = index; i > 0; i--)
        {
            node = node->Next();
            do{ if(!(node != 0)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\knob.PH",   __FUNCTION__   , 138, std::string("") + "assertion failed: " "node != NULL" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        }

        return node;
    }

  public:
    UINT32 NumberOfValues() const { return _numNodes; }
    const string & ValueString(const UINT32 index) const { return Node(index)->ValueString(); }
    const TYPE & Value(const UINT32 index) const { return Node(index)->Value(); }
    const TYPE & Value() const { return _first.Value(); }
    const string & ValueString() const { return _first.ValueString(); }

    
    
    
    VOID Overwrite(const string & valstring) { _first.Overwrite(valstring); }
    VOID Accumulate(const string & valstring) { _first.Accumulate(valstring); }
    VOID Append(const string & valstring)
    {
        listnode * node;
        if (_numNodes == 0)
        {
            node = & _first;
        }
        else
        {
            node = new listnode;
            listnode * const last = Node(_numNodes - 1);
            last->Append(node);
        }
        node->Overwrite(valstring);
        _numNodes++;
    }
};

                                                                  
class KNOB_BASE
{
  private:
    static KNOB_BASE *_knob_list;
    static BOOL _parsing_done;
    static BOOL _developer_flags_enabled; 

  protected:
    KNOB_BASE   *_next;
    const string _family;
    const string _name;
    const string _purpose;
    const string _default_value;
    const KNOB_MODE _mode;
    BOOL  _disabled;
    INT32 _nreads;
    INT32 _nwrites;

  public:
    
    
    
    
    KNOB_BASE(const string & myprefix, const string & myname, const string & myfamily, const string & mydefault,
              const string & mypurpose, KNOB_MODE mymode = KNOB_MODE_WRITEONCE);

    
    virtual ~KNOB_BASE() {}

    
    
    
    virtual const string Type() = 0; 

    KNOB_MODE Mode() const {return _mode;}

    const string & Family() const {return _family;}

    const string & Name() const {return _name;}

    string Cmd() const { return ("-" + _name); }

    BOOL Enabled() const {return !_disabled;}

    
    static VOID CheckAllKnobs(BOOL allowDashes = 0);

    
    static UINT32 NumberOfKnobs();

    
    static VOID DisableKnobFamily(const string & myfamily);

    
    static VOID EnableKnobFamily(const string & myfamily);

    
    static VOID SetDeveloperFlagsEnabled();

    
    static BOOL WasDeveloperFlagsEnabled();

    
    static VOID DisableKnob(const string & myname);

    
    static VOID EnableKnob(const string & myname);

    
    static string StringKnobSummary();

    
    static string StringLongAll();

    static KNOB_BASE * FindKnob(const string & name);

    static KNOB_BASE * FindFamily(const string & name);

    static KNOB_BASE * FindEnabledKnob(const string & name);

    
    
    
    static VOID SetParsingDone();

    
    static BOOL WasParsingDone();

    int Compare(const KNOB_BASE & k2) const;

    
    virtual const string & ValueString(const UINT32 index) const = 0;

    
    virtual UINT32 NumberOfValues() const = 0;

    
    
    
    
    virtual VOID AddValue(const string & valstring) = 0;
};

                                                                  
template<class TYPE> class KNOB : public KNOB_BASE
{
  private:
    typedef KNOBVALUE_LIST<TYPE> valuelist;
    valuelist _value_list;

    
    KNOB() { do{ if(MessageTypeError.on()) MessageTypeError.MessageNoReturn("KNOB should not be constructed using default constructor",1,PIN_ERR_INTERNAL,0); }while(0); }
    
    KNOB(const KNOB&)  { do{ if(MessageTypeError.on()) MessageTypeError.MessageNoReturn("KNOB should not be copied",1,PIN_ERR_INTERNAL,0); }while(0); }
    
    KNOB& operator=(const KNOB&)  { do{ if(MessageTypeError.on()) MessageTypeError.MessageNoReturn("KNOB should not be copied",1,PIN_ERR_INTERNAL,0); }while(0); }

  public:
    KNOB(KNOB_MODE mymode, const string & myfamily, const string & myname,
         const string & mydefault, const string & mypurpose, const string & myprefix = "")
    :
        KNOB_BASE(myprefix, myname, myfamily, mydefault, mypurpose, mymode),
        _value_list(mydefault, (mymode != KNOB_MODE_APPEND))
    {}

    
    
    
    
    VOID AddValue(const string & valstring)
    {
        switch (_mode)
        {
          case KNOB_MODE_WRITEONCE:
            
            do{ if(!(_nwrites == 0 || _value_list.ValueString() == valstring)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\knob.PH",   __FUNCTION__   , 311, std::string("") + "trying to overwrite write-once knob '" + _name + "'"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
#line 312 "C:\\Pin35\\source\\include\\pin\\gen\\knob.PH"

            
          case KNOB_MODE_OVERWRITE:
            _value_list.Overwrite(valstring);
            break;

          case KNOB_MODE_ACCUMULATE:
            _value_list.Accumulate(valstring);
            break;

          case KNOB_MODE_APPEND:
            _value_list.Append(valstring);
            break;

          default:
            do{ if(!(false)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\knob.PH",   __FUNCTION__   , 327, std::string("") + "unknown mode " + decstr(static_cast<UINT32>(_mode)) + " for knob '" + _name + "'"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        }

        _nwrites++;
    }

    
    
    
    
    const string Type() { return KNOBVALUE<TYPE>::Type(); }
    
    const TYPE & Value() const {  return _value_list.Value(); }
    const string & ValueString() const {  return _value_list.ValueString(); }
    
    operator TYPE() const { return Value(); }
    
    const TYPE & Value(const UINT32 index) { _nreads++; return _value_list.Value(index); }
    const string & ValueString(const UINT32 index) const { return _value_list.ValueString(index); }
    UINT32 NumberOfValues() const { return _value_list.NumberOfValues(); }
};

                                                                  
class KNOB_COMMENT : public KNOB<BOOL>
{

  public:
    KNOB_COMMENT( const string & family, const string & purpose) :
        KNOB<BOOL>(KNOB_MODE_COMMENT,family,"","",purpose)
    {}

};

                                                                  
class ADDRESS_RANGE
{
  public:
    ADDRESS_RANGE(ADDRINT low, ADDRINT high)
    {
        _low = low;
        _high = high;
    }
    
    ADDRESS_RANGE()
    {
        _low = 0;
        _high = 0;
    }
    
    ADDRINT _low;
    ADDRINT _high;

    ADDRESS_RANGE & operator+= (const ADDRESS_RANGE & right)
    {
        return *this;
    }

    string String() const
    {
        return hexstr(_low) + ":" + hexstr(_high);
    }

    BOOL Valid() const
    {
        return (_high - _low) == 0 ? 0:1;
    }

    ADDRINT Size() const
    {
        return _high - _low;
    }
};

                                                                  
extern KNOB<BOOL> KnobSlowAsserts;

                                                                  

#line 108 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\lock.PH"






struct PIN_LOCK
{
    PINVM::PINSYNC_SAFEPOD_LOCK _lock;  
    INT32 _owner;                       
};

                                                                  
typedef PINVM::PINSYNC_POD_LOCK PIN_MUTEX;

                                                                  
typedef PINVM::PINSYNC_POD_RWLOCK PIN_RWMUTEX;

                                                                  
typedef PINVM::PINSYNC_POD_SEMAPHORE PIN_SEMAPHORE;

                                                                  
extern VOID PIN_InitLock(PIN_LOCK *lock);

                                                                  
extern VOID PIN_GetLock(PIN_LOCK *lock, INT32 val);

                                                                  
extern INT32 PIN_ReleaseLock(PIN_LOCK *lock);

                                                                  
extern BOOL PIN_MutexInit(PIN_MUTEX *lock);

                                                                  
extern VOID PIN_MutexFini(PIN_MUTEX *lock);

                                                                  
extern VOID PIN_MutexLock(PIN_MUTEX *lock);

                                                                  
extern VOID PIN_MutexUnlock(PIN_MUTEX *lock);

                                                                  
extern BOOL PIN_MutexTryLock(PIN_MUTEX *lock);

                                                                  
extern BOOL PIN_RWMutexInit(PIN_RWMUTEX *lock);

                                                                  
extern VOID PIN_RWMutexFini(PIN_RWMUTEX *lock);

                                                                  
extern VOID PIN_RWMutexReadLock(PIN_RWMUTEX *lock);

                                                                  
extern VOID PIN_RWMutexWriteLock(PIN_RWMUTEX *lock);

                                                                  
extern VOID PIN_RWMutexUnlock(PIN_RWMUTEX *lock);

                                                                  
extern BOOL PIN_RWMutexTryReadLock(PIN_RWMUTEX *lock);

                                                                  
extern BOOL PIN_RWMutexTryWriteLock(PIN_RWMUTEX *lock);

                                                                  
extern BOOL PIN_SemaphoreInit(PIN_SEMAPHORE *sem);

                                                                  
extern VOID PIN_SemaphoreFini(PIN_SEMAPHORE *sem);

                                                                  
extern VOID PIN_SemaphoreSet(PIN_SEMAPHORE *sem);

                                                                  
extern VOID PIN_SemaphoreClear(PIN_SEMAPHORE *sem);

                                                                  
extern BOOL PIN_SemaphoreIsSet(PIN_SEMAPHORE *sem);

                                                                  
extern VOID PIN_SemaphoreWait(PIN_SEMAPHORE *sem);

                                                                  
extern BOOL PIN_SemaphoreTimedWait(PIN_SEMAPHORE *sem, unsigned timeout);

                                                                  

#line 109 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\fpstate_ia32.PH"






typedef UTIL::FXSAVE_IA32 FXSAVE;

                                                                  
struct XSAVE_HEADER
{
    UINT64 _mask;
    UINT64 _xcomp_bv;
    UINT64 _reserved[6];
};

                                                                  
const size_t VSTATE_PADDING = 128;

                                                                  
struct FPSTATE
{
    
    FXSAVE fxsave_legacy; 

    
    struct XSTATE
    {
        XSAVE_HEADER _extendedHeader; 
        UINT8 _ymmUpper[8*16];  
        UINT8 _pad[8*16];       
    } _xstate;

    
    
    UINT8 _reserved[VSTATE_PADDING]; 


    
    
    
    
    
    
    struct VSTATE
    {
        UINT8  _bndRegs[64];    
        UINT8  _bndCSR[64];     
        UINT64 _kmasks[8];      
        UINT8  _zmmUpper[8*32]; 
        UINT8  _pad256[8*32];   
        UINT8  _pad1024[16*64]; 
    } _vstate;

    
};

                                                                  
const size_t FPSTATE_SIZE_FXSAVE = sizeof(FXSAVE);

                                                                  
const size_t FPSTATE_SIZE_XSAVE_AVX = sizeof(FXSAVE) + sizeof(FPSTATE::XSTATE);

                                                                  
const size_t FPSTATE_SIZE_XSAVE_AVX512 =
        sizeof(FXSAVE) + sizeof(FPSTATE::XSTATE) + VSTATE_PADDING + sizeof(FPSTATE::VSTATE);

                                                                  
const size_t FPSTATE_SIZE = sizeof(FPSTATE);

                                                                  
const size_t FPSTATE_ALIGNMENT = 64;

                                                                  
const size_t FP_STATE_EXTENDED_HEADER_SIZE = sizeof(XSAVE_HEADER);

                                                                  
const UINT64 X87_CLASS_BIT = 0x1;

                                                                  
const UINT64 SSE_CLASS_BIT = 0x2;

                                                                  
const UINT64 AVX_CLASS_BIT = 0x4;

                                                                  
const UINT64 BNDREGS_CLASS_BIT = 0x8;

                                                                  
const UINT64 BNDCSR_CLASS_BIT = 0x10;

                                                                  
const UINT64 OPMASK_CLASS_BIT = 0x20;

                                                                  
const UINT64 ZMM_HI256_CLASS_BIT = 0x40;

                                                                  
const UINT64 HI16_ZMM_CLASS_BIT = 0x80;

                                                                  

#line 112 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 113 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 116 "c:\\pin35\\source\\include\\pin\\level_base.PLH"

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\reginfo_ia32.PH"






enum REGWIDTH
{
    REGWIDTH_8=0,
    REGWIDTH_16=1,
    REGWIDTH_32=2,
    REGWIDTH_64=3,
    REGWIDTH_80,
    REGWIDTH_128,
    REGWIDTH_256,
    REGWIDTH_512,

    REGWIDTH_REG_X87,
#line 20 "C:\\Pin35\\source\\include\\pin\\gen\\reginfo_ia32.PH"
    REGWIDTH_INVALID,

    REGWIDTH_NATIVE=REGWIDTH_32


#line 26 "C:\\Pin35\\source\\include\\pin\\gen\\reginfo_ia32.PH"
};

                                                                  
enum REG_CLASS
{
    REG_CLASS_NONE      = 0,
    REG_CLASS_PSEUDO,
    REG_CLASS_GR,
    REG_CLASS_GRU8,
    REG_CLASS_GRL8,
    REG_CLASS_GRH16,
    REG_CLASS_GRH32,
    REG_CLASS_SEG,
    REG_CLASS_MM,
    REG_CLASS_XMM,
    REG_CLASS_YMM,
    REG_CLASS_ZMM,
    REG_CLASS_K,
    REG_CLASS_FPST,
    REG_CLASS_ST,
    REG_CLASS_CR,
    REG_CLASS_DR,
    REG_CLASS_TR,
    REG_CLASS_FLAGS,
    REG_CLASS_FLAGS16,
    REG_CLASS_FLAGS32,
    REG_CLASS_STATUS_FLAGS,
    REG_CLASS_DFLAG,

    REG_CLASS_X87,
#line 57 "C:\\Pin35\\source\\include\\pin\\gen\\reginfo_ia32.PH"
    REG_CLASS_MXCSR,
    REG_CLASS_MXCSRMASK,
    REG_CLASS_IP,
    REG_CLASS_IP16,
    REG_CLASS_IP32,
    REG_CLASS_ARCH,         
    REG_CLASS_PIN_GR,
    REG_CLASS_PIN_GRU8,
    REG_CLASS_PIN_GRL8,
    REG_CLASS_PIN_GRH16,
    REG_CLASS_PIN_GRH32,
    REG_CLASS_PIN_XMM,
    REG_CLASS_PIN_YMM,
    REG_CLASS_PIN_ZMM,
    REG_CLASS_PIN_K,

    REG_CLASS_PIN_X87,
#line 75 "C:\\Pin35\\source\\include\\pin\\gen\\reginfo_ia32.PH"
    REG_CLASS_PIN_MXCSR,
    REG_CLASS_PIN_FLAGS,
    REG_CLASS_PIN_STATUS_FLAGS,
    REG_CLASS_PIN_DFLAG
};

                                                                  
typedef UINT64 REG_CLASS_BITS;

                                                                  


const REG_CLASS_BITS REGCBIT_APP_ALL = 
    (REG_CLASS_BITS(1) << (REG_CLASS_PSEUDO))              |
    ((REG_CLASS_BITS(1) << (REG_CLASS_GR))                  )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRU8))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRL8))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRH16))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRH32))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_SEG))                 )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_MM))                  )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_XMM))                 )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_YMM))                 )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_ZMM))                 )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_K))                   )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_FPST))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_ST))                  )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_CR))                  )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_DR))                  )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_TR))                  )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS16))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS32))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_STATUS_FLAGS))        )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_DFLAG))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_X87))                 )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_MXCSR))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_MXCSRMASK))           )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_IP))                  )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_IP16))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_IP32))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_ARCH)));

                                                                  
const REG_CLASS_BITS REGCBIT_PIN_ALL = 

    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GR))              )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRU8))            )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRL8))            )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRH16))           )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRH32))           )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_XMM))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_YMM))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_ZMM))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_K))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_X87))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_MXCSR))           )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_FLAGS))           )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_STATUS_FLAGS))    )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_DFLAG)));

                                                                  
const REG_CLASS_BITS REGCBIT_ALL_REGS = REGCBIT_APP_ALL | REGCBIT_PIN_ALL;

                                                                  
const REG_CLASS_BITS REGCBIT_APP_FLAGS = 

    ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_STATUS_FLAGS))        )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_DFLAG)));

                                                                  
const REG_CLASS_BITS REGCBIT_PIN_FLAGS = 
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_FLAGS))           )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_STATUS_FLAGS))    )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_DFLAG)));

                                                                  
const REG_CLASS_BITS REGCBIT_PARTIAL = 
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRU8))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRL8))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRH16))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_GRH32))               )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS16))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS32))             )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_IP16))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_IP32))                )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRU8))            )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRL8))            )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRH16))           )|
    ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRH32)));

                                                                  
enum REG_SUBCLASS
{
    REG_SUBCLASS_NONE      = 0,
    REG_SUBCLASS_REX,
    REG_SUBCLASS_FULL_STACKPTR,
    REG_SUBCLASS_PIN_FULL_STACKPTR,
    REG_SUBCLASS_PIN_TMP,
    REG_SUBCLASS_PIN_INST_GR,
    REG_SUBCLASS_PIN_INST_GR_H32,
    REG_SUBCLASS_PIN_INST_BUF,
    REG_SUBCLASS_PIN_INST_COND
};

                                                                  
const REG_SUBCLASS_BITS REGSBIT_PIN_INST_ALL = 
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_PIN_INST_GR))      )|
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_PIN_INST_GR_H32))  )|
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_PIN_INST_BUF))     )|
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_PIN_INST_COND)));

                                                                  
const REG_SUBCLASS_BITS REGSBIT_PIN_SCRATCH_ALL = 
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_PIN_INST_GR))      )|
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_PIN_INST_BUF)));

                                                                  
const REG_SUBCLASS_BITS REGSBIT_STACKPTR_ALL = 
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_FULL_STACKPTR))         )|
    ((REG_CLASS_BITS(1) << (REG_SUBCLASS_PIN_FULL_STACKPTR)));

                                                                  
enum REG_ALLOC_TYPE
{
    REG_ALLOC_NONE      = 0,    
    REG_ALLOC_PART,             
    REG_ALLOC_ANY_GR,           
    REG_ALLOC_IDENT,            

    REG_ALLOC_CR            = REG_ALLOC_IDENT,
    REG_ALLOC_DR            = REG_ALLOC_IDENT,
    REG_ALLOC_TR            = REG_ALLOC_IDENT,
    REG_ALLOC_ST            = REG_ALLOC_IDENT,
    REG_ALLOC_MM            = REG_ALLOC_IDENT,
    REG_ALLOC_XMM           = REG_ALLOC_IDENT,
    REG_ALLOC_YMM           = REG_ALLOC_IDENT,
    REG_ALLOC_ZMM           = REG_ALLOC_IDENT,
    REG_ALLOC_K             = REG_ALLOC_IDENT,
    REG_ALLOC_SEG           = REG_ALLOC_IDENT,
    REG_ALLOC_STACK_PTR     = REG_ALLOC_IDENT,
    REG_ALLOC_X87           = REG_ALLOC_IDENT,
    REG_ALLOC_FLAGS         = REG_ALLOC_IDENT,
    REG_ALLOC_STATUS_FLAGS  = REG_ALLOC_IDENT,
    REG_ALLOC_DFLAG         = REG_ALLOC_IDENT
};

                                                                  

#line 118 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"






typedef enum
{
    REG_INVALID_ = 0,

    REG_NONE = 1,
    REG_FIRST = 2,

    
    REG_RBASE,

    
    REG_MACHINE_BASE = REG_RBASE,

    
    
    
    
    

    REG_APPLICATION_BASE = REG_RBASE,

    
    
    
    REG_PHYSICAL_INTEGER_BASE = REG_RBASE,

    REG_TO_SPILL_BASE = REG_RBASE,

#line 36 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_GR_BASE = REG_RBASE,









































#line 80 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    
    REG_EDI = REG_GR_BASE,
    REG_GDI = REG_EDI,
    REG_ESI,
    REG_GSI = REG_ESI,
    REG_EBP,
    REG_GBP = REG_EBP,
    REG_ESP,
    REG_STACK_PTR = REG_ESP,
    REG_EBX,
    REG_GBX = REG_EBX,
    REG_EDX,
    REG_GDX = REG_EDX,
    REG_ECX,
    REG_GCX = REG_ECX,
    REG_EAX,
    REG_GAX = REG_EAX,
    REG_GR_LAST = REG_EAX,

    REG_SEG_BASE,
    REG_SEG_CS = REG_SEG_BASE,
    REG_SEG_SS,
    REG_SEG_DS,
    REG_SEG_ES,
    REG_SEG_FS,
    REG_SEG_GS,
    REG_SEG_LAST = REG_SEG_GS,

    REG_EFLAGS,
    REG_GFLAGS=REG_EFLAGS,
    REG_EIP,
    REG_INST_PTR = REG_EIP,
#line 113 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"


    REG_PHYSICAL_INTEGER_END = REG_INST_PTR,
#line 117 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    
    REG_AL,
    REG_AH,
    REG_AX,

    REG_CL,
    REG_CH,
    REG_CX,

    REG_DL,
    REG_DH,
    REG_DX,

    REG_BL,
    REG_BH,
    REG_BX,

    REG_BP,
    REG_SI,
    REG_DI,

    REG_SP,
    REG_FLAGS,
    REG_IP,










































#line 185 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_MM_BASE,
    REG_MM0 = REG_MM_BASE,
    REG_MM1,
    REG_MM2,
    REG_MM3,
    REG_MM4,
    REG_MM5,
    REG_MM6,
    REG_MM7,
    REG_MM_LAST = REG_MM7,

    REG_XMM_BASE,
    REG_FIRST_FP_REG = REG_XMM_BASE,
    REG_XMM0 = REG_XMM_BASE,
    REG_XMM1,
    REG_XMM2,
    REG_XMM3,
    REG_XMM4,
    REG_XMM5,
    REG_XMM6,
    REG_XMM7,

































#line 241 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_XMM_SSE_LAST = REG_XMM7,
    REG_XMM_AVX_LAST = REG_XMM_SSE_LAST,
    REG_XMM_AVX512_LAST = REG_XMM_AVX_LAST,
    REG_XMM_LAST = REG_XMM_AVX512_LAST,
#line 246 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_YMM_BASE,
    REG_YMM0 = REG_YMM_BASE,
    REG_YMM1,
    REG_YMM2,
    REG_YMM3,
    REG_YMM4,
    REG_YMM5,
    REG_YMM6,
    REG_YMM7,
































#line 289 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_YMM_AVX_LAST = REG_YMM7,
    REG_YMM_AVX512_LAST = REG_YMM_AVX_LAST,
    REG_YMM_LAST = REG_YMM_AVX512_LAST,
#line 293 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_ZMM_BASE,
    REG_ZMM0 = REG_ZMM_BASE,
    REG_ZMM1,
    REG_ZMM2,
    REG_ZMM3,
    REG_ZMM4,
    REG_ZMM5,
    REG_ZMM6,
    REG_ZMM7,






























#line 334 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_ZMM_AVX512_SPLIT_LAST = REG_ZMM7,
    REG_ZMM_AVX512_LAST = REG_ZMM_AVX512_SPLIT_LAST,
    REG_ZMM_LAST = REG_ZMM_AVX512_LAST,
#line 338 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_K_BASE,
    REG_K0 = REG_K_BASE,
    
    
    REG_IMPLICIT_FULL_MASK = REG_K0,
    REG_K1,
    REG_K2,
    REG_K3,
    REG_K4,
    REG_K5,
    REG_K6,
    REG_K7,
    REG_K_LAST = REG_K7,

    REG_MXCSR,
    REG_MXCSRMASK,

    
    



#line 362 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_ORIG_EAX,
    REG_ORIG_GAX = REG_ORIG_EAX,
#line 365 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_FPST_BASE,
    REG_FPSTATUS_BASE = REG_FPST_BASE,
    REG_FPCW = REG_FPSTATUS_BASE,
    REG_FPSW,
    REG_FPTAG,          
    REG_FPIP_OFF,
    REG_FPIP_SEL,
    REG_FPOPCODE,
    REG_FPDP_OFF,
    REG_FPDP_SEL,
    REG_FPSTATUS_LAST = REG_FPDP_SEL,

    REG_FPTAG_FULL,     

    REG_ST_BASE,
    REG_ST0 = REG_ST_BASE,
    REG_ST1,
    REG_ST2,
    REG_ST3,
    REG_ST4,
    REG_ST5,
    REG_ST6,
    REG_ST7,
    REG_ST_LAST = REG_ST7,
    REG_FPST_LAST = REG_ST_LAST,

    REG_DR_BASE,
    REG_DR0 = REG_DR_BASE,
    REG_DR1,
    REG_DR2,
    REG_DR3,
    REG_DR4,
    REG_DR5,
    REG_DR6,
    REG_DR7,
    REG_DR_LAST = REG_DR7,

    REG_CR_BASE,
    REG_CR0 = REG_CR_BASE,
    REG_CR1,
    REG_CR2,
    REG_CR3,
    REG_CR4,
    REG_CR_LAST = REG_CR4,

    REG_TSSR,
    REG_LDTR,

    REG_TR_BASE,
    REG_TR = REG_TR_BASE,
    REG_TR3,
    REG_TR4,
    REG_TR5,
    REG_TR6,
    REG_TR7,
    REG_TR_LAST = REG_TR7,

    

    REG_MACHINE_LAST = REG_TR_LAST, 

    

















    REG_STATUS_FLAGS,
    REG_DF_FLAG,

    
    
    REG_APPLICATION_LAST = REG_DF_FLAG, 

    
    REG_TOOL_BASE,

#line 456 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    
    
    REG_SEG_GS_BASE  = REG_TOOL_BASE, 
    REG_SEG_FS_BASE, 

    
    
    REG_INST_BASE,
    REG_INST_SCRATCH_BASE = REG_INST_BASE,  
    REG_INST_G0 = REG_INST_SCRATCH_BASE,    
    REG_INST_G1,                            
    REG_INST_G2,                            
    REG_INST_G3,                            
    REG_INST_G4,                            
    REG_INST_G5,                            
    REG_INST_G6,                            
    REG_INST_G7,                            
    REG_INST_G8,                            
    REG_INST_G9,                            
    REG_INST_G10,                           
    REG_INST_G11,                           
    REG_INST_G12,                           
    REG_INST_G13,                           
    REG_INST_G14,                           
    REG_INST_G15,                           
    REG_INST_G16,                           
    REG_INST_G17,                           
    REG_INST_G18,                           
    REG_INST_G19,                           
    REG_INST_G20,                           
    REG_INST_G21,                           
    REG_INST_G22,                           
    REG_INST_G23,                           
    REG_INST_G24,                           
    REG_INST_G25,                           
    REG_INST_G26,                           
    REG_INST_G27,                           
    REG_INST_G28,                           
    REG_INST_G29,                           
    REG_INST_TOOL_FIRST = REG_INST_G0,
    REG_INST_TOOL_LAST = REG_INST_G29,

    REG_BUF_BASE0,
    REG_BUF_BASE1,
    REG_BUF_BASE2,
    REG_BUF_BASE3,
    REG_BUF_BASE4,
    REG_BUF_BASE5,
    REG_BUF_BASE6,
    REG_BUF_BASE7,
    REG_BUF_BASE8,
    REG_BUF_BASE9,
    REG_BUF_BASE_LAST = REG_BUF_BASE9,

    REG_BUF_END0,
    REG_BUF_END1,
    REG_BUF_END2,
    REG_BUF_END3,
    REG_BUF_END4,
    REG_BUF_END5,
    REG_BUF_END6,
    REG_BUF_END7,
    REG_BUF_END8,
    REG_BUF_END9,
    REG_BUF_ENDLAST = REG_BUF_END9,
    REG_BUF_LAST = REG_BUF_ENDLAST,

    REG_INST_SCRATCH_LAST = REG_BUF_LAST,


































#line 560 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_TOOL_LAST = REG_BUF_LAST,
#line 562 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"


    REG_SPECIAL_BASE,

    
    
    
    
    
    REG_X87 = REG_SPECIAL_BASE,

    REG_SPECIAL_LAST = REG_X87,

    REG_PIN_BASE,

    REG_PIN_SEG_GS_VAL = REG_PIN_BASE,  
    REG_PIN_SEG_FS_VAL,                 

    REG_LAST_CONTEXT_REG = REG_PIN_SEG_FS_VAL,  

    REG_PIN_GR_BASE,

    
    REG_PIN_EDI = REG_PIN_GR_BASE,


    REG_PIN_GDI = REG_PIN_EDI,                  
#line 590 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_ESI,


    REG_PIN_GSI = REG_PIN_ESI,
#line 596 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_EBP,


    REG_PIN_GBP = REG_PIN_EBP,
#line 602 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_ESP,


    REG_PIN_STACK_PTR = REG_PIN_ESP,
#line 608 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_EBX,


    REG_PIN_GBX = REG_PIN_EBX,
#line 614 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_EDX,


    REG_PIN_GDX = REG_PIN_EDX,
#line 620 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_ECX,


    REG_PIN_GCX = REG_PIN_ECX,                  
#line 626 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_EAX,


    REG_PIN_GAX = REG_PIN_EAX,                  
#line 632 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_AL,
    REG_PIN_AH,
    REG_PIN_AX,
    REG_PIN_CL,
    REG_PIN_CH,
    REG_PIN_CX,
    REG_PIN_DL,
    REG_PIN_DH,
    REG_PIN_DX,
    REG_PIN_BL,
    REG_PIN_BH,
    REG_PIN_BX,
    REG_PIN_BP,
    REG_PIN_SI,
    REG_PIN_DI,
    REG_PIN_SP,


































































#line 716 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    
    REG_PIN_THREAD_ID,

    
    REG_PIN_INDIRREG,  
    REG_PIN_IPRELADDR, 
    REG_PIN_SYSENTER_RESUMEADDR, 
    REG_PIN_SYSCALL_NEXT_PC,  
    REG_PIN_VMENTER, 
                     
                     

    
    REG_PIN_T_BASE,










    REG_PIN_T0 = REG_PIN_T_BASE,
    REG_PIN_T0D = REG_PIN_T0,
    REG_PIN_T1,
    REG_PIN_T1D = REG_PIN_T1,
    REG_PIN_T2,
    REG_PIN_T2D = REG_PIN_T2,
    REG_PIN_T3,
    REG_PIN_T3D = REG_PIN_T3,
#line 750 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_PIN_T0W,    
    REG_PIN_T1W,
    REG_PIN_T2W,
    REG_PIN_T3W,
    REG_PIN_T0L,    
    REG_PIN_T1L,
    REG_PIN_T2L,
    REG_PIN_T3L,
    REG_PIN_T_LAST = REG_PIN_T3L,
    REG_PIN_THREAD_IDD,    
    REG_TO_SPILL_LAST = REG_PIN_THREAD_IDD,
    REG_PIN_INST_COND,     

    
    
    










    REG_PIN_INST_T0,
    REG_PIN_INST_T0D = REG_PIN_INST_T0,
    REG_PIN_INST_T1,
    REG_PIN_INST_T1D = REG_PIN_INST_T1,
    REG_PIN_INST_T2,
    REG_PIN_INST_T2D = REG_PIN_INST_T2,
    REG_PIN_INST_T3,
    REG_PIN_INST_T3D = REG_PIN_INST_T3,
#line 785 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_PIN_INST_T0W,    
    REG_PIN_INST_T1W,
    REG_PIN_INST_T2W,
    REG_PIN_INST_T3W,
    REG_PIN_INST_T0L,    
    REG_PIN_INST_T1L,
    REG_PIN_INST_T2L,
    REG_PIN_INST_T3L,

    
    REG_PIN_INST_PRESERVED_PREDICATE,

    
    REG_PIN_FLAGS_BEFORE_AC_CLEARING,

    
    
    
    REG_PIN_BRIDGE_ORIG_SP,    
    REG_PIN_BRIDGE_APP_IP, 
    REG_PIN_BRIDGE_SP_BEFORE_ALIGN, 
    REG_PIN_BRIDGE_SP_BEFORE_CALL, 
    REG_PIN_BRIDGE_SP_BEFORE_MARSHALLING_FRAME, 
    REG_PIN_BRIDGE_MARSHALLING_FRAME, 
    REG_PIN_BRIDGE_ON_STACK_CONTEXT_FRAME, 
    REG_PIN_BRIDGE_ON_STACK_CONTEXT_SP, 
    REG_PIN_BRIDGE_MULTI_MEMORYACCESS_FRAME, 
    REG_PIN_BRIDGE_MULTI_MEMORYACCESS_SP, 
    
    REG_PIN_MULTI_MEM_ACCESS_AND_REWRITE_EMULATION_INFO_FRAME,
    REG_PIN_BRIDGE_TRANS_MEMORY_CALLBACK_FRAME, 
    REG_PIN_BRIDGE_TRANS_MEMORY_CALLBACK_SP, 
    REG_PIN_TRANS_MEMORY_CALLBACK_READ_ADDR, 
    REG_PIN_TRANS_MEMORY_CALLBACK_READ2_ADDR, 
    REG_PIN_TRANS_MEMORY_CALLBACK_WRITE_ADDR, 
    REG_PIN_BRIDGE_SPILL_AREA_CONTEXT_FRAME, 
    REG_PIN_BRIDGE_SPILL_AREA_CONTEXT_SP, 

    REG_PIN_SPILLPTR,  
    REG_PIN_GR_LAST = REG_PIN_SPILLPTR,
    REG_PIN_X87,
    REG_PIN_MXCSR,

    
    

    



    REG_PIN_STATUS_FLAGS,
    REG_PIN_DF_FLAG,

    


    REG_PIN_FLAGS,

    REG_PIN_XMM_BASE,
    REG_PIN_XMM0 = REG_PIN_XMM_BASE,
    REG_PIN_XMM1,
    REG_PIN_XMM2,
    REG_PIN_XMM3,
    REG_PIN_XMM4,
    REG_PIN_XMM5,
    REG_PIN_XMM6,
    REG_PIN_XMM7,
































#line 885 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_PIN_XMM_SSE_LAST = REG_PIN_XMM7,
    REG_PIN_XMM_AVX_LAST = REG_PIN_XMM_SSE_LAST,
    REG_PIN_XMM_AVX512_LAST = REG_PIN_XMM_AVX_LAST,
    REG_PIN_XMM_LAST = REG_PIN_XMM_AVX512_LAST,
#line 890 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_YMM_BASE,
    REG_PIN_YMM0 = REG_PIN_YMM_BASE,
    REG_PIN_YMM1,
    REG_PIN_YMM2,
    REG_PIN_YMM3,
    REG_PIN_YMM4,
    REG_PIN_YMM5,
    REG_PIN_YMM6,
    REG_PIN_YMM7,































#line 932 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    REG_PIN_YMM_AVX_LAST = REG_PIN_YMM7,
    REG_PIN_YMM_AVX512_LAST = REG_PIN_YMM_AVX_LAST,
    REG_PIN_YMM_LAST = REG_PIN_YMM_AVX512_LAST,
#line 936 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_ZMM_BASE,
    REG_PIN_ZMM0 = REG_PIN_ZMM_BASE,
    REG_PIN_ZMM1,
    REG_PIN_ZMM2,
    REG_PIN_ZMM3,
    REG_PIN_ZMM4,
    REG_PIN_ZMM5,
    REG_PIN_ZMM6,
    REG_PIN_ZMM7,































    REG_PIN_ZMM_AVX512_SPLIT_LAST = REG_PIN_ZMM7,
    REG_PIN_ZMM_AVX512_LAST = REG_PIN_ZMM_AVX512_SPLIT_LAST,
    REG_PIN_ZMM_LAST = REG_PIN_ZMM_AVX512_LAST,
#line 981 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_PIN_K_BASE,
    REG_PIN_K0 = REG_PIN_K_BASE,
    REG_PIN_K1,
    REG_PIN_K2,
    REG_PIN_K3,
    REG_PIN_K4,
    REG_PIN_K5,
    REG_PIN_K6,
    REG_PIN_K7,
    REG_PIN_K_LAST = REG_PIN_K7,

    REG_PIN_LAST = REG_PIN_K_LAST,

#line 996 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    REG_LAST


} REG;

                                                                  
typedef enum {
    REG_ACCESS_READ,
    REG_ACCESS_WRITE,        
    REG_ACCESS_OVERWRITE     
} REG_ACCESS;

                                                                  
const ADDRINT NUM_PHYSICAL_REGS = REG_PHYSICAL_INTEGER_END - REG_PHYSICAL_INTEGER_BASE + 1;

                                                                  
const ADDRINT NUM_SCRATCH_REGS = REG_INST_SCRATCH_LAST - REG_INST_SCRATCH_BASE + 1;

                                                                  
const ADDRINT NUM_SPECIAL_REGS = 2 + NUM_SCRATCH_REGS;

                                                                  
const ADDRINT NUM_CONTEXT_INT_REGS = NUM_PHYSICAL_REGS + NUM_SPECIAL_REGS;

                                                                  
const ADDRINT NUM_CONTEXT_REGS = REG_LAST_CONTEXT_REG + 1;

                                                                  
const ADDRINT ARCH_STATE_SIZE = (NUM_PHYSICAL_REGS + NUM_SPECIAL_REGS)*sizeof(ADDRINT) +
                                      (FPSTATE_SIZE 
                                                         
                                                         
                                                         
                                      + FPSTATE_ALIGNMENT);

                                                                  
struct REGDEF_ENTRY {
    REG reg;                     
                                 
    UINT32 regSpillSize;         
    REGWIDTH regWidth;           
    UINT64 regClassBitMap;       
    UINT64 regSubClassBitMap;    
    REG_ALLOC_TYPE regAllocType; 
    REG regFullName;             
    REG regMachineName;          
                                 
    REG regPinName;              
};

                                                                  
extern const REGDEF_ENTRY _regDefTable[] ;

                                                                  
extern UINT64 _regClassBitMapTable[REG_LAST];

                                                                  
extern UINT64 _regSubClassBitMapTable[REG_LAST];

                                                                  
extern UINT32 _regSpillSizeTable[REG_LAST];

                                                                  
extern REGWIDTH _regWidthTable[REG_LAST];

                                                                  
extern REG_ALLOC_TYPE _regAllocTypeTable[REG_LAST];

                                                                  
extern REG _regFullNameTable[REG_LAST];

                                                                  
extern REG _regMachineNameTable[REG_LAST];

                                                                  
extern REG _regPinNameTable[REG_LAST];

                                                                  
extern INT32 _regWidthToBitWidth[];

                                                                  
inline VOID InitRegTables()
{
    for (UINT32 i=0; i<(int)REG_LAST; i++)
    {
        do{ if(LEVEL_BASE::SlowAssertsEnabled() && !((REG)(i)==_regDefTable[i].reg)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH",   __FUNCTION__   , 1082, std::string("") + "assertion failed: " "(REG)(i)==_regDefTable[i].reg" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        _regClassBitMapTable[i] = _regDefTable[i].regClassBitMap;
        _regSubClassBitMapTable[i] = _regDefTable[i].regSubClassBitMap;
        _regSpillSizeTable[i] = _regDefTable[i].regSpillSize;
        _regWidthTable[i] = _regDefTable[i].regWidth;
        _regAllocTypeTable[i] = _regDefTable[i].regAllocType;
        _regFullNameTable[i] = _regDefTable[i].regFullName;
        _regMachineNameTable[i] = _regDefTable[i].regMachineName;
        _regPinNameTable[i] = _regDefTable[i].regPinName;
    }
}

                                                                  
inline BOOL REG_is_reg(REG reg){ return (reg >= REG_RBASE) && (reg < REG_LAST);}

                                                                  
inline BOOL REG_is_pseudo(REG reg){ return (reg == REG_ORIG_GAX);}

                                                                  
inline BOOL REG_is_gr(REG reg)
{
    return ((_regClassBitMapTable[reg]) == ((REG_CLASS_BITS(1) << (REG_CLASS_GR))));
}

                                                                  
inline BOOL REG_is_fr(REG reg)
{
   const REG_CLASS_BITS  frClassMask =
        ((REG_CLASS_BITS(1) << (REG_CLASS_XMM)))                 |
        ((REG_CLASS_BITS(1) << (REG_CLASS_YMM)))                 |
        ((REG_CLASS_BITS(1) << (REG_CLASS_ZMM)))                 |
        ((REG_CLASS_BITS(1) << (REG_CLASS_K)))                   |
        ((REG_CLASS_BITS(1) << (REG_CLASS_FPST)))                |
        ((REG_CLASS_BITS(1) << (REG_CLASS_ST)))                  |
        ((REG_CLASS_BITS(1) << (REG_CLASS_MXCSR)))               |
        ((REG_CLASS_BITS(1) << (REG_CLASS_MXCSRMASK)));

   return (((_regClassBitMapTable[reg]) & frClassMask) != 0);
}

                                                                  
inline BOOL REG_is_br(REG reg)  { return 0; }

                                                                  
inline BOOL REG_is_gr64(REG reg)
{



#line 1132 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    
    return 0;
#line 1135 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
}

                                                                  
inline BOOL REG_is_gr32(REG reg)
{



#line 1144 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    return (_regClassBitMapTable[reg] == (REG_CLASS_BITS(1) << (REG_CLASS_GR)));
#line 1146 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
}

                                                                  
inline BOOL REG_is_pin_gr32(REG reg)
{



#line 1155 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
    return (_regClassBitMapTable[reg] == (REG_CLASS_BITS(1) << (REG_CLASS_PIN_GR)));
#line 1157 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
}

                                                                  
inline BOOL REG_is_gr16(REG reg)
{
    return (_regClassBitMapTable[reg] == (REG_CLASS_BITS(1) << (REG_CLASS_GRH16)));

}

                                                                  
inline BOOL REG_is_gr8(REG reg)
{
    const REG_CLASS_BITS  gr8classMask = ((REG_CLASS_BITS(1) << (REG_CLASS_GRU8))) | ((REG_CLASS_BITS(1) << (REG_CLASS_GRL8)));
    return ((_regClassBitMapTable[reg] & gr8classMask) != 0);

}

                                                                  
inline BOOL REG_is_seg(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_SEG))));
}

                                                                  
inline BOOL REG_is_fr_for_get_context(REG reg)
{
     const REG_CLASS_BITS  frClassMask =
        ((REG_CLASS_BITS(1) << (REG_CLASS_FPST)) )               |
        ((REG_CLASS_BITS(1) << (REG_CLASS_MXCSR)))               |
        ((REG_CLASS_BITS(1) << (REG_CLASS_MXCSRMASK)));

    return ((_regClassBitMapTable[reg] & frClassMask) != 0);
}

                                                                  
inline BOOL REG_is_mxcsr(REG reg) { return (REG_MXCSR == reg); }

                                                                  
inline BOOL REG_is_any_mxcsr(REG reg) { return (REG_MXCSR == reg || REG_PIN_MXCSR == reg); }

                                                                  
inline BOOL REG_is_mm(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_MM))));
}

                                                                  
inline BOOL REG_is_xmm(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_XMM))));
}

                                                                  
inline BOOL REG_is_ymm(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_YMM))));
}

                                                                  
inline BOOL REG_is_zmm(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_ZMM))));
}

                                                                  
inline BOOL REG_is_xmm_ymm_zmm(REG reg)
{
    const REG_CLASS_BITS xmm_ymm_zmmClassMask = ((REG_CLASS_BITS(1) << (REG_CLASS_XMM))) | ((REG_CLASS_BITS(1) << (REG_CLASS_YMM))) | ((REG_CLASS_BITS(1) << (REG_CLASS_ZMM)));
    return ((_regClassBitMapTable[reg] & xmm_ymm_zmmClassMask) != 0);
}

                                                                  
inline BOOL REG_is_any_vector_reg(REG reg)
{
    const REG_CLASS_BITS vectorClassMask =
            (REG_CLASS_BITS(1) << (REG_CLASS_XMM))     | (REG_CLASS_BITS(1) << (REG_CLASS_YMM))     | (REG_CLASS_BITS(1) << (REG_CLASS_ZMM)) |
            (REG_CLASS_BITS(1) << (REG_CLASS_PIN_XMM)) | (REG_CLASS_BITS(1) << (REG_CLASS_PIN_YMM)) | (REG_CLASS_BITS(1) << (REG_CLASS_PIN_ZMM));
    return ((_regClassBitMapTable[reg] & vectorClassMask) != 0);
}

                                                                  
inline BOOL REG_is_k_mask(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_K))));
}

                                                                  
inline BOOL REG_is_any_mask(REG reg)
{
    return ((_regClassBitMapTable[reg] & ((REG_CLASS_BITS(1) << (REG_CLASS_K)) | (REG_CLASS_BITS(1) << (REG_CLASS_PIN_K)))) != 0);
}

                                                                  
inline REG REG_corresponding_ymm_reg(REG reg) { return static_cast<REG>(reg-REG_XMM_BASE+REG_YMM_BASE); }

                                                                  
inline REG REG_corresponding_zmm_reg(REG reg) { return static_cast<REG>(reg-REG_XMM_BASE+REG_ZMM_BASE); }

                                                                  
inline BOOL REG_is_st(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_ST))));
}

                                                                  
inline BOOL REG_is_machine(REG reg)
{
    return ((reg >= REG_MACHINE_BASE) && (reg <= REG_MACHINE_LAST));
}

                                                                  
inline BOOL REG_is_application(REG reg)
{
    return ((_regClassBitMapTable[reg] & REGCBIT_APP_ALL) != 0);
}

                                                                  
inline BOOL REG_is_pin(REG reg)
{
    return ((_regClassBitMapTable[reg] & REGCBIT_PIN_ALL) != 0);
}

                                                                  
inline BOOL REG_is_subclass_none(REG reg)
{
    return ((_regSubClassBitMapTable[reg] &    (REG_SUBCLASS_BITS(1) << (REG_SUBCLASS_NONE))) != 0);
}

                                                                  
inline BOOL REG_is_pin_gpr(REG reg)
{
    return REG_is_pin(reg) && REG_is_subclass_none(reg);
}

                                                                  
inline BOOL REG_is_seg_base(REG reg)
{
    return (reg == REG_SEG_GS_BASE)||(reg == REG_SEG_FS_BASE);
}

                                                                  
inline BOOL REG_valid_for_iarg_reg_value(REG reg)
{
    const REG_CLASS_BITS allowedClassMask = (((REG_CLASS_BITS(1) << (REG_CLASS_GR))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GR))) | ((REG_CLASS_BITS(1) << (REG_CLASS_SEG)))
                                            | REGCBIT_PARTIAL | REGCBIT_APP_FLAGS | REGCBIT_PIN_FLAGS);
    const REG_CLASS_BITS disallowedPartialRegs = (((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS16))) | ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS32)))
                                        | ((REG_CLASS_BITS(1) << (REG_CLASS_IP16))) | ((REG_CLASS_BITS(1) << (REG_CLASS_IP32)))
                                        | ((REG_CLASS_BITS(1) << (REG_CLASS_DFLAG))) | ((REG_CLASS_BITS(1) << (REG_CLASS_STATUS_FLAGS))));

    
    if (REG_is_seg_base(reg))
        return 1;

    
    if (reg < REG_FIRST || reg > REG_LAST)
        return 0;

    
    
    if ((_regClassBitMapTable[reg] & disallowedPartialRegs) != 0)
        return 0;

    
    
    if (REG_is_pin_gpr(reg))
        return 0;

    
    
    return ((_regClassBitMapTable[reg] & allowedClassMask) != 0);
}

                                                                  
inline BOOL REG_is_pin_gr(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GR))));
}

                                                                  
inline BOOL REG_is_pin_gr_half32(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRH32))));
}

                                                                  
inline BOOL REG_is_pin_xmm(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_XMM))));
}

                                                                  
inline BOOL REG_is_pin_ymm(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_YMM))));
}

                                                                  
inline BOOL REG_is_pin_zmm(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_ZMM))));
}

                                                                  
inline BOOL REG_is_pin_xmm_ymm_zmm(REG reg)
{
    const REG_CLASS_BITS pin_xmm_ymm_zmmClassMask =
            ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_XMM))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_YMM))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_ZMM)));
    return ((_regClassBitMapTable[reg] & pin_xmm_ymm_zmmClassMask) != 0);
}

                                                                  
inline BOOL REG_is_pin_k_mask(REG reg)
{
    return (_regClassBitMapTable[reg] == ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_K))));
}

                                                                  
inline BOOL REG_is_avx512_hi16_xmm(const REG xmm)
{

    return 0;













#line 1392 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
}

                                                                  
inline BOOL REG_is_avx512_hi16_ymm(const REG ymm)
{

    return 0;













#line 1413 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"
}

                                                                  
inline BOOL REG_is_gr_type(REG reg)
{
    const REG_CLASS_BITS  grclassMask = ((REG_CLASS_BITS(1) << (REG_CLASS_GR))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GR)));
    return ((_regClassBitMapTable[reg] & grclassMask) != 0);
}

                                                                  
inline REG REG_AppFlags() {return REG_GFLAGS;}

                                                                  
inline BOOL REG_is_flags(REG reg) {return reg == REG_GFLAGS;}

                                                                  
inline BOOL REG_is_pin_flags(REG reg) {return reg == REG_PIN_FLAGS;}

                                                                  
inline BOOL REG_is_status_flags(REG reg) {return reg == REG_STATUS_FLAGS;}

                                                                  
inline BOOL REG_is_pin_status_flags(REG reg) {return reg == REG_PIN_STATUS_FLAGS;}

                                                                  
inline BOOL REG_is_df_flag(REG reg) {return reg == REG_DF_FLAG;}

                                                                  
inline BOOL REG_is_pin_df_flag(REG reg) {return reg == REG_PIN_DF_FLAG;}

                                                                  
inline BOOL REG_is_flags_type(REG reg)
{
    const REG_CLASS_BITS  flagsClassMask = (((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_FLAGS))));
    return ((_regClassBitMapTable[reg] & flagsClassMask) != 0);
}

                                                                  
inline BOOL REG_is_flags_any_size_type(REG reg)
{
    const REG_CLASS_BITS  flagsClassMask
        = (((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_FLAGS)))
        | ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS32))) | ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS16))));
    return ((_regClassBitMapTable[reg] & flagsClassMask) != 0);
}

                                                                  
inline BOOL REG_is_status_flags_type(REG reg)
{
    const REG_CLASS_BITS  flagsStatusClassMask = (((REG_CLASS_BITS(1) << (REG_CLASS_STATUS_FLAGS))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_STATUS_FLAGS))));
    return ((_regClassBitMapTable[reg] & flagsStatusClassMask) != 0);
}

                                                                  
inline BOOL REG_is_app_status_flags_type(REG reg)
{
    return ((_regClassBitMapTable[reg] & (REG_CLASS_BITS(1) << (REG_CLASS_STATUS_FLAGS))) != 0);
}

                                                                  
inline BOOL REG_is_df_flag_type(REG reg)
{
    const REG_CLASS_BITS  dfClassMask = (((REG_CLASS_BITS(1) << (REG_CLASS_DFLAG))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_DFLAG))));
    return ((_regClassBitMapTable[reg] & dfClassMask) != 0);
}

                                                                  
inline BOOL REG_is_app_df_flag_type(REG reg)
{
    return ((_regClassBitMapTable[reg] & (REG_CLASS_BITS(1) << (REG_CLASS_DFLAG))) != 0);
}

                                                                  
inline BOOL REG_is_any_flags_type(REG reg)
{
     return ((_regClassBitMapTable[reg] & (REGCBIT_APP_FLAGS | REGCBIT_PIN_FLAGS)) != 0);
}

                                                                  
inline BOOL REG_is_any_pin_flags(REG reg)
{
    return ((_regClassBitMapTable[reg] & REGCBIT_PIN_FLAGS) != 0);
}

                                                                  
inline BOOL REG_is_any_app_flags(REG reg)
{
    return ((_regClassBitMapTable[reg] & REGCBIT_APP_FLAGS) != 0);
}

                                                                  
inline REG REG_get_status_flags_reg_of_type(REG reg)
{
    if (REG_is_flags(reg))
    {
        return (REG_STATUS_FLAGS);
    }
    else
    {
        do{ if(!(REG_is_pin_flags(reg))) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH",   __FUNCTION__   , 1512, std::string("") + "assertion failed: " "REG_is_pin_flags(reg)" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        return (REG_PIN_STATUS_FLAGS);
    }
}

                                                                  
inline REG REG_get_df_flag_reg_of_type(REG reg)
{
    if (REG_is_flags(reg))
    {
        return (REG_DF_FLAG);
    }
    else
    {
        do{ if(!(REG_is_pin_flags(reg))) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH",   __FUNCTION__   , 1526, std::string("") + "assertion failed: " "REG_is_pin_flags(reg)" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        return (REG_PIN_DF_FLAG);
    }
}

                                                                  
inline REG REG_get_full_flags_reg_of_type(REG reg)
{
    if (REG_is_any_app_flags(reg))
    {
        return (REG_GFLAGS);
    }
    else
    {
        do{ if(!(REG_is_any_pin_flags(reg))) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH",   __FUNCTION__   , 1540, std::string("") + "assertion failed: " "REG_is_any_pin_flags(reg)" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        return (REG_PIN_FLAGS);
    }
}

                                                                  
inline BOOL REG_is_stackptr_type(REG reg)
{
    return ((_regSubClassBitMapTable[reg] & REGSBIT_STACKPTR_ALL) != 0);
}

                                                                  
inline BOOL REG_is_representative_reg(REG reg)
{
    
    const REG_CLASS_BITS  representativeClassMask = (((REG_CLASS_BITS(1) << (REG_CLASS_X87))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_X87))));
    return ((_regClassBitMapTable[reg] & representativeClassMask) != 0);
}

                                                                  
inline BOOL REG_is_pin_inst(REG reg)
{
    return ((_regSubClassBitMapTable[reg] & REGSBIT_PIN_INST_ALL) != 0);
}

                                                                  
inline BOOL REG_is_buffer(REG reg)
{
    return ((_regSubClassBitMapTable[reg] &    (REG_SUBCLASS_BITS(1) << (REG_SUBCLASS_PIN_INST_BUF))) != 0);
}

                                                                  
inline BOOL REG_is_inst_scratch(REG reg)
{
    return ((_regSubClassBitMapTable[reg] & REGSBIT_PIN_SCRATCH_ALL) != 0);
}

                                                                  
inline ADDRINT REG_regSubClassBitMapTable()
{
    return ((ADDRINT)(_regSubClassBitMapTable));
}

                                                                  
inline ADDRINT REG_regDefTable()
{
    return ((ADDRINT)(_regDefTable));
}

                                                                  
inline BOOL REG_is_pin_tmp(REG reg)
{
    return ((_regSubClassBitMapTable[reg] &    (REG_SUBCLASS_BITS(1) << (REG_SUBCLASS_PIN_TMP))) != 0);
}

                                                                  
typedef enum
{
    REGNAME_LAST
}REGNAME;

                                                                  
inline REG REG_INVALID() {return REG_INVALID_;}

                                                                  
inline BOOL REG_valid(REG reg){ return reg != REG_INVALID();}

                                                                  
inline BOOL REG_is_pin64(REG reg)
{

    
    return 0;
#line 1614 "C:\\Pin35\\source\\include\\pin\\gen\\reg_ia32.PH"

    return REG_is_pin_gr(reg);  
}

                                                                  
extern REG REG_LastSupportedXmm();

                                                                  
extern REG REG_LastSupportedYmm();

                                                                  
extern REG REG_LastSupportedZmm();

                                                                  
extern UINT32 REG_Size(REG reg);

                                                                  
extern REG REG_FullRegName(const REG reg);

                                                                  
extern string REG_StringShort(REG reg);

                                                                  
extern REG REG_IdentityCopy(const REG reg);

                                                                  


#line 119 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\reg_partial_ia32.PH"






inline BOOL REG_is_Half16(const REG reg)
{

    const REG_CLASS_BITS  rh16Mask =
        ((REG_CLASS_BITS(1) << (REG_CLASS_GRH16)))   |
        ((REG_CLASS_BITS(1) << (REG_CLASS_FLAGS16))) |
        ((REG_CLASS_BITS(1) << (REG_CLASS_IP16)))    |
        ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRH16)));

    return ((_regClassBitMapTable[reg] & rh16Mask) != 0);
}

                                                                  
inline REGWIDTH REG_Width(REG reg)
{
    return (_regWidthTable[reg]);
}

                                                                  
inline BOOL REG_is_Half32(const REG reg)
{
    return (REG_Width(reg) == REGWIDTH_32);
}

                                                                  
inline BOOL REG_is_Lower8(const REG reg)
{
    const REG_CLASS_BITS  rl8Mask = ((REG_CLASS_BITS(1) << (REG_CLASS_GRL8))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRL8)));
    return ((_regClassBitMapTable[reg] & rl8Mask) != 0);
}

                                                                  
inline BOOL REG_is_Upper8(const REG reg)
{

    const REG_CLASS_BITS  ru8Mask = ((REG_CLASS_BITS(1) << (REG_CLASS_GRU8))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRU8)));
    return ((_regClassBitMapTable[reg] & ru8Mask) != 0);
}

                                                                  
inline BOOL REG_is_Any8(const REG reg)
{

    const REG_CLASS_BITS  r8Mask
        = ((REG_CLASS_BITS(1) << (REG_CLASS_GRU8))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRU8)))
        | ((REG_CLASS_BITS(1) << (REG_CLASS_GRL8))) | ((REG_CLASS_BITS(1) << (REG_CLASS_PIN_GRL8)));
    return ((_regClassBitMapTable[reg] & r8Mask) != 0);
}

                                                                  
extern BOOL REG_is_partialreg(const REG reg);

                                                                  

#line 120 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\base_ia32.PH"






typedef enum
{
    
    
    
    
    PREDICATE_ALWAYS_TRUE,  
    PREDICATE_INVALID,
    
    PREDICATE_BELOW,          
    PREDICATE_BELOW_OR_EQUAL, 
    PREDICATE_LESS,           
    PREDICATE_LESS_OR_EQUAL,  
    PREDICATE_NOT_BELOW,      
    PREDICATE_NOT_BELOW_OR_EQUAL, 
    PREDICATE_NOT_LESS,       
    PREDICATE_NOT_LESS_OR_EQUAL,
    PREDICATE_NOT_OVERFLOW,   
    PREDICATE_NOT_PARITY  ,   
    PREDICATE_NOT_SIGN  ,     
    PREDICATE_NOT_ZERO  ,     
    PREDICATE_OVERFLOW,       
    PREDICATE_PARITY,         
    PREDICATE_SIGN  ,         
    PREDICATE_ZERO  ,         
    
    PREDICATE_CX_NON_ZERO,    
    PREDICATE_ECX_NON_ZERO,   
    PREDICATE_RCX_NON_ZERO,   
    PREDICATE_SAVED_GCX_NON_ZERO, 
    PREDICATE_LAST
}PREDICATE_IA32;

                                                                  

#line 121 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
 typedef PREDICATE_IA32 PREDICATE;

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\tls.PH"






typedef INT32 TLS_KEY;

                                                                  
const TLS_KEY INVALID_TLS_KEY=(-1);

                                                                  
template <TLS_KEY FirstKey_, TLS_KEY LastKey_> class TLS_ARRAY
{
  public:

    


    TLS_ARRAY() {Clear();}

    


    VOID Clear()
    {
        for (VOID ** pValue = m_array; pValue < m_array + m_numKeys; ++pValue)
        {
            *pValue = 0;
        }
    }

    


    VOID * Get(TLS_KEY tlsKey, BOOL * pResult = 0) const
    {
        if(pResult)
        {
            *pResult = IsValidKey(tlsKey);
        }
        return (IsValidKey(tlsKey) ? m_array[tlsKey - FirstKey_] : 0);
    }

    BOOL Set(TLS_KEY tlsKey, const VOID * value)
    {
        if (IsValidKey(tlsKey))
        {
            m_array[tlsKey - FirstKey_] = const_cast<VOID *>(value);
            return 1;
        }
        return 0;
    }

    


    VOID * & operator [] (TLS_KEY tlsKey) { return m_array[tlsKey - FirstKey_];}
    VOID * const & operator []  (TLS_KEY tlsKey) const { return m_array[tlsKey - FirstKey_];}

    


    static BOOL IsValidKey(TLS_KEY tlsKey)
    {
        return ((tlsKey <= LastKey_) && (tlsKey >= FirstKey_));
    }
  private:

    static const UINT32  m_numKeys = LastKey_ - FirstKey_ + 1;
    VOID * m_array[m_numKeys];
};

                                                                  

#line 124 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\exception.PH"






enum EXCEPTION_CLASS
{
    EXCEPTCLASS_NONE,                   
    EXCEPTCLASS_UNKNOWN,                
    EXCEPTCLASS_ACCESS_FAULT,           
    EXCEPTCLASS_INVALID_INS,            
    EXCEPTCLASS_INT_ERROR,              
    EXCEPTCLASS_FP_ERROR,               
    EXCEPTCLASS_MULTIPLE_FP_ERROR,      
    EXCEPTCLASS_DEBUG,                  
    EXCEPTCLASS_OS                      
};

                                                                  
enum EXCEPTION_CODE
{
    EXCEPTCODE_NONE,                    

    
    

    EXCEPTCODE_ACCESS_INVALID_ADDRESS,  
                                        
    EXCEPTCODE_ACCESS_DENIED,           
                                        
    EXCEPTCODE_ACCESS_INVALID_PAGE,     
                                        
    EXCEPTCODE_ACCESS_MISALIGNED,       
                                        
    EXCEPTCODE_ILLEGAL_INS,             
                                        
    EXCEPTCODE_PRIVILEGED_INS,          
                                        
    EXCEPTCODE_INT_DIVIDE_BY_ZERO,      
                                        
    EXCEPTCODE_INT_OVERFLOW_TRAP,       
                                        
    EXCEPTCODE_INT_BOUNDS_EXCEEDED,     
                                        
    EXCEPTCODE_X87_DIVIDE_BY_ZERO,      
                                        
    EXCEPTCODE_X87_OVERFLOW,            
                                        
    EXCEPTCODE_X87_UNDERFLOW,           
                                        
    EXCEPTCODE_X87_INEXACT_RESULT,      
                                        
    EXCEPTCODE_X87_INVALID_OPERATION,   
                                        
    EXCEPTCODE_X87_DENORMAL_OPERAND,    
                                        
    EXCEPTCODE_X87_STACK_ERROR,         
                                        
    EXCEPTCODE_SIMD_DIVIDE_BY_ZERO,     
                                        
    EXCEPTCODE_SIMD_OVERFLOW,           
                                        
    EXCEPTCODE_SIMD_UNDERFLOW,          
                                        
    EXCEPTCODE_SIMD_INEXACT_RESULT,     
                                        
    EXCEPTCODE_SIMD_INVALID_OPERATION,  
                                        
    EXCEPTCODE_SIMD_DENORMAL_OPERAND,   
                                        
    EXCEPTCODE_DBG_BREAKPOINT_TRAP,     
                                        
    EXCEPTCODE_DBG_SINGLE_STEP_TRAP,    
                                        

    

    EXCEPTCODE_ACCESS_WINDOWS_GUARD_PAGE,       
                                                
                                                
    EXCEPTCODE_ACCESS_WINDOWS_STACK_OVERFLOW,   
                                                
                                                
    EXCEPTCODE_WINDOWS,                         
                                                

    
    

    EXCEPTCODE_RECEIVED_UNKNOWN,                    
                                                    
    EXCEPTCODE_RECEIVED_ACCESS_FAULT,               
                                                    
    EXCEPTCODE_RECEIVED_AMBIGUOUS_X87,              
                                                    
                                                    
    EXCEPTCODE_RECEIVED_AMBIGUOUS_SIMD              
                                                    
                                                    
};

                                                                  
enum FAULTY_ACCESS_TYPE
{
    FAULTY_ACCESS_TYPE_UNKNOWN, 
    FAULTY_ACCESS_READ,         
    FAULTY_ACCESS_WRITE,        
    FAULTY_ACCESS_EXECUTE       
};

                                                                  
enum FPERROR
{
    FPERROR_DIVIDE_BY_ZERO =    (1<<0),     
    FPERROR_OVERFLOW =          (1<<1),     
    FPERROR_UNDERFLOW =         (1<<2),     
    FPERROR_INEXACT_RESULT =    (1<<3),     
    FPERROR_INVALID_OPERATION = (1<<4),     
    FPERROR_DENORMAL_OPERAND =  (1<<5),     
    FPERROR_X87_STACK_ERROR =   (1<<6)      
};

                                                                  
const UINT32 MAX_WINDOWS_EXCEPTION_ARGS = 5;

                                                                  
struct EXCEPTION_INFO
{
    
    
    

    









    EXCEPTION_INFO & Init(EXCEPTION_CODE exceptCode, ADDRINT exceptAddress);

    


    EXCEPTION_CODE GetExceptCode() const {return m_exceptCode;}

    


    static EXCEPTION_CLASS GetExceptClass(EXCEPTION_CODE exceptCode);
    EXCEPTION_CLASS GetExceptClass() const {return GetExceptClass(m_exceptCode);}

    


    ADDRINT GetExceptAddress() const {return m_exceptAddress;}

    


    VOID SetExceptAddress(ADDRINT exceptAddress) {m_exceptAddress = exceptAddress;}

    





    static BOOL IsTrap(EXCEPTION_CODE exceptCode);
    BOOL IsTrap() const {return IsTrap(m_exceptCode);}

    


    VOID Reset() {m_exceptCode = EXCEPTCODE_NONE;}

    



    BOOL IsEmpty() const {return (m_exceptCode == EXCEPTCODE_NONE);}

    


    string ToString() const;

    


    string GetCodeAsString() const;

  public:

    
    
    

    









    EXCEPTION_INFO & InitAccessFault(EXCEPTION_CODE exceptCode,
                                     ADDRINT exceptAddress,
                                     ADDRINT accessAddress,
                                     FAULTY_ACCESS_TYPE accessType = FAULTY_ACCESS_TYPE_UNKNOWN);

    


    BOOL IsAccessFault() const {return GetExceptClass() == EXCEPTCLASS_ACCESS_FAULT;}

    



    FAULTY_ACCESS_TYPE GetFaultyAccessType() const 
    {
        do{ if(!(IsAccessFault())) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\exception.PH",   __FUNCTION__   , 229, std::string("") + "assertion failed: " "IsAccessFault()" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0); 
        return m_specific.m_access.m_type;
    }

    






    BOOL GetFaultyAccessAddress(ADDRINT * pAccessAddress) const 
    {
        do{ if(!(IsAccessFault())) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\exception.PH",   __FUNCTION__   , 242, std::string("") + "assertion failed: " "IsAccessFault()" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        return m_specific.m_access.m_address.Get(pAccessAddress);
    }

  public:

    
    
    

    








    EXCEPTION_INFO & InitMultipleFpError(EXCEPTION_CODE exceptCode,
                                         ADDRINT exceptAddress,
                                         UINT32 fpErrors);

    


    BOOL IsMultipleFpException() const {return GetExceptClass() == EXCEPTCLASS_MULTIPLE_FP_ERROR;}

    



    UINT32 GetFpErrors() const
    {
        do{ if(!(IsMultipleFpException())) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\exception.PH",   __FUNCTION__   , 276, std::string("") + "assertion failed: " "IsMultipleFpException()" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0); 
        return m_specific.m_multipleFp.m_fpErrors;
    }

  public:

    
    
    

    










    EXCEPTION_INFO & InitWindowsSysException(UINT32 sysExceptCode,
                                          ADDRINT exceptAddress,
                                          UINT32 numArgs = 0,
                                          const ADDRINT * pArgs = 0);

    


    BOOL IsWindowsSysException() const {return m_exceptCode == EXCEPTCODE_WINDOWS;}

    



    UINT32 GetWindowsSysExceptionCode() const 
    {
        do{ if(!(IsWindowsSysException())) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\exception.PH",   __FUNCTION__   , 313, std::string("") + "assertion failed: " "IsWindowsSysException()" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        return m_specific.m_winsys.m_exceptCode;
    }

    



    UINT32 CountWindowsSysArguments() const 
    {
        do{ if(!(IsWindowsSysException())) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\exception.PH",   __FUNCTION__   , 323, std::string("") + "assertion failed: " "IsWindowsSysException()" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        return m_specific.m_winsys.m_numArgs;
    }

    







    ADDRINT GetWindowsSysArgument(UINT32 argNum) const 
    {
        do{ if(!(IsWindowsSysException())) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\exception.PH",   __FUNCTION__   , 337, std::string("") + "assertion failed: " "IsWindowsSysException()" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        do{ if(!(argNum < m_specific.m_winsys.m_numArgs)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\exception.PH",   __FUNCTION__   , 338, std::string("") + "assertion failed: " "argNum < m_specific.m_winsys.m_numArgs" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        return m_specific.m_winsys.m_args[argNum];
    }

  public:

    
    
    
    EXCEPTION_CODE m_exceptCode;                    
    ADDRINT m_exceptAddress;                        

    


    union EXCEPTION_SPECIFIC
    {
        struct ACCESS_FAULT                             
        {
            FAULTY_ACCESS_TYPE m_type;                  
            OPTIONAL_VALUE<ADDRINT> m_address;          
        }m_access;

        struct WINDOWS_SYS                              
        {
            UINT32 m_exceptCode;                        
            UINT32 m_numArgs;                           
            ADDRINT m_args[MAX_WINDOWS_EXCEPTION_ARGS]; 
        }m_winsys;

        struct MULTIPLE_FP                              
        {
            UINT32 m_fpErrors;                          
        }m_multipleFp;
    }m_specific;
};

                                                                  
typedef struct EXCEPTION_INFO EXCEPTION_INFO;

                                                                  
inline VOID PIN_InitExceptionInfo(EXCEPTION_INFO * pExceptInfo,
                                        EXCEPTION_CODE exceptCode, 
                                        ADDRINT exceptAddress)
{
    pExceptInfo->Init(exceptCode, exceptAddress);
}

                                                                  
inline VOID PIN_InitAccessFaultInfo(EXCEPTION_INFO * pExceptInfo,
                                          EXCEPTION_CODE exceptCode,
                                          ADDRINT exceptAddress,
                                          ADDRINT accessAddress,
                                          FAULTY_ACCESS_TYPE accessType = FAULTY_ACCESS_TYPE_UNKNOWN)
{
    pExceptInfo->InitAccessFault(exceptCode, exceptAddress, accessAddress, accessType);
}

                                                                  
inline VOID PIN_InitWindowsExceptionInfo(EXCEPTION_INFO * pExceptInfo,
                                               UINT32 sysExceptCode,
                                               ADDRINT exceptAddress,
                                               UINT32 numArgs = 0,
                                               const ADDRINT * pArgs = 0)
{
    pExceptInfo->InitWindowsSysException(sysExceptCode, exceptAddress, numArgs, pArgs);
}

                                                                  
inline EXCEPTION_CODE PIN_GetExceptionCode(const EXCEPTION_INFO * pExceptInfo)
{
    return pExceptInfo->GetExceptCode();
}

                                                                  
inline EXCEPTION_CLASS PIN_GetExceptionClass(EXCEPTION_CODE exceptCode)
{
    return EXCEPTION_INFO::GetExceptClass(exceptCode);
}

                                                                  
inline ADDRINT PIN_GetExceptionAddress(const EXCEPTION_INFO * pExceptInfo)
{
    return pExceptInfo->GetExceptAddress();
}

                                                                  
inline VOID PIN_SetExceptionAddress(EXCEPTION_INFO * pExceptInfo, 
                                          ADDRINT exceptAddress)
{
    pExceptInfo->SetExceptAddress(exceptAddress);
}

                                                                  
inline FAULTY_ACCESS_TYPE PIN_GetFaultyAccessType(const EXCEPTION_INFO * pExceptInfo) 
{
    return pExceptInfo->GetFaultyAccessType();
}

                                                                  
inline BOOL PIN_GetFaultyAccessAddress(const EXCEPTION_INFO * pExceptInfo,
                                             ADDRINT * pAccessAddress) 
{
    return pExceptInfo->GetFaultyAccessAddress(pAccessAddress);
}

                                                                  
inline UINT32 PIN_GetFpErrorSet(const EXCEPTION_INFO * pExceptInfo) 
{
    return pExceptInfo->GetFpErrors();
}

                                                                  
inline UINT32 PIN_GetWindowsExceptionCode(const EXCEPTION_INFO * pExceptInfo) 
{
    return pExceptInfo->GetWindowsSysExceptionCode();
}

                                                                  
inline UINT32 PIN_CountWindowsExceptionArguments(const EXCEPTION_INFO * pExceptInfo) 
{
    return pExceptInfo->CountWindowsSysArguments();
}

                                                                  
inline ADDRINT PIN_GetWindowsExceptionArgument(const EXCEPTION_INFO * pExceptInfo,
                                                     UINT32 argNum) 
{
    return pExceptInfo->GetWindowsSysArgument(argNum);
}

                                                                  
inline string PIN_ExceptionToString(const EXCEPTION_INFO * pExceptInfo) 
{
    return pExceptInfo->ToString();
}

                                                                  

#line 125 "c:\\pin35\\source\\include\\pin\\level_base.PLH"

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\child_process.PH"






class CHILD_PROCESS_CLASS
{
  public:
   









    CHILD_PROCESS_CLASS(UINT32 processId, 
                        const COMMAND_LINE_ARGUMENTS & appCmd, 
                        const COMMAND_LINE_ARGUMENTS & pinCmd) : m_processId(processId),
                                                                 m_appCmd(appCmd),
                                                                 m_pinCmd(pinCmd),
                                                                 m_isPinCmdModified(0)
    {
        (m_pinAndAppCmd = m_pinCmd).Insert(m_appCmd);
    }

   




    UINT32 GetId()
    {
        return m_processId;
    }

   









    BOOL GetApplicationCommandLine(INT * pArgc, const CHAR * const ** pArgv);

   










    BOOL SetPinCommandLine(INT argc, const CHAR * const * argv);

   










 
    BOOL GetPinCommandLine(INT * pArgc, const CHAR * const ** pArgv);

   










   
    BOOL GetFullCommandLine(INT * pArgc, const CHAR * const ** pArgv);

   

 
    BOOL IsPinCommandLineModified();

   



    ~CHILD_PROCESS_CLASS() {}

  private:
    UINT32                 m_processId;        
    COMMAND_LINE_ARGUMENTS m_appCmd;           
    COMMAND_LINE_ARGUMENTS m_pinCmd;           
    COMMAND_LINE_ARGUMENTS m_pinAndAppCmd;     
    BOOL                   m_isPinCmdModified; 
};

                                                                  

#line 127 "c:\\pin35\\source\\include\\pin\\level_base.PLH"


#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\os_info_win.PH"






const SYSCALL_NUMBER_T SYSCALL_NUMBER_INVALID = ~0;

                                                                  

#line 130 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\sysfuncs_windows.PH"







#line 131 "c:\\pin35\\source\\include\\pin\\level_base.PLH"








#line 140 "c:\\pin35\\source\\include\\pin\\level_base.PLH"

}
#line 143 "c:\\pin35\\source\\include\\pin\\level_base.PLH"
#line 44 "C:\\Pin35\\source\\include\\pin\\pin.H"
#line 1 "c:\\pin35\\source\\include\\pin\\level_core.PLH"










































extern "C" {
#line 1 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-types.h"







































#line 1 "c:\\pin35\\extras\\xed-ia32\\include\\xed\\xed-common-hdrs.h"




















































































#line 41 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-types.h"











#line 53 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-types.h"










#line 64 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-types.h"

typedef unsigned int  xed_uint_t;
typedef          int  xed_int_t;
typedef unsigned int  xed_bits_t;
typedef unsigned int  xed_bool_t;



#line 73 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-types.h"
typedef unsigned __int32 xed_addr_t;
#line 75 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-types.h"


typedef union {
   unsigned __int8   byte[2]; 
   __int8  s_byte[2]; 

  struct {
    unsigned __int8 b0; 
    unsigned __int8 b1; 
  } b;
  __int16  i16;
  unsigned __int16 u16;
} xed_union16_t ;

typedef union {
   unsigned __int8   byte[4]; 
   unsigned __int16  word[2]; 
   __int8  s_byte[4]; 
   __int16 s_word[2]; 

  struct {
    unsigned __int8 b0; 
    unsigned __int8 b1; 
    unsigned __int8 b2; 
    unsigned __int8 b3; 
  } b;

  struct {
    unsigned __int16 w0; 
    unsigned __int16 w1; 
  } w;
  __int32  i32;
  unsigned __int32 u32;
} xed_union32_t ;

typedef union {
   unsigned __int8      byte[8]; 
   unsigned __int16     word[4]; 
   unsigned __int32    dword[2]; 
   __int8     s_byte[8]; 
   __int16    s_word[4]; 
   __int32   s_dword[2]; 

  struct {
    unsigned __int8 b0; 
    unsigned __int8 b1; 
    unsigned __int8 b2; 
    unsigned __int8 b3; 
    unsigned __int8 b4; 
    unsigned __int8 b5; 
    unsigned __int8 b6; 
    unsigned __int8 b7; 
  } b;

  struct {
    unsigned __int16 w0; 
    unsigned __int16 w1;
    unsigned __int16 w2;
    unsigned __int16 w3; 
  } w;
  struct {
    unsigned __int32 lo32;
    unsigned __int32 hi32;
  } s;
    unsigned __int64 u64;
    __int64 i64;
} xed_union64_t ;


#line 145 "C:\\Pin35\\extras\\xed-ia32\\include\\xed\\xed-types.h"
#line 45 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
struct xed_decoded_inst_s;
typedef struct xed_decoded_inst_s xed_decoded_inst_t;
}

namespace LEVEL_CORE
{

using namespace LEVEL_BASE;
    
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\types_core.TLH"
















































template<int dummy>
class INDEX 
{


public:
    







    INT32 index;
    BOOL operator==(const INDEX<dummy> right) const { return right.index == index;}\
    BOOL operator!=(const INDEX<dummy> right) const { return right.index != index;}\
    BOOL operator<(const INDEX<dummy> right)  const { return index < right.index;}\
    
    
    
    
    
    INT32 q() const {return index;}
    BOOL is_valid() const { return (index>0);}
    VOID  q_set(INT32 y) {index=y;}
    VOID  invalidate() {index=0;}

};


  
typedef class INDEX<0> APP;

  
typedef class INDEX<1> IMG; 

  
typedef class INDEX<2> SEC; 

  
typedef class INDEX<3> RTN; 

  
typedef class INDEX<4> BBL; 

  
typedef class INDEX<5> EDG;

  
typedef class INDEX<6> INS;

  
typedef class INDEX<7> REL;
typedef class INDEX<8> EXT;

  
typedef class INDEX<9> SYM;

typedef class INDEX<20> CHUNK;
typedef class INDEX<21> LDEF;

typedef class INDEX<22> GOT;


typedef class INDEX<100> BBX;
typedef class INDEX<102> EDX;
typedef class INDEX<103> INX;


inline IMG MAKE_IMG(INT32 y){ IMG x; x.q_set(y); return x;}
inline INS MAKE_INS(INT32 y){ INS x; x.q_set(y); return x;}
inline BBL MAKE_BBL(INT32 y){ BBL x; x.q_set(y); return x;}
inline RTN MAKE_RTN(INT32 y){ RTN x; x.q_set(y); return x;}
inline EDG MAKE_EDG(INT32 y){ EDG x; x.q_set(y); return x;}
inline EXT MAKE_EXT(INT32 y){ EXT x; x.q_set(y); return x;}
inline REL MAKE_REL(INT32 y){ REL x; x.q_set(y); return x;}
inline SEC MAKE_SEC(INT32 y){ SEC x; x.q_set(y); return x;}
inline SYM MAKE_SYM(INT32 y){ SYM x; x.q_set(y); return x;}
inline GOT MAKE_GOT(INT32 y){ GOT x; x.q_set(y); return x;}
inline APP MAKE_APP(INT32 y){ APP x; x.q_set(y); return x;}

inline CHUNK MAKE_CHUNK(INT32 y){ CHUNK x; x.q_set(y); return x;}
inline LDEF MAKE_LDEF(INT32 y){ LDEF x; x.q_set(y); return x;}



template<int dummy>
class ADDR
{
  private:
    static const ADDRINT INVALID_ADDR = ~ADDRINT(0);
    
    ADDRINT address;
 public:

    
    
    VOID value_set(ADDRINT v=INVALID_ADDR) {address = v;}

    VOID add(ADDRINT v)       {address += v;}
    VOID sub(ADDRINT v)       {address -= v;} 
    VOID round_up(UINT32 alignment)    {address = RoundUp(address,alignment);} 
    VOID round_down(UINT32 alignment)  {address = RoundDown(address,alignment);} 

    ADDRINT value() const {return address;}
    UINT32 value_mod_2() const {return address % 2;} 
    UINT32 value_mod_4() const {return address % 4;} 
    UINT32 value_mod_8() const {return address % 8;}
    UINT32 value_mod_16() const {return address % 16;}
    UINT32 value_mod_32() const {return address % 32;}

    BOOL   valid() const { return address !=  INVALID_ADDR; }
    BOOL   zero() const { return address ==  ADDRINT(0); }
    ADDRDELTA diff( ADDR<dummy> a) const {return address - a.address;}

    int operator==(const ADDR<dummy> right) const { return right.address == address;}
    int operator!=(const ADDR<dummy> right) const { return right.address != address;}

    bool operator<(const ADDR<dummy> right) const { return address < right.address;}
    bool operator<=(const ADDR<dummy> right) const { return address <= right.address;}
    bool operator>(const ADDR<dummy> right) const { return address > right.address;}
    bool operator>=(const ADDR<dummy> right) const { return address >= right.address;}

    static  int cmp(const ADDR<dummy> lhs, const ADDR<dummy> rhs)
    {
        if( lhs < rhs ) return -1;
        else if( rhs < lhs ) return 1;
        else return 0;
    }

    static int qcmp(const void*x1, const void *x2)
    {
        return cmp( *static_cast<const ADDR<dummy> *>(x1),*static_cast<const ADDR<dummy> *>(x2));
    }
    
};

template<int dummy> inline string str( ADDR<dummy> a) {return StringFromAddrint(a.value());}

typedef class ADDR<1> IADDR;
typedef class ADDR<2> OADDR;

inline IADDR IADDR_INVALID() {IADDR x;x.value_set(); return x;}
inline IADDR MAKE_IADDR(ADDRINT y) {IADDR x;x.value_set(y); return x;}
inline IADDR MAKE_PTR_IADDR(const VOID *y) {IADDR x;x.value_set(reinterpret_cast<ADDRINT>(y)); return x;}

inline OADDR OADDR_INVALID() {OADDR x;x.value_set(); return x;}
inline OADDR MAKE_OADDR(ADDRINT y) {OADDR x;x.value_set(y); return x;}
inline OADDR MAKE_PTR_OADDR(const VOID *y) {OADDR x;x.value_set(reinterpret_cast<ADDRINT>(y)); return x;}

inline UINT32 INDEX_INVALID() {return ~(0L);}

inline BOOL IADDR_valid(IADDR a){return a.valid();}
inline BOOL OADDR_valid(OADDR a){return a.valid();}



class GOTENTRY;
class OPDENTRY;
class DYNAMICENTRY;




enum INSDECODE
{
    INSDECODE_OK,           
    INSDECODE_TOOSHORT,     
    INSDECODE_EXCEPTION     
};

#line 222 "C:\\Pin35\\source\\include\\pin\\gen\\types_core.TLH"
#line 55 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\val.PH"









#line 56 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\sec.PH"






typedef enum
{
    SEC_TYPE_INVALID,
    SEC_TYPE_UNUSED,
    SEC_TYPE_REGREL,    
    SEC_TYPE_DYNREL, 
    SEC_TYPE_EXEC, 
    SEC_TYPE_DATA, 
    SEC_TYPE_DYNAMIC,
    SEC_TYPE_OPD,
    SEC_TYPE_GOT,
    SEC_TYPE_STACK,
    SEC_TYPE_PLTOFF,
    SEC_TYPE_HASH,
    SEC_TYPE_LSDA,    
    SEC_TYPE_UNWIND,
    SEC_TYPE_UNWINDINFO,
    SEC_TYPE_REGSYM,
    SEC_TYPE_DYNSYM,
    SEC_TYPE_DEBUG,
    SEC_TYPE_BSS, 
    SEC_TYPE_SYMSTR,
    SEC_TYPE_DYNSTR,
    SEC_TYPE_SECSTR,
    SEC_TYPE_COMMENT,
    SEC_TYPE_LOOS,  
    SEC_TYPE_USER,  
    SEC_TYPE_LAST
}SEC_TYPE;

                                                                  

#line 57 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\img.PH"






typedef enum
{
    IMG_TYPE_INVALID,
    IMG_TYPE_STATIC, 
    IMG_TYPE_SHARED, 
    IMG_TYPE_SHAREDLIB, 
    IMG_TYPE_RELOCATABLE, 
    IMG_TYPE_DYNAMIC_CODE, 
    IMG_TYPE_API_CREATED, 
    IMG_TYPE_LAST
}IMG_TYPE;

                                                                  
struct IMG_REGION
{
    char    _region_name[16];
    ADDRINT _low_addr;
    ADDRINT _high_addr;
};

                                                                  

#line 58 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\bbl.PH"






typedef struct
{
    ADDRINT pos;
}BBL_STRUCT_MAP;

                                                                  
extern UINT32 BBL_NumAttrCrosslink(BBL bbl);

                                                                  
extern VOID BBL_MoveAllAttributes(BBL fromBbl, BBL toBbl);

                                                                  
extern UINT32 BBL_NumIns(BBL bbl);

                                                                  
extern CHUNK BBL_DataChunk(BBL bbl);

                                                                  

#line 59 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\edg.PH"







#line 60 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\ins.PH"











const __declspec(deprecated) UINT32 VARIABLE_MEMORY_REFERENCE_SIZE = ~0U;

                                                                  
typedef enum 
{
    MEMORY_TYPE_READ,
    MEMORY_TYPE_WRITE,
    MEMORY_TYPE_READ2
} MEMORY_TYPE;

                                                                  
typedef enum
{
    SYSCALL_STANDARD_INVALID,               
    SYSCALL_STANDARD_IA32_LINUX,            
    SYSCALL_STANDARD_IA32_LINUX_SYSENTER,   
    SYSCALL_STANDARD_IA32E_LINUX,           
    SYSCALL_STANDARD_IA32_MAC,              
    SYSCALL_STANDARD_IA32E_MAC,             
    SYSCALL_STANDARD_IA32_WINDOWS_FAST,     
    SYSCALL_STANDARD_IA32E_WINDOWS_FAST,    
    SYSCALL_STANDARD_IA32_WINDOWS_ALT,      
    SYSCALL_STANDARD_WOW64,                 
    SYSCALL_STANDARD_WINDOWS_INT            
} SYSCALL_STANDARD;

                                                                  

#line 61 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"






template<UINT32 _min, UINT32 _max> class REGISTER_SET
{
  private:
    static const UINT32  _SET_SIZE  = sizeof(ADDRINT)*8;  
    static const UINT32  _NUM_SETS  = ((_max-_min)/_SET_SIZE) + 1;
    static const ADDRINT _ONE       = ADDRINT(1);
    static const ADDRINT _ALL_ONES  = ~ADDRINT(0);

    ADDRINT _set[_NUM_SETS];
    
  public:
    REGISTER_SET()
    {
        for (UINT32 k=0; k< _NUM_SETS; k++)     {_set[k] = 0;}
    }

    REGISTER_SET(UINT32 first, UINT32 last)
    {
        for (UINT32 k=0; k< _NUM_SETS; k++)     {_set[k] = 0;}
        for (UINT32 r=first; r <= last; r++)    {Insert(REG(r));}
    }

    REG Min() const {return REG(_min);}
    REG Max() const {return REG(_max);}
    
    BOOL Contains(REG reg_no) const
    {
        const UINT32 i = UINT32(reg_no);



#line 39 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        do{ if(LEVEL_BASE::SlowAssertsEnabled() && !(_min <= i && i <= _max)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\regset.PH",   __FUNCTION__   , 39, std::string("") + "assertion failed: " "_min <= i && i <= _max" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);


#line 43 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        const UINT32 set_no = (i - _min) / _SET_SIZE;
        const UINT32 pos_no = (i - _min) % _SET_SIZE;
        return ((_set[ set_no ] & (_ONE << pos_no)) != 0);
    }

    VOID InsertVector(REG reg_no, UINT32 vector)
    {
        const UINT32 i = UINT32(reg_no);



#line 55 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        do{ if(LEVEL_BASE::SlowAssertsEnabled() && !(_min <= i && i <= _max)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\regset.PH",   __FUNCTION__   , 55, std::string("") + "assertion failed: " "_min <= i && i <= _max" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);


#line 59 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        const UINT32 set_no = (i - _min) / _SET_SIZE;
        do{ if(!(0 == (i - _min) % _SET_SIZE)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\regset.PH",   __FUNCTION__   , 60, std::string("") + "assertion failed: " "0 == (i - _min) % _SET_SIZE" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
        _set[set_no] = vector;
    }
    
    VOID InsertAll()
    {
        for (UINT32 k=0; k<_NUM_SETS; k++) {_set[k] = _ALL_ONES;}
    }

    VOID Insert(REG reg_no)
    {
        const UINT32 i = UINT32(reg_no);



#line 76 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        if(KnobSlowAsserts)
        {
            do{ if(!(_min <= i && i <= _max)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\regset.PH",   __FUNCTION__   , 79, std::string("") + "_min(" + decstr(_min) + ") i(" + decstr(i) + ") _max( " +decstr(_max) + ")\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
#line 80 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        }


#line 84 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        const UINT32 set_no = (i - _min) / _SET_SIZE;
        const UINT32 pos_no = (i - _min) % _SET_SIZE;

        _set[set_no] |= (_ONE << pos_no);
    }

    VOID Remove(REG reg_no)
    {
        const UINT32 i = UINT32(reg_no);



#line 97 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        do{ if(LEVEL_BASE::SlowAssertsEnabled() && !(_min <= i && i <= _max)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\regset.PH",   __FUNCTION__   , 97, std::string("") + "assertion failed: " "_min <= i && i <= _max" "\n"),1,PIN_ERR_ASSERT,0); }while(0);} while(0);


#line 101 "C:\\Pin35\\source\\include\\pin\\gen\\regset.PH"
        const UINT32 set_no = (i - _min) / _SET_SIZE;
        const UINT32 pos_no = (i - _min) % _SET_SIZE;

        _set[set_no] &= ~(_ONE << pos_no);
    }
    
    VOID Clear()
    {
        for (UINT32 k=0; k<_NUM_SETS; k++) {_set[k] = 0;}
    }

    VOID Invert()
    {
        for (UINT32 k=0; k<_NUM_SETS; k++) {_set[k] = ~_set[k];}
    }

    REG PopNext()
    {
        for (UINT32 i=_min; i<=_max; i++)
        {
            const REG reg = REG(i);
            if ( Contains(reg) )
            {
                Remove(reg);
                return reg;
            }
        }
        
        return REG_INVALID();
    }
    
    REG PopNextFast()
    {
        for (UINT32 s=0; s<_NUM_SETS; s++)
        {
            if (_set[s] == 0) continue;

            const UINT32 limit = (((_max)<((s+1) * _SET_SIZE))?(_max) : ((s+1) * _SET_SIZE));

            for (UINT32 i = _min + (s * _SET_SIZE); i <= limit; i++)
            {
                const REG reg = REG(i);
                if ( Contains(reg) )
                {
                    Remove(reg);
                    return reg;
                }
            }
        }
        
        return REG_INVALID();
    }
    
    UINT32 PopCount() const
    {
        UINT32 count = 0;
        for ( UINT32 s=0; s<_NUM_SETS; s++) {count += BitCount(_set[s]);}
        return count;
    }

    BOOL PopCountIsZero() const
    {
        for ( UINT32 s=0; s<_NUM_SETS; s++) {if( _set[s] != 0 ) return 0;}
        return 1;
    }

    UINT32 HashKey() const
    {
        UINT32 hashKey = 0;
        for ( UINT32 s=0; s<_NUM_SETS; s++) {hashKey = HashData(hashKey, _set[s]);}
        return hashKey;
    }
    
    REGISTER_SET operator| (const REGISTER_SET & b) const 
    {
        REGISTER_SET c;
  
        for (UINT32 i=0; i< _NUM_SETS; i++) {c._set[i] = _set[i] | b._set[i];}
        return c;
        
    }

    REGISTER_SET & operator|=(const REGISTER_SET & b)
    {
  
        for (UINT32 i=0; i< _NUM_SETS; i++) {_set[i] |= b._set[i];}
        return *this;
    }

    int operator== (const REGISTER_SET & b) const 
    {
        for (UINT32 i=0; i< _NUM_SETS; i++) {if( _set[i] != b._set[i] ) return 0;}
        return 1;
        
    }
    
    int operator!= (const REGISTER_SET & b) const 
    {
        for (UINT32 i=0; i< _NUM_SETS; i++) {if( _set[i] != b._set[i] ) return 1;}
        return 0;
    }

    REGISTER_SET operator& (const REGISTER_SET & b) const 
    {
        REGISTER_SET c;
  
        for (UINT32 i=0; i< _NUM_SETS; i++) {c._set[i] = _set[i] & b._set[i];}
        return c;
        
    }

    REGISTER_SET & operator&= (const REGISTER_SET & b)
    {
  
        for (UINT32 i=0; i< _NUM_SETS; i++) {_set[i] &= b._set[i];}
        return *this;
    }

    REGISTER_SET operator- (const REGISTER_SET & b) const
    {
        REGISTER_SET c;
  
        for (UINT32 i=0; i< _NUM_SETS; i++) {c._set[i] = _set[i] & ~b._set[i];}
        return c;
        
    }

    REGISTER_SET & operator-= (const REGISTER_SET & b)
    {
  
        for (UINT32 i=0; i< _NUM_SETS; i++) {_set[i] &= ~b._set[i];}
        return *this;
    }

    static inline string PrintRange(REG start, REG stop)
    {
        if ( start == stop )
        {
            return REG_StringShort( start );
        }
        else
        {
            return REG_StringShort( start ) + "-" + REG_StringShort( stop ) ;
        }
    }

    string Dump () const
    {
        string s("{");
        for (UINT32 i=0; i< _NUM_SETS; i++)
        {
            if (i!=0) s += ",";
            s += hexstr(_set[i]);
        }
        s += "}";
        return s;
    }
    
    string String () const
    {
        string s;
    
        s += "{";
        BOOL printed_range = 0;
        
        for (UINT32 i=_min; i<=_max; i++)
        {
            const REG reg = REG(i);
            
            if ( Contains(reg) ) 
            {
                if( printed_range ) s += ",";
                
                s += PrintRange(reg, reg);
                printed_range = 1;
            }
        }
    
        s += "}";
        
        return s;
    }

    string StringList() const
    {
        string s;
    
        s += "{";

        BOOL first = 1;
        
        for (UINT32 i=_min; i<=_max; i++)
        {
            const REG reg = REG(i);
            
            if ( Contains(reg) ) 
            {
                if (first)
                {
                    first = 0;
                }
                else
                {
                    s += ",";
                }   
                s += REG_StringShort(reg);
            }
        }
        
        s += "}";
        
        return s;
    }
    
};

                                                                  

#line 62 "c:\\pin35\\source\\include\\pin\\level_core.PLH"

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\ins_ia32.PH"






const USIZE SIZE_OF_RIP_AND_ADDR_PROBE = 14;

                                                                  
const USIZE SIZE_OF_RIP_PROBE = 6;

                                                                  
const USIZE SIZE_OF_MEMOFFSET_PROBE = 7;

                                                                  
const USIZE SIZE_OF_OFFSET_PROBE = 5;

                                                                  
extern VOID ThreadAwareMemcpy(VOID * dst, const VOID * src, USIZE size);

                                                                  
extern USIZE INS_MaxProbeSize(BOOL requestRipAndAddrProbe);

                                                                  
extern UINT32 INS_MaxNumRRegs(INS x);

                                                                  
extern UINT32 INS_MaxNumWRegs(INS x);

                                                                  
extern BOOL INS_RegRContain(const INS ins, const REG reg);

                                                                  
extern BOOL INS_RegWContain(const INS ins, const REG reg);

                                                                  
extern BOOL INS_FullRegRContain(const INS ins, const REG reg);

                                                                  
extern BOOL INS_FullRegWContain(const INS ins, const REG reg);

                                                                  
extern BOOL INS_IsStackRead(const INS ins);

                                                                  
extern BOOL INS_IsStackWrite(const INS ins);

                                                                  
extern BOOL INS_IsIpRelRead(const INS ins);

                                                                  
extern BOOL INS_IsIpRelWrite(const INS ins);

                                                                  
extern BOOL INS_IsPredicated(INS ins);

                                                                  
extern BOOL INS_HasRealRep(INS ins);

                                                                  
extern BOOL INS_IsOriginal(INS ins);

                                                                  
extern string INS_Disassemble(INS ins);

                                                                  




extern __declspec(deprecated) ADDRINT INS_MemoryOffset(INS ins);

                                                                  
extern ADDRDELTA INS_MemoryDisplacement(INS ins);

                                                                  
extern __declspec(deprecated) ADDRDELTA INS_MemoryDisplacementSigned(INS ins);

                                                                  
extern REG INS_MemoryBaseReg(INS ins);

                                                                  
extern REG INS_MemoryIndexReg(INS ins);

                                                                  
extern UINT32 INS_MemoryScale(INS ins);

                                                                  
extern BOOL INS_IsStandardMemop(INS ins);

                                                                  
extern BOOL INS_hasKnownMemorySize(INS ins);

                                                                  
extern BOOL INS_ChangeReg(const INS ins, const REG old_reg, const REG new_reg, const BOOL as_read);

                                                                  
extern BOOL INS_IsCacheLineFlush(INS ins);

                                                                  

#line 64 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\regset_ia32.PH"






const REG REG_FirstInRegset = REG_RBASE;

                                                                  
const REG REG_LastInRegset = REG(REG_LAST-1);

                                                                  
typedef class REGISTER_SET<REG_FirstInRegset, REG_LastInRegset>  REGSET;

                                                                  
inline BOOL REGSET_Contains(const REGSET & regset, REG reg) { return regset.Contains(reg);}

                                                                  
inline VOID REGSET_Insert(REGSET& regset, REG reg) { regset.Insert(reg);}

                                                                  
inline VOID REGSET_Remove(REGSET& regset, REG reg) { regset.Remove(reg);}

                                                                  
inline VOID REGSET_Clear(REGSET& regset) { regset.Clear();}

                                                                  
inline VOID REGSET_AddAll(REGSET& regset)
{
    regset.InsertAll();
}

                                                                  
inline REG REGSET_PopNext(REGSET& regset) { return regset.PopNext();}

                                                                  
inline UINT32 REGSET_PopCount(const REGSET& regset) { return regset.PopCount();}

                                                                  
inline BOOL REGSET_PopCountIsZero(const REGSET& regset) { return regset.PopCountIsZero();}

                                                                  
inline string REGSET_StringShort(const REGSET& regset) { return regset.String();}

                                                                  
inline string REGSET_StringList(const REGSET& regset) { return regset.StringList();}

                                                                  

#line 65 "c:\\pin35\\source\\include\\pin\\level_core.PLH"



#line 69 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\ins_syscall_ia32_windows.PH"






extern SYSCALL_STANDARD INS_SyscallStd(INS ins);

                                                                  
inline BOOL INS_IsSyscall(INS ins)
{
    return (INS_SyscallStd(ins) != SYSCALL_STANDARD_INVALID);
}

                                                                  

#line 70 "c:\\pin35\\source\\include\\pin\\level_core.PLH"


#line 73 "c:\\pin35\\source\\include\\pin\\level_core.PLH"

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\ins_api_xed_ia32.PH"






extern INT32 INS_Category(const INS ins);

                                                                  
extern INT32 INS_Extension(const INS ins);

                                                                  
extern UINT32 INS_EffectiveAddressWidth(INS ins);

                                                                  
extern USIZE INS_MemoryOperandSize(INS ins, UINT32 memoryOp);

                                                                  
extern USIZE INS_MemoryWriteSize(INS ins);

                                                                  
extern PREDICATE INS_GetPredicate(INS ins);

                                                                  
extern USIZE INS_MemoryReadSize(INS ins);

                                                                  
extern BOOL INS_IsMemoryRead(INS ins);

                                                                  
extern BOOL INS_IsMemoryWrite(INS ins);

                                                                  
extern BOOL INS_HasMemoryRead2(INS ins);

                                                                  
extern BOOL INS_HasFallThrough(INS ins);

                                                                  
extern BOOL INS_IsSysenter(INS ins);

                                                                  
extern BOOL INS_IsXbegin(INS ins);

                                                                  
extern BOOL INS_IsXend(INS ins);

                                                                  
extern BOOL INS_IsLea(INS ins);

                                                                  
extern BOOL INS_IsNop(INS ins);

                                                                  
extern string OPCODE_StringShort(UINT32 opcode);

                                                                  
extern string INS_Mnemonic(INS ins);

                                                                  
extern BOOL INS_IsBranch(INS ins);

                                                                  
extern BOOL INS_IsDirectBranch(INS ins);

                                                                  
extern BOOL INS_IsDirectCall(INS ins);

                                                                  
extern BOOL INS_IsDirectBranchOrCall(INS ins);

                                                                  
extern BOOL INS_IsHalt(INS ins);

                                                                  
extern BOOL INS_IsBranchOrCall(INS ins);

                                                                  
extern BOOL INS_Stutters(INS ins);

                                                                  
extern BOOL INS_IsPcMaterialization(INS ins);

                                                                  
extern BOOL INS_IsCall(INS ins);

                                                                  
extern BOOL INS_IsFarCall(INS ins);

                                                                  
extern BOOL INS_IsFarJump(INS ins);

                                                                  
extern BOOL INS_IsDirectFarJump(INS ins);

                                                                  
extern BOOL INS_IsVgather(INS ins);

                                                                  
extern BOOL INS_IsVscatter(INS ins);

                                                                  
extern BOOL INS_HasMemoryVector(INS ins);

                                                                  
extern VOID INS_GetFarPointer(INS ins,
                                 UINT16& segment_selector,
                                 UINT32& displacement);

                                                                  
extern BOOL INS_IsProcedureCall(INS ins);

                                                                  
extern BOOL INS_IsInterrupt(INS ins);

                                                                  
extern BOOL INS_IsRet(INS ins);

                                                                  
extern BOOL INS_IsSysret(INS ins);

                                                                  
extern BOOL INS_IsFarRet(INS ins);

                                                                  
extern BOOL INS_IsPrefetch(INS ins);

                                                                  
extern BOOL INS_IsSub(const INS ins);

                                                                  
extern BOOL INS_IsMov(const INS ins);

                                                                  
extern BOOL INS_IsMovFullRegRegSame(const INS ins);

                                                                  
extern BOOL INS_IsAtomicUpdate(const INS ins);

                                                                  
extern BOOL INS_IsRDTSC(const INS ins);

                                                                  
extern BOOL INS_IsMaskMov(const INS ins);

                                                                  
extern REG INS_RepCountRegister(INS ins);

                                                                  
extern BOOL INS_IsIndirectBranchOrCall(INS ins);

                                                                  
extern REG INS_SegmentRegPrefix(INS ins);

                                                                  




extern __declspec(deprecated) BOOL INS_IsRewritableMemOpBaseLimited(INS ins, MEMORY_TYPE mtype, REG & base);

                                                                  




extern __declspec(deprecated) BOOL INS_IsRewritableMemOpBase(INS ins, MEMORY_TYPE mtype, REG & base);

                                                                  




extern __declspec(deprecated) BOOL INS_IsDynamicRewritableMemOpBase(INS ins, MEMORY_TYPE mtype, REG & reg);

                                                                  
extern BOOL INS_HasExplicitMemoryReference(INS ins);

                                                                  
extern VOID PIN_SetSyntaxIntel();

                                                                  
extern VOID PIN_SetSyntaxATT();

                                                                  
extern VOID PIN_SetSyntaxXED();

                                                                  
extern REG INS_RegR(INS x, UINT32 k);

                                                                  
extern REG INS_RegW(INS x, UINT32 k);

                                                                  
extern OPCODE INS_Opcode(INS ins);

                                                                  
extern string CATEGORY_StringShort(UINT32 num);

                                                                  
extern string EXTENSION_StringShort(UINT32 num);

                                                                  
extern BOOL INS_SegPrefixIsMemoryRead(INS ins);

                                                                  
extern BOOL INS_SegPrefixIsMemoryWrite(INS ins);

                                                                  
extern BOOL INS_AddressSizePrefix(INS ins);

                                                                  
extern BOOL INS_BranchNotTakenPrefix(INS ins);

                                                                  
extern BOOL INS_BranchTakenPrefix(INS ins);

                                                                  
extern BOOL INS_LockPrefix(INS ins);

                                                                  
extern BOOL INS_OperandSizePrefix(INS ins);

                                                                  
extern BOOL INS_RepPrefix(INS ins);

                                                                  
extern BOOL INS_RepnePrefix(INS ins);

                                                                  
extern BOOL INS_SegmentPrefix(INS ins);

                                                                  
extern BOOL INS_IsXchg(INS ins);

                                                                  
extern BOOL INS_IsStringop(INS ins);

                                                                  
extern BOOL INS_IsIRet(INS ins);

                                                                  

#line 75 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\ins_xed_ia32.PH"






extern xed_decoded_inst_t* INS_XedDec(INS ins);

                                                                  
extern REG INS_XedExactMapToPinReg(unsigned int r);

                                                                  

#line 76 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\operand_ia32.PH"






extern UINT32 INS_OperandCount(INS ins);

                                                                  
extern UINT32 INS_OperandNameId(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandIsMemory(INS ins, UINT32 n);

                                                                  
extern REG INS_OperandMemoryBaseReg(INS ins, UINT32 n);

                                                                  
extern REG INS_OperandMemoryIndexReg(INS ins, UINT32 n);

                                                                  
extern REG INS_OperandMemorySegmentReg(INS ins, UINT32 n);

                                                                  
extern UINT32 INS_OperandMemoryScale(INS ins, UINT32 n);

                                                                  
extern ADDRDELTA INS_OperandMemoryDisplacement(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandIsFixedMemop(INS ins, UINT32 n);

                                                                  
extern VOID GetNumberAndSizeOfMemAccesses (INS ins, int *numAccesses, int *accessSize, int *indexSize);

                                                                  
extern UINT32 INS_MemoryOperandCount(INS ins);

                                                                  
extern BOOL INS_OperandIsAddressGenerator(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandIsBranchDisplacement(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandIsReg(INS ins, UINT32 n);

                                                                  
extern REG INS_OperandReg(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandIsImmediate(INS ins, UINT32 n);

                                                                  
extern UINT64 INS_OperandImmediate(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandIsImplicit(INS ins, UINT32 n);

                                                                  
extern BOOL INS_RegIsImplicit(INS ins, REG reg);

                                                                  
extern UINT32 INS_OperandWidth(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandRead(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandWritten(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandReadOnly(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandWrittenOnly(INS ins, UINT32 n);

                                                                  
extern BOOL INS_OperandReadAndWritten(INS ins, UINT32 n);

                                                                  



extern __declspec(deprecated) BOOL INS_OperandReadAndWriten(INS ins, UINT32 n);

                                                                  
extern BOOL INS_MemoryOperandIsRead(INS ins, UINT32 memopIdx);

                                                                  
extern BOOL INS_MemoryOperandIsWritten(INS ins, UINT32 memopIdx);

                                                                  
extern UINT32 INS_MemoryOperandIndexToOperandIndex(INS ins, UINT32 memopIdx);

                                                                  

#line 77 "c:\\pin35\\source\\include\\pin\\level_core.PLH"

} 

#line 81 "c:\\pin35\\source\\include\\pin\\level_core.PLH"
#line 45 "C:\\Pin35\\source\\include\\pin\\pin.H"
#line 1 "c:\\pin35\\source\\include\\pin\\level_vmapi.PLH"













































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"


#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdarg.h"















































#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 42 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 46 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 48 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 47 "c:\\pin35\\source\\include\\pin\\level_vmapi.PLH"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\vector"


























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 8 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"



 





#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_prolog.h"
#line 28 "C:\\Pin35\\extras\\stlport\\include\\vector"

#line 30 "C:\\Pin35\\extras\\stlport\\include\\vector"







#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
















































namespace std {





namespace priv {

template <class _Tp, class _Alloc>
class _Vector_base {
public:
  typedef _Vector_base<_Tp, _Alloc> _Self;
  
  typedef _Alloc allocator_type;
  typedef _Tp* pointer;
  typedef _STLP_alloc_proxy<pointer, _Tp, allocator_type> _AllocProxy;

  _Vector_base(const _Alloc& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

  _Vector_base(size_t __n, const _Alloc& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {
    _M_start = _M_end_of_storage.allocate(__n, __n);
    _M_finish = _M_start;
    _M_end_of_storage._M_data = _M_start + __n;
     
  }


  _Vector_base(__move_source<_Self> src)
    : _M_start(src.get()._M_start), _M_finish(src.get()._M_finish),
      _M_end_of_storage(__move_source<_AllocProxy>(src.get()._M_end_of_storage)) {
    
    src.get()._M_finish = src.get()._M_end_of_storage._M_data = src.get()._M_start = 0;
  }
#line 85 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

  ~_Vector_base() {
    if (_M_start != pointer())
      _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);
  }

protected:
  void  _M_throw_length_error() const;
  void  _M_throw_out_of_range() const;

  pointer _M_start;
  pointer _M_finish;
  _AllocProxy _M_end_of_storage;
};



#line 103 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

#line 105 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
}
#line 107 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

template <class _Tp, class _Alloc = allocator<_Tp> >
class vector : protected ::std::priv:: _Vector_base<_Tp, _Alloc>


#line 113 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
{
private:
  typedef ::std::priv:: _Vector_base<_Tp, _Alloc> _Base;
  typedef vector<_Tp, _Alloc> _Self;
public:
  
  typedef typename _Base::allocator_type allocator_type;

  typedef _Tp value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;

  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;

  allocator_type get_allocator() const
  { return (const allocator_type&)this->_M_end_of_storage; }

private:


#line 142 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

  
  void _M_insert_overflow_aux(pointer __pos, const _Tp& __x, const __false_type& ,
                              size_type __fill_len, bool __atend);
  void _M_insert_overflow_aux(pointer __pos, const _Tp& __x, const __true_type& ,
                              size_type __fill_len, bool __atend) {
    
    if (_M_is_inside(__x)) {
      value_type __x_copy = __x;
      _M_insert_overflow_aux(__pos, __x_copy, __false_type(), __fill_len, __atend);
      return;
    }
    _M_insert_overflow_aux(__pos, __x, __false_type(), __fill_len, __atend);
  }

  void _M_insert_overflow(pointer __pos, const _Tp& __x, const __false_type& ,
                          size_type __fill_len, bool __atend = false) {

    typedef typename __move_traits<_Tp>::implemented _Movable;
#line 162 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    _M_insert_overflow_aux(__pos, __x, _Movable(), __fill_len, __atend);
  }
  void _M_insert_overflow(pointer __pos, const _Tp& __x, const __true_type& ,
                          size_type __fill_len, bool __atend = false);
  void _M_range_check(size_type __n) const {
    if (__n >= size_type(this->_M_finish - this->_M_start))
      this->_M_throw_out_of_range();
  }

  size_type _M_compute_next_size(size_type __n) {
    const size_type __size = size();
    if (__n > max_size() - __size)
      this->_M_throw_length_error();
    size_type __len = __size + (max)(__n, __size);
    if (__len > max_size() || __len < __size)
      __len = max_size(); 
    return __len;
  }

public:
  iterator begin()             { return this->_M_start; }
  const_iterator begin() const { return this->_M_start; }
  iterator end()               { return this->_M_finish; }
  const_iterator end() const   { return this->_M_finish; }

  reverse_iterator rbegin()              { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const  { return const_reverse_iterator(end()); }
  reverse_iterator rend()                { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const    { return const_reverse_iterator(begin()); }

  size_type size() const        { return size_type(this->_M_finish - this->_M_start); }
  size_type max_size() const {
    size_type __vector_max_size = size_type(-1) / sizeof(_Tp);
    typename allocator_type::size_type __alloc_max_size = this->_M_end_of_storage.max_size();
    return (__alloc_max_size < __vector_max_size)?__alloc_max_size:__vector_max_size;
  }

  size_type capacity() const    { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }
  bool empty() const            { return this->_M_start == this->_M_finish; }

  reference operator[](size_type __n) { return *(begin() + __n); }
  const_reference operator[](size_type __n) const { return *(begin() + __n); }

  reference front()             { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back()              { return *(end() - 1); }
  const_reference back() const  { return *(end() - 1); }

  reference at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
  const_reference at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }


  explicit vector(const allocator_type& __a = allocator_type())




#line 220 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__a) {}


private:
  
  
  
  void _M_initialize(size_type __n, const _Tp& __val = _Tp())
  { this->_M_finish = ::std::priv:: __uninitialized_init(this->_M_start, __n, __val); }
public:
  explicit vector(size_type __n)
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__n, allocator_type())
  { _M_initialize(__n); }
  vector(size_type __n, const _Tp& __val, const allocator_type& __a = allocator_type())








#line 243 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__n, __a)
  { this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_start, __n, __val); }

  vector(const _Self& __x)
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__x.size(), __x.get_allocator()) {
    typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
    this->_M_finish = ::std::priv:: __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy());
  }


  vector(__move_source<_Self> src)
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__move_source<_Base>(src.get()))
  {}
#line 257 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"


private:
  template <class _Integer>
  void _M_initialize_aux(_Integer __n, _Integer __val,
                         const __true_type& ) {
    size_type __real_n = __n;
    this->_M_start = this->_M_end_of_storage.allocate(__n, __real_n);
    this->_M_end_of_storage._M_data = this->_M_start + __real_n;
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_start, __n, __val);
  }

  template <class _InputIterator>
  void _M_initialize_aux(_InputIterator __first, _InputIterator __last,
                         const __false_type& )
  { _M_range_initialize(__first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }

public:
  
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
               const allocator_type& __a = allocator_type() )
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__a) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_initialize_aux(__first, __last, _Integral());
  }








#line 292 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"








#line 301 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

  
  
  ~vector() { ::std::_Destroy_Range(rbegin(), rend()); }

  _Self& operator=(const _Self& __x);

  void reserve(size_type __n);

  
  
  
  

  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }
  void _M_fill_assign(size_type __n, const _Tp& __val);


  template <class _ForwardIter>
  void _M_assign_aux(_ForwardIter __first, _ForwardIter __last, const forward_iterator_tag &) {



#line 325 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    const size_type __len = ::std::distance(__first, __last);
    if (__len > capacity()) {
      size_type __n = __len;
      iterator __tmp = _M_allocate_and_copy(__n, __first, __last);
      _M_clear();
      _M_set(__tmp, __tmp + __len, __tmp + __n);
    }
    else if (size() >= __len) {
      iterator __new_finish = copy(__first, __last, this->_M_start);
      ::std::_Destroy_Range(__new_finish, this->_M_finish);
      this->_M_finish = __new_finish;
    }
    else {
      _ForwardIter __mid = __first;
      ::std::advance(__mid, size());
      ::std::copy(__first, __mid, this->_M_start);
      this->_M_finish = ::std::uninitialized_copy(__mid, __last, this->_M_finish);
    }
  }


  template <class _InputIter>
  void _M_assign_aux(_InputIter __first, _InputIter __last,
                     const input_iterator_tag &) {
    iterator __cur = begin();
    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
      *__cur = *__first;
    if (__first == __last)
      erase(__cur, end());
    else
      insert(end(), __first, __last);
  }

  template <class _Integer>
  void _M_assign_dispatch(_Integer __n, _Integer __val,
                          const __true_type& )
  { _M_fill_assign(__n, __val); }

  template <class _InputIter>
  void _M_assign_dispatch(_InputIter __first, _InputIter __last,
                          const __false_type& )
  { _M_assign_aux(__first, __last, typename ::std::iterator_traits< _InputIter >::iterator_category()); }

  template <class _InputIterator>
  void assign(_InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_assign_dispatch(__first, __last, _Integral());
  }
#line 374 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"


  void push_back(const _Tp& __x = _Tp()) {


#line 380 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    if (this->_M_finish != this->_M_end_of_storage._M_data) {
      _Copy_Construct(this->_M_finish, __x);
      ++this->_M_finish;
    }
    else {
      typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
      _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1, true);
    }
  }








#line 398 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"


  iterator insert(iterator __pos, const _Tp& __x = _Tp());


#line 404 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"




#line 409 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

  void swap(_Self& __x) {
    ::std::swap(this->_M_start, __x._M_start);
    ::std::swap(this->_M_finish, __x._M_finish);
    this->_M_end_of_storage.swap(__x._M_end_of_storage);
  }


#line 418 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

private:
  void _M_fill_insert_aux (iterator __pos, size_type __n, const _Tp& __x, const __true_type& );
  void _M_fill_insert_aux (iterator __pos, size_type __n, const _Tp& __x, const __false_type& );
  void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);

  bool _M_is_inside(const value_type& __x) const {
    return (&__x >= this->_M_start && &__x < this->_M_finish);
  }


  template <class _ForwardIterator>
  void _M_range_insert_realloc(iterator __pos,
                               _ForwardIterator __first, _ForwardIterator __last,



#line 436 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
                               size_type __n) {
    typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;

    typedef typename __move_traits<_Tp>::implemented _Movable;
#line 441 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    size_type __len = _M_compute_next_size(__n);
    pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);
    pointer __new_finish = __new_start;
     {
      __new_finish = ::std::priv:: __uninitialized_move(this->_M_start, __pos, __new_start, _TrivialUCopy(), _Movable());
      __new_finish = uninitialized_copy(__first, __last, __new_finish);
      __new_finish = ::std::priv:: __uninitialized_move(__pos, this->_M_finish, __new_finish, _TrivialUCopy(), _Movable());
    }
    
#line 451 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    _M_clear_after_move();
    _M_set(__new_start, __new_finish, __new_start + __len);
  }


  template <class _ForwardIterator>
  void _M_range_insert_aux(iterator __pos,
                           _ForwardIterator __first, _ForwardIterator __last,



#line 463 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
                           size_type __n, const __true_type& ) {
    iterator __src = this->_M_finish - 1;
    iterator __dst = __src + __n;
    for (; __src >= __pos; --__dst, --__src) {
      ::std::_Move_Construct(__dst, *__src);
      ::std::_Destroy_Moved(__src);
    }
    uninitialized_copy(__first, __last, __pos);
    this->_M_finish += __n;
  }


  template <class _ForwardIterator>
  void _M_range_insert_aux(iterator __pos,
                           _ForwardIterator __first, _ForwardIterator __last,



#line 482 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
                           size_type __n, const __false_type& ) {
    typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
    typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
    const size_type __elems_after = this->_M_finish - __pos;
    pointer __old_finish = this->_M_finish;
    if (__elems_after > __n) {
      ::std::priv:: __ucopy_ptrs(this->_M_finish - __n, this->_M_finish, this->_M_finish, _TrivialUCopy());
      this->_M_finish += __n;
      ::std::priv:: __copy_backward_ptrs(__pos, __old_finish - __n, __old_finish, _TrivialCopy());
      copy(__first, __last, __pos);
    }
    else {

      _ForwardIterator __mid = __first;
      ::std::advance(__mid, __elems_after);


#line 500 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
      uninitialized_copy(__mid, __last, this->_M_finish);
      this->_M_finish += __n - __elems_after;
      ::std::priv:: __ucopy_ptrs(__pos, __old_finish, this->_M_finish, _TrivialUCopy());
      this->_M_finish += __elems_after;
      copy(__first, __mid, __pos);
    } 
  }



  template <class _Integer>
  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                          const __true_type&)
  { _M_fill_insert(__pos, (size_type) __n, (_Tp) __val); }

  template <class _InputIterator>
  void _M_insert_dispatch(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          const __false_type&)
  { _M_range_insert(__pos, __first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }

public:
  
  template <class _InputIterator>
  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_insert_dispatch(__pos, __first, __last, _Integral());
  }

private:
  template <class _InputIterator>
  void _M_range_insert(iterator __pos,
                       _InputIterator __first, _InputIterator __last,
                       const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __pos = insert(__pos, *__first);
      ++__pos;
    }
  }

  template <class _ForwardIterator>
  void _M_range_insert(iterator __pos,
                       _ForwardIterator __first, _ForwardIterator __last,
                       const forward_iterator_tag &) {




#line 549 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

    typedef typename __move_traits<_Tp>::implemented _Movable;
#line 552 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    


    if (__first != __last) {
      size_type __n = ::std::distance(__first, __last);

      if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
        _M_range_insert_aux(__pos, __first, __last, __n, _Movable());
      }
      else {
        _M_range_insert_realloc(__pos, __first, __last, __n);
      }
    }
  }

public:
  void insert (iterator __pos, size_type __n, const _Tp& __x)
  { _M_fill_insert(__pos, __n, __x); }

  void pop_back() {
    --this->_M_finish;
    ::std::_Destroy(this->_M_finish);
  }

private:
  iterator _M_erase(iterator __pos, const __true_type& ) {
    ::std::_Destroy(__pos);
    iterator __dst = __pos, __src = __dst + 1;
    iterator __end = end();
    for (; __src != __end; ++__dst, ++__src) {
      ::std::_Move_Construct(__dst, *__src);
      ::std::_Destroy_Moved(__src);
    }
    this->_M_finish = __dst;
    return __pos;
  }
  iterator _M_erase(iterator __pos, const __false_type& ) {
    if (__pos + 1 != end()) {
      typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
      ::std::priv:: __copy_ptrs(__pos + 1, this->_M_finish, __pos, _TrivialCopy());
    }
    --this->_M_finish;
    ::std::_Destroy(this->_M_finish);
    return __pos;
  }
  iterator _M_erase(iterator __first, iterator __last, const __true_type& ) {
    iterator __dst = __first, __src = __last;
    iterator __end = end();
    for (; __dst != __last && __src != __end; ++__dst, ++__src) {
      ::std::_Destroy(__dst);
      ::std::_Move_Construct(__dst, *__src);
    }
    if (__dst != __last) {
      
      ::std::_Destroy_Range(__dst, __last);
      ::std::_Destroy_Moved_Range(__last, __end);
    }
    else {
      
      for (; __src != __end; ++__dst, ++__src) {
        ::std::_Destroy_Moved(__dst);
        ::std::_Move_Construct(__dst, *__src);
      }
      ::std::_Destroy_Moved_Range(__dst, __end);
    }
    this->_M_finish = __dst;
    return __first;
  }
  iterator _M_erase(iterator __first, iterator __last, const __false_type& ) {
    typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
    pointer __i = ::std::priv:: __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());
    ::std::_Destroy_Range(__i, this->_M_finish);
    this->_M_finish = __i;
    return __first;
  }

public:
  iterator erase(iterator __pos) {

    typedef typename __move_traits<_Tp>::implemented _Movable;
#line 633 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    return _M_erase(__pos, _Movable());
  }
  iterator erase(iterator __first, iterator __last) {

    typedef typename __move_traits<_Tp>::implemented _Movable;
#line 639 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    if (__first == __last)
      return __first;
    return _M_erase(__first, __last, _Movable());
  }


  void resize(size_type __new_size, const _Tp& __x = _Tp()) {


#line 649 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
    if (__new_size < size())
      erase(begin() + __new_size, end());
    else
      insert(end(), __new_size - size(), __x);
  }



#line 658 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

  void clear() {
    erase(begin(), end());
  }

private:
  void _M_clear() {
    ::std::_Destroy_Range(rbegin(), rend());
    this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);
  }

  void _M_clear_after_move() {
    ::std::_Destroy_Moved_Range(rbegin(), rend());
    this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);
  }

  void _M_set(pointer __s, pointer __f, pointer __e) {
    this->_M_start = __s;
    this->_M_finish = __f;
    this->_M_end_of_storage._M_data = __e;
  }


  template <class _ForwardIterator>
  pointer _M_allocate_and_copy(size_type& __n,
                               _ForwardIterator __first, _ForwardIterator __last)



#line 688 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
  {
    pointer __result = this->_M_end_of_storage.allocate(__n, __n);
     {
      uninitialized_copy(__first, __last, __result);
      return __result;
    }
    
    
  }



  template <class _InputIterator>
  void _M_range_initialize(_InputIterator __first, _InputIterator __last,
                           const input_iterator_tag &) {
    for ( ; __first != __last; ++__first)
      push_back(*__first);
  }
  
  template <class _ForwardIterator>
  void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                           const forward_iterator_tag &) {
    size_type __n = ::std::distance(__first, __last);
    this->_M_start = this->_M_end_of_storage.allocate(__n, __n);
    this->_M_end_of_storage._M_data = this->_M_start + __n;
    this->_M_finish = uninitialized_copy(__first, __last, this->_M_start);
  }
#line 716 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
};




#line 722 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

}


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"






























#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"

#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_range_errors.h"




























































#line 34 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"

namespace std {

namespace priv {

template <class _Tp, class _Alloc>
void _Vector_base<_Tp,_Alloc>::_M_throw_length_error() const
{ __stl_throw_length_error("vector"); }

template <class _Tp, class _Alloc>
void _Vector_base<_Tp, _Alloc>::_M_throw_out_of_range() const
{ __stl_throw_out_of_range("vector"); }



#line 50 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"

#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"
}
#line 54 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"



#line 58 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"

#line 60 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::reserve(size_type __n) {
  if (capacity() < __n) {
    if (max_size() < __n) {
      this->_M_throw_length_error();
    }

    const size_type __old_size = size();
    pointer __tmp;
    if (this->_M_start) {
      __tmp = _M_allocate_and_copy(__n, this->_M_start, this->_M_finish);
      _M_clear();
    } else {
      __tmp = this->_M_end_of_storage.allocate(__n, __n);
    }
    _M_set(__tmp, __tmp + __old_size, __tmp + __n);
  }
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_insert_overflow_aux(pointer __pos, const _Tp& __x, const __false_type& ,
                                                 size_type __fill_len, bool __atend ) {
  typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;

  typedef typename __move_traits<_Tp>::implemented _Movable;
#line 87 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"
  size_type __len = _M_compute_next_size(__fill_len);
  pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);
  pointer __new_finish = __new_start;
   {
    __new_finish = ::std::priv:: __uninitialized_move(this->_M_start, __pos, __new_start, _TrivialUCopy(), _Movable());
    
    if (__fill_len == 1) {
      _Copy_Construct(__new_finish, __x);
      ++__new_finish;
    } else
      __new_finish = ::std::priv:: __uninitialized_fill_n(__new_finish, __fill_len, __x);
    if (!__atend)
      __new_finish = ::std::priv:: __uninitialized_move(__pos, this->_M_finish, __new_finish, _TrivialUCopy(), _Movable()); 
  }
  
#line 103 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"
  _M_clear_after_move();
  _M_set(__new_start, __new_finish, __new_start + __len);
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_insert_overflow(pointer __pos, const _Tp& __x, const __true_type& ,
                                             size_type __fill_len, bool __atend ) {
  size_type __len = _M_compute_next_size(__fill_len);
  pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);
  pointer __new_finish = static_cast<pointer>(::std::priv:: __copy_trivial(this->_M_start, __pos, __new_start));
  
  __new_finish = ::std::priv:: __fill_n(__new_finish, __fill_len, __x);
  if (!__atend)
    __new_finish = static_cast<pointer>(::std::priv:: __copy_trivial(__pos, this->_M_finish, __new_finish)); 
  _M_clear();
  _M_set(__new_start, __new_finish, __new_start + __len);
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_insert_aux(iterator __pos, size_type __n,
                                             const _Tp& __x, const __true_type& ) {
  if (_M_is_inside(__x)) {
    _Tp __x_copy = __x;
    _M_fill_insert_aux(__pos, __n, __x_copy, __true_type());
    return;
  }
  iterator __src = this->_M_finish - 1;
  iterator __dst = __src + __n;
  for (; __src >= __pos; --__dst, --__src) {
    ::std::_Move_Construct(__dst, *__src);
    ::std::_Destroy_Moved(__src);
  }
  ::std::priv:: __uninitialized_fill_n(__pos, __n, __x);
  this->_M_finish += __n;
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_insert_aux (iterator __pos, size_type __n,
                                              const _Tp& __x, const __false_type& ) {
  typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
  
  if (_M_is_inside(__x)) {
    _Tp __x_copy = __x;
    _M_fill_insert_aux(__pos, __n, __x_copy, __false_type());
    return;
  }
  const size_type __elems_after = this->_M_finish - __pos;
  pointer __old_finish = this->_M_finish;
  if (__elems_after > __n) {
    ::std::priv:: __ucopy_ptrs(this->_M_finish - __n, this->_M_finish, this->_M_finish, _TrivialUCopy());
    this->_M_finish += __n;
    ::std::priv:: __copy_backward_ptrs(__pos, __old_finish - __n, __old_finish, _TrivialCopy());
    ::std::fill(__pos, __pos + __n, __x);
  } else {
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_finish, __n - __elems_after, __x);
    ::std::priv:: __ucopy_ptrs(__pos, __old_finish, this->_M_finish, _TrivialUCopy());
    this->_M_finish += __elems_after;
    ::std::fill(__pos, __old_finish, __x);
  }
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_insert(iterator __pos,
                                         size_type __n, const _Tp& __x) {

  typedef typename __move_traits<_Tp>::implemented _Movable;
#line 171 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"
  if (__n != 0) {
    if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
      _M_fill_insert_aux(__pos, __n, __x, _Movable());
    } else {
      typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
      _M_insert_overflow(__pos, __x, _TrivialCopy(), __n);
    }
  }
}

template <class _Tp, class _Alloc>
vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
  typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
  if (&__x != this) {
    const size_type __xlen = __x.size();
    if (__xlen > capacity()) {
      size_type __len = __xlen;
      pointer __tmp = _M_allocate_and_copy(__len, const_cast<const_pointer>(__x._M_start) + 0,
                                                  const_cast<const_pointer>(__x._M_finish) + 0);
      _M_clear();
      this->_M_start = __tmp;
      this->_M_end_of_storage._M_data = this->_M_start + __len;
    } else if (size() >= __xlen) {
      pointer __i = ::std::priv:: __copy_ptrs(const_cast<const_pointer>(__x._M_start) + 0,
                                           const_cast<const_pointer>(__x._M_finish) + 0, this->_M_start, _TrivialCopy());
      ::std::_Destroy_Range(__i, this->_M_finish);
    } else {
      ::std::priv:: __copy_ptrs(const_cast<const_pointer>(__x._M_start),
                             const_cast<const_pointer>(__x._M_start) + size(), this->_M_start, _TrivialCopy());
      ::std::priv:: __ucopy_ptrs(const_cast<const_pointer>(__x._M_start) + size(),
                              const_cast<const_pointer>(__x._M_finish) + 0, this->_M_finish, _TrivialUCopy());
    }
    this->_M_finish = this->_M_start + __xlen;
  }
  return *this;
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const _Tp& __val) {
  if (__n > capacity()) {
    vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());
    __tmp.swap(*this);
  } else if (__n > size()) {
    fill(begin(), end(), __val);
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_finish, __n - size(), __val);
  } else
    erase(::std::priv:: __fill_n(begin(), __n, __val), end());
}

template <class _Tp, class _Alloc>
typename vector<_Tp, _Alloc>::iterator
vector<_Tp, _Alloc>::insert(iterator __pos, const _Tp& __x) {
  size_type __n = __pos - begin();
  _M_fill_insert(__pos, 1, __x);
  return begin() + __n;
}






#line 235 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"

}

#line 239 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.c"




#line 727 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
#line 728 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"



#line 732 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"






#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"






































namespace std {
namespace priv {

struct _Bit_reference {
  unsigned int* _M_p;
  unsigned int _M_mask;
  _Bit_reference(unsigned int* __x, unsigned int __y)
    : _M_p(__x), _M_mask(__y) {}

public:
  _Bit_reference() : _M_p(0), _M_mask(0) {}

  operator bool() const {
    return !(!(*_M_p & _M_mask));
  }
  _Bit_reference& operator = (bool __x) {
    if (__x)  *_M_p |= _M_mask;
    else      *_M_p &= ~_M_mask;
    return *this;
  }
  _Bit_reference& operator = (const _Bit_reference& __x) {
    return *this = bool(__x);
  }
  bool operator == (const _Bit_reference& __x) const {
    return bool(*this) == bool(__x);
  }
  bool operator < (const _Bit_reference& __x) const {
    return !bool(*this) && bool(__x);
  }

  _Bit_reference& operator |= (bool __x) {
    if (__x)
      *_M_p |= _M_mask;
    return *this;
  }
  _Bit_reference& operator &= (bool __x) {
    if (!__x)
      *_M_p &= ~_M_mask;
    return *this;
  }
  void flip() { *_M_p ^= _M_mask; }
};


}

inline void swap(::std::priv:: _Bit_reference& __x, ::std::priv:: _Bit_reference& __y) {
  bool __tmp = (bool)__x;
  __x = __y;
  __y = __tmp;
}


template<>
struct __type_traits<::std::priv:: _Bit_reference> {
  typedef __false_type    has_trivial_default_constructor;
  typedef __true_type     has_trivial_copy_constructor;
  typedef __false_type    has_trivial_assignment_operator;
  typedef __true_type     has_trivial_destructor;
  typedef __false_type    is_POD_type;
};

namespace priv {

struct _Bit_iterator_base {
  typedef ptrdiff_t difference_type;

  unsigned int* _M_p;
  unsigned int  _M_offset;

  void _M_bump_up() {
    if (_M_offset++ == (int(8 * sizeof(unsigned int))) - 1) {
      _M_offset = 0;
      ++_M_p;
    }
  }

  void _M_bump_down() {
    if (_M_offset-- == 0) {
      _M_offset = (int(8 * sizeof(unsigned int))) - 1;
      --_M_p;
    }
  }

  _Bit_iterator_base() : _M_p(0), _M_offset(0) {}
  _Bit_iterator_base(unsigned int* __x, unsigned int __y) : _M_p(__x), _M_offset(__y) {}



#line 129 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"
  

  void _M_advance (difference_type __i) {
    difference_type __n = __i + _M_offset;
    _M_p += __n / (int(8 * sizeof(unsigned int)));
    __n = __n % (int(8 * sizeof(unsigned int)));
    if (__n < 0) {
      _M_offset = (unsigned int) __n + (int(8 * sizeof(unsigned int)));
      --_M_p;
    } else
      _M_offset = (unsigned int) __n;
  }

  difference_type _M_subtract(const _Bit_iterator_base& __x) const {
    return (int(8 * sizeof(unsigned int))) * (_M_p - __x._M_p) + _M_offset - __x._M_offset;
  }
};

inline bool  __cdecl operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __y._M_p == __x._M_p && __y._M_offset == __x._M_offset;
}
inline bool  __cdecl operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __y._M_p != __x._M_p || __y._M_offset != __x._M_offset;
}

inline bool __cdecl operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __x._M_p < __y._M_p || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
}

inline bool __cdecl operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)  {
  return operator <(__y , __x);
}
inline bool __cdecl operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return !(__y < __x);
}
inline bool __cdecl operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return !(__x < __y);
}

template <class _Ref, class _Ptr>
struct _Bit_iter : public _Bit_iterator_base {
  typedef _Ref  reference;
  typedef _Ptr  pointer;
  typedef _Bit_iter<_Ref, _Ptr> _Self;
  typedef random_access_iterator_tag iterator_category;
  typedef bool value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  _Bit_iter(unsigned int* __x, unsigned int __y) : _Bit_iterator_base(__x, __y) {}
  _Bit_iter() {}

  _Bit_iter(const _Bit_iter<_Bit_reference, _Bit_reference*>& __x):
    _Bit_iterator_base((const _Bit_iterator_base&)__x) {}

  
  

  reference operator*() const {
    return _Bit_reference(_M_p, 1UL << _M_offset);
  }
  _Self& operator++() {
    _M_bump_up();
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    _M_bump_up();
    return __tmp;
  }
  _Self& operator--() {
    _M_bump_down();
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    _M_bump_down();
    return __tmp;
  }
  _Self& operator+=(difference_type __i) {
    _M_advance(__i);
    return *this;
  }
  _Self& operator-=(difference_type __i) {
    *this += -__i;
    return *this;
  }
  _Self operator+(difference_type __i) const {
    _Self __tmp = *this;
    return __tmp += __i;
  }
  _Self operator-(difference_type __i) const {
    _Self __tmp = *this;
    return __tmp -= __i;
  }
  difference_type operator-(const _Self& __x) const {
    return _M_subtract(__x);
  }
  reference operator[](difference_type __i) { return *(*this + __i); }
};

template <class _Ref, class _Ptr>
inline _Bit_iter<_Ref,_Ptr>  __cdecl
operator+(ptrdiff_t __n, const _Bit_iter<_Ref, _Ptr>& __x) {
   return __x + __n;
}

}


template <class _Ref, class _Ptr>
struct __type_traits< ::std::priv:: _Bit_iter<_Ref, _Ptr> > {
  typedef __false_type   has_trivial_default_constructor;
  typedef __true_type    has_trivial_copy_constructor;
  typedef __true_type    has_trivial_assignment_operator;
  typedef __true_type    has_trivial_destructor;
  typedef __false_type   is_POD_type;
};
#line 248 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"










#line 259 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

namespace priv {

typedef _Bit_iter<bool, const bool*> _Bit_const_iterator;
typedef _Bit_iter<_Bit_reference, _Bit_reference*> _Bit_iterator;



template <class _Alloc>
class _Bvector_base {
  typedef _Bvector_base<_Alloc> _Self;
public:
  
  typedef _Alloc allocator_type;
  typedef unsigned int __chunk_type;
  typedef typename _Alloc_traits<__chunk_type, _Alloc>::allocator_type __chunk_allocator_type;
  allocator_type get_allocator() const
  { return static_cast<const __chunk_allocator_type&>(_M_end_of_storage); }

  _Bvector_base(const allocator_type& __a)
    : _M_start(), _M_finish(), _M_end_of_storage(__a,
                                                 (__chunk_type*)0)
  {}

  _Bvector_base(__move_source<_Self> src)
    : _M_start(src.get()._M_start), _M_finish(src.get()._M_finish),
      _M_end_of_storage(src.get()._M_end_of_storage) {
    
    src.get()._M_start._M_p = 0;
  }
#line 290 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

  ~_Bvector_base() {
    _M_deallocate();
  }

protected:

  static size_t _M_bits_to_chunks(size_t __n_bits)
  { return (__n_bits + (int(8 * sizeof(unsigned int))) - 1) / (int(8 * sizeof(unsigned int))); }

  __chunk_type* _M_bit_alloc(size_t __n)
  { return _M_end_of_storage.allocate(_M_bits_to_chunks(__n)); }

  void _M_deallocate() {
    if (_M_start._M_p)
      _M_end_of_storage.deallocate(_M_start._M_p,
                                   _M_end_of_storage._M_data - _M_start._M_p);
  }

  _Bit_iterator _M_start;
  _Bit_iterator _M_finish;
  _STLP_alloc_proxy<__chunk_type*, __chunk_type, __chunk_allocator_type> _M_end_of_storage;
};


















#line 332 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"



#line 336 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"









#line 346 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"


#line 349 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

#line 351 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"
#line 352 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"


}
#line 356 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

template <class _Alloc>
class vector<bool, _Alloc> : public ::std::priv:: _Bvector_base<_Alloc >


#line 362 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"
{
  typedef ::std::priv:: _Bvector_base<_Alloc > _Base;
  typedef vector<bool, _Alloc> _Self;
public:
  typedef bool value_type;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef ::std::priv:: _Bit_reference reference;
  typedef bool const_reference;
  typedef ::std::priv:: _Bit_reference* pointer;
  typedef const bool* const_pointer;
  typedef random_access_iterator_tag _Iterator_category;

  typedef ::std::priv:: _Bit_iterator          iterator;
  typedef ::std::priv:: _Bit_const_iterator    const_iterator;

  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;


  typedef typename ::std::priv:: _Bvector_base<_Alloc >::allocator_type allocator_type;
  typedef typename ::std::priv:: _Bvector_base<_Alloc >::__chunk_type __chunk_type;



#line 387 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

protected:

  void _M_initialize(size_type __n) {
    __chunk_type* __q = this->_M_bit_alloc(__n);
    this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__n);
    this->_M_start = iterator(__q, 0);
    this->_M_finish = this->_M_start + difference_type(__n);
  }
  void _M_insert_aux(iterator __position, bool __x) {
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
      ::std::priv:: __copy_backward(__position, this->_M_finish, this->_M_finish + 1,
                                 random_access_iterator_tag(), (difference_type*)0 );
      *__position = __x;
      ++this->_M_finish;
    }
    else {
      size_type __len = size() ? 2 * size() : (int(8 * sizeof(unsigned int)));
      __chunk_type* __q = this->_M_bit_alloc(__len);
      iterator __i = ::std::copy(begin(), __position, iterator(__q, 0));
      *__i++ = __x;
      this->_M_finish = ::std::copy(__position, end(), __i);
      this->_M_deallocate();
      this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__len);
      this->_M_start = iterator(__q, 0);
    }
  }


  template <class _InputIterator>
  void _M_initialize_range(_InputIterator __first, _InputIterator __last,
                           const input_iterator_tag &) {
    this->_M_start = iterator();
    this->_M_finish = iterator();
    this->_M_end_of_storage._M_data = 0;
    for ( ; __first != __last; ++__first)
      push_back(*__first);
  }

  template <class _ForwardIterator>
  void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                           const forward_iterator_tag &) {
    size_type __n = ::std::distance(__first, __last);
    _M_initialize(__n);
    ::std::copy(__first, __last, this->_M_start);
  }

  template <class _InputIterator>
  void _M_insert_range(iterator __pos,
                       _InputIterator __first, _InputIterator __last,
                       const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __pos = insert(__pos, *__first);
      ++__pos;
    }
  }

  template <class _ForwardIterator>
  void _M_insert_range(iterator __position,
                       _ForwardIterator __first, _ForwardIterator __last,
                       const forward_iterator_tag &) {
    if (__first != __last) {
      size_type __n = ::std::distance(__first, __last);
      if (capacity() - size() >= __n) {
        ::std::priv:: __copy_backward(__position, end(), this->_M_finish + difference_type(__n),
                                   random_access_iterator_tag(), (difference_type*)0 );
        ::std::copy(__first, __last, __position);
        this->_M_finish += difference_type(__n);
      }
      else {
        size_type __len = size() + (max)(size(), __n);
        __chunk_type* __q = this->_M_bit_alloc(__len);
        iterator __i = ::std::copy(begin(), __position, iterator(__q, 0));
        __i = ::std::copy(__first, __last, __i);
        this->_M_finish = ::std::copy(__position, end(), __i);
        this->_M_deallocate();
        this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__len);
        this->_M_start = iterator(__q, 0);
      }
    }
  }

#line 470 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

public:
  iterator begin() { return this->_M_start; }
  const_iterator begin() const { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }

  size_type size() const { return size_type(end() - begin()); }
  size_type max_size() const { return size_type(-1); }
  size_type capacity() const {
    return size_type(const_iterator(this->_M_end_of_storage._M_data, 0) - begin());
  }
  bool empty() const { return begin() == end(); }
  reference operator[](size_type __n)
  { return *(begin() + difference_type(__n)); }
  const_reference operator[](size_type __n) const
  { return *(begin() + difference_type(__n)); }

  void _M_range_check(size_type __n) const {
    if (__n >= this->size())
      __stl_throw_range_error("vector<bool>");
  }

  reference at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }
  const_reference at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

  explicit vector(const allocator_type& __a = allocator_type())
    : ::std::priv:: _Bvector_base<_Alloc >(__a) {}

  vector(size_type __n, bool __val,
            const allocator_type& __a = allocator_type())
    : ::std::priv:: _Bvector_base<_Alloc >(__a) {
    _M_initialize(__n);
    fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __val ? ~0 : 0);
  }

  explicit vector(size_type __n)
    : ::std::priv:: _Bvector_base<_Alloc >(allocator_type()) {
    _M_initialize(__n);
    fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), 0);
  }

  vector(const _Self& __x)
    : ::std::priv:: _Bvector_base<_Alloc >(__x.get_allocator()) {
    _M_initialize(__x.size());
    ::std::copy(__x.begin(), __x.end(), this->_M_start);
  }


  template <class _Integer>
  void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    _M_initialize(__n);
    fill(this->_M_start._M_p, this->_M_end_of_storage._M_data, __x ? ~0 : 0);
  }

  template <class _InputIterator>
  void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                              const __false_type&) {
    _M_initialize_range(__first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category());
  }








#line 550 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
            const allocator_type& __a = allocator_type())
    : ::std::priv:: _Bvector_base<_Alloc >(__a) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_initialize_dispatch(__first, __last, _Integral());
  }















#line 573 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"


  vector(__move_source<_Self> src)
    : ::std::priv:: _Bvector_base<_Alloc >(__move_source<_Base>(src.get())) {}
#line 578 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

  ~vector() {}

  vector<bool, _Alloc>& operator=(const vector<bool, _Alloc>& __x) {
    if (&__x == this) return *this;
    if (__x.size() > capacity()) {
      this->_M_deallocate();
      _M_initialize(__x.size());
    }
    ::std::copy(__x.begin(), __x.end(), begin());
    this->_M_finish = begin() + difference_type(__x.size());
    return *this;
  }

  
  
  
  

  void _M_fill_assign(size_t __n, bool __x) {
    if (__n > size()) {
      fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
      insert(end(), __n - size(), __x);
    }
    else {
      erase(begin() + __n, end());
      fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
    }
  }
  void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }


  template <class _InputIterator>
  void assign(_InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_assign_dispatch(__first, __last, _Integral());
  }

  template <class _Integer>
  void _M_assign_dispatch(_Integer __n, _Integer __val, const __true_type&)
    { _M_fill_assign((size_t) __n, (bool) __val); }

  template <class _InputIter>
  void _M_assign_dispatch(_InputIter __first, _InputIter __last, const __false_type&)
    { _M_assign_aux(__first, __last, typename ::std::iterator_traits< _InputIter >::iterator_category()); }

  template <class _InputIterator>
  void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                     const input_iterator_tag &) {
    iterator __cur = begin();
    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
      *__cur = *__first;
    if (__first == __last)
      erase(__cur, end());
    else
      insert(end(), __first, __last);
  }

  template <class _ForwardIterator>
  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                     const forward_iterator_tag &) {
    size_type __len = ::std::distance(__first, __last);
    if (__len < size())
      erase(::std::copy(__first, __last, begin()), end());
    else {
      _ForwardIterator __mid = __first;
      ::std::advance(__mid, size());
      ::std::copy(__first, __mid, begin());
      insert(end(), __mid, __last);
    }
  }
#line 650 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

  void reserve(size_type __n) {
    if (capacity() < __n) {
      if (max_size() < __n)
        __stl_throw_length_error("vector<bool>");
      __chunk_type* __q = this->_M_bit_alloc(__n);
      ::std::priv:: _Bit_iterator __z(__q, 0);
      this->_M_finish = ::std::copy(begin(), end(), __z);
      this->_M_deallocate();
      this->_M_start = iterator(__q, 0);
      this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__n);
    }
  }

  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }
  void push_back(bool __x) {
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
      *(this->_M_finish) = __x;
      ++this->_M_finish;
    }
    else
      _M_insert_aux(end(), __x);
  }
  void swap(vector<bool, _Alloc>& __x) {
    ::std::swap(this->_M_start, __x._M_start);
    ::std::swap(this->_M_finish, __x._M_finish);
    this->_M_end_of_storage.swap(__x._M_end_of_storage);
  }


#line 684 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

  iterator insert(iterator __position, bool __x = bool()) {
    difference_type __n = __position - begin();
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data && __position == end()) {
      *(this->_M_finish) = __x;
      ++this->_M_finish;
    }
    else
      _M_insert_aux(__position, __x);
    return begin() + __n;
  }



  template <class _Integer>
  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                          const __true_type&) {
    _M_fill_insert(__pos, (size_type) __n, (bool) __x);
  }

  template <class _InputIterator>
  void _M_insert_dispatch(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          const __false_type&) {
    _M_insert_range(__pos, __first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category());
  }

  
  template <class _InputIterator>
  void insert(iterator __position,
              _InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_insert_dispatch(__position, __first, __last, _Integral());
  }











































#line 762 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

  void _M_fill_insert(iterator __position, size_type __n, bool __x) {
    if (__n == 0) return;
    if (capacity() - size() >= __n) {
      ::std::priv:: __copy_backward(__position, end(), this->_M_finish + difference_type(__n),
                                 random_access_iterator_tag(), (difference_type*)0 );
      fill(__position, __position + difference_type(__n), __x);
      this->_M_finish += difference_type(__n);
    }
    else {
      size_type __len = size() + (max)(size(), __n);
      __chunk_type* __q = this->_M_bit_alloc(__len);
      iterator __i = ::std::copy(begin(), __position, iterator(__q, 0));
      fill_n(__i, __n, __x);
      this->_M_finish = ::std::copy(__position, end(), __i + difference_type(__n));
      this->_M_deallocate();
      this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__len);
      this->_M_start = iterator(__q, 0);
    }
  }

  void insert(iterator __position, size_type __n, bool __x) {
    _M_fill_insert(__position, __n, __x);
  }

  void pop_back() {
    --this->_M_finish;
  }
  iterator erase(iterator __position) {
    if (__position + 1 != end())
      ::std::copy(__position + 1, end(), __position);
      --this->_M_finish;
    return __position;
  }
  iterator erase(iterator __first, iterator __last) {
    this->_M_finish = ::std::copy(__last, end(), __first);
    return __first;
  }
  void resize(size_type __new_size, bool __x = bool()) {
    if (__new_size < size())
      erase(begin() + difference_type(__new_size), end());
    else
      insert(end(), __new_size - size(), __x);
  }
  void flip() {
    for (__chunk_type* __p = this->_M_start._M_p; __p != this->_M_end_of_storage._M_data; ++__p)
      *__p = ~*__p;
  }

  void clear() { erase(begin(), end()); }
};







#line 821 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"



#line 825 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"

}










#line 838 "C:\\Pin35\\extras\\stlport\\include\\stl/_bvector.h"




#line 739 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
#line 740 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"
#line 741 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"



#line 745 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

namespace std {



typedef vector<bool, allocator<bool> > bit_vector;
#line 752 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"





template <class _Tp, class _Alloc>
inline bool __cdecl operator==(const vector<_Tp, _Alloc>& __x,
                                  const vector<_Tp, _Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}
#line 13 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"

template <class _Tp, class _Alloc>
inline bool __cdecl operator<(const vector<_Tp, _Alloc>& __x,
                                 const vector<_Tp, _Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Tp, class _Alloc> inline bool __cdecl operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return !(__x == __y);}template <class _Tp, class _Alloc> inline bool __cdecl operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return __y < __x;}template <class _Tp, class _Alloc> inline bool __cdecl operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__y < __x);}template <class _Tp, class _Alloc> inline bool __cdecl operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__x < __y);}


template <class _Tp, class _Alloc>
inline void __cdecl swap(vector<_Tp, _Alloc>& __x,
                            vector<_Tp, _Alloc>& __y) {
  __x.swap(__y);
}
#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/_relops_cont.h"
#line 756 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"





template <class _Tp, class _Alloc>
struct __move_traits<vector<_Tp, _Alloc> > {
  typedef __true_type implemented;
  typedef typename __move_traits<_Alloc>::complete complete;
};
#line 767 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"


template <class _Tp, class _Alloc>
struct _DefaultZeroValue<vector<_Tp, _Alloc> >
{ typedef typename __type_traits<_Alloc>::has_trivial_default_constructor _Ret; };
#line 773 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

#line 775 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"

}

#line 779 "C:\\Pin35\\extras\\stlport\\include\\stl/_vector.h"




#line 38 "C:\\Pin35\\extras\\stlport\\include\\vector"
#line 39 "C:\\Pin35\\extras\\stlport\\include\\vector"
#line 40 "C:\\Pin35\\extras\\stlport\\include\\vector"







#line 48 "C:\\Pin35\\extras\\stlport\\include\\vector"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 51 "C:\\Pin35\\extras\\stlport\\include\\vector"

#line 53 "C:\\Pin35\\extras\\stlport\\include\\vector"

#line 55 "C:\\Pin35\\extras\\stlport\\include\\vector"





#line 48 "c:\\pin35\\source\\include\\pin\\level_vmapi.PLH"

namespace LEVEL_VM
{

using namespace LEVEL_CORE;

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\types_vmapi.TLH"














































const ADDRINT DEFAULT_CONTEXT_IMPL = 0;




const ADDRINT SPILL_AREA_CONTEXT_IMPL = 1;




 struct CONTEXT
{
    


    CONTEXT() : _impl(DEFAULT_CONTEXT_IMPL)
    {
        memset(_state, 0, sizeof(CHAR) * ARCH_STATE_SIZE);
    }

    ADDRINT _impl;                              
    CHAR    _state[ARCH_STATE_SIZE];            
};




 struct PHYSICAL_CONTEXT
{
   


    PHYSICAL_CONTEXT(CONTEXT * pCtxt) : _pCtxt(pCtxt) {}

    CONTEXT * _pCtxt;                         
};

#line 85 "C:\\Pin35\\source\\include\\pin\\gen\\types_vmapi.TLH"





 enum PROCESSOR_STATE
{
    PROCESSOR_STATE_X87,    
    PROCESSOR_STATE_XMM,    
    PROCESSOR_STATE_YMM,    
    PROCESSOR_STATE_ZMM     
};







 typedef struct CONTEXT CONTEXT;







 typedef struct PHYSICAL_CONTEXT PHYSICAL_CONTEXT;






 typedef enum
{
    IPOINT_INVALID,
    IPOINT_BEFORE, 
    IPOINT_AFTER,  
    IPOINT_ANYWHERE, 
    IPOINT_TAKEN_BRANCH 

} IPOINT;




 enum CONTEXT_CHANGE_REASON
{
    CONTEXT_CHANGE_REASON_FATALSIGNAL,  
    CONTEXT_CHANGE_REASON_SIGNAL,       
    CONTEXT_CHANGE_REASON_SIGRETURN,    
    CONTEXT_CHANGE_REASON_APC,          
    CONTEXT_CHANGE_REASON_EXCEPTION,    
    CONTEXT_CHANGE_REASON_CALLBACK      
};




enum EXCEPT_HANDLING_RESULT
{
    EHR_HANDLED,                

    EHR_UNHANDLED,              
                                

    EHR_CONTINUE_SEARCH         
                                
};

















 enum CALL_ORDER
{
    CALL_ORDER_FIRST = 100,              
    CALL_ORDER_DEFAULT = 200,            
    CALL_ORDER_LAST = 300                
};






 typedef enum
{
    IARG_INVALID,
    IARG_ADDRINT, 
    IARG_PTR, 
    IARG_BOOL, 
    IARG_UINT32, 
    IARG_UINT64, 

    



    IARG_INST_PTR,

    





    IARG_REG_VALUE,

    



    IARG_REG_REFERENCE,

    



    IARG_REG_CONST_REFERENCE,

    IARG_MEMORYREAD_EA, 
    IARG_MEMORYREAD2_EA, 
    IARG_MEMORYWRITE_EA,
    








    IARG_MEMORYREAD_SIZE,
    














    IARG_MEMORYWRITE_SIZE,

    
    IARG_MEMORYREAD_PTR, 
    IARG_MEMORYREAD2_PTR, 
    IARG_MEMORYWRITE_PTR,
    IARG_MEMORYOP_PTR,  

    IARG_MULTI_MEMORYACCESS_EA,

    IARG_EXPLICIT_MEMORY_EA, 

    IARG_BRANCH_TAKEN, 
    IARG_BRANCH_TARGET_ADDR, 
    IARG_FALLTHROUGH_ADDR,  
    IARG_EXECUTING, 
    IARG_FIRST_REP_ITERATION, 
    IARG_PREDICATE, 

    
    IARG_STACK_VALUE, 
    IARG_STACK_REFERENCE, 
    IARG_MEMORY_VALUE,      
    IARG_MEMORY_REFERENCE,  


    
    IARG_SYSCALL_NUMBER, 
    IARG_SYSARG_REFERENCE, 

    IARG_SYSARG_VALUE, 
    IARG_SYSRET_VALUE, 
    IARG_SYSRET_ERRNO, 

    
    


    IARG_FUNCARG_CALLSITE_REFERENCE,
    


    IARG_FUNCARG_CALLSITE_VALUE,
    


    IARG_FUNCARG_ENTRYPOINT_REFERENCE,
    


    IARG_FUNCARG_ENTRYPOINT_VALUE,
    IARG_FUNCRET_EXITPOINT_REFERENCE, 
    IARG_FUNCRET_EXITPOINT_VALUE, 

    IARG_RETURN_IP,     

    IARG_ORIG_FUNCPTR, 

    IARG_PROTOTYPE, 

    IARG_THREAD_ID, 

    






    IARG_CONTEXT,
    













    IARG_CONST_CONTEXT,
    




















    IARG_PARTIAL_CONTEXT,

     














    IARG_PRESERVE,


    IARG_RETURN_REGS,  

    IARG_CALL_ORDER,   

    IARG_IARGLIST, 

    IARG_FAST_ANALYSIS_CALL, 

    IARG_MEMORYOP_EA,  
    IARG_MEMORYOP_MASKED_ON,
    IARG_TSC,          
    IARG_FILE_NAME,    
    IARG_LINE_NO,      
    IARG_LAST          

} IARG_TYPE;











#line 401 "C:\\Pin35\\source\\include\\pin\\gen\\types_vmapi.TLH"






 typedef enum
{
    PROBE_INVALID,                  
    PROBE_REDIRECT,                 
                                    
    PROBE_REDIRECT_TO_ORIGINAL,     
                                    
    PROBE_SINGLE_THREAD,            
    PROBE_MULTI_THREAD,             
    PROBE_FUNCTION_WRAPPER,         
    PROBE_NO_WRAPPER,               
    PROBE_RELOCATE                  
} PROBE_TYPE;

static const UINT32 MAX_BYTES_PER_PIN_REG = 64;
static const UINT32 MAX_WORDS_PER_PIN_REG = (MAX_BYTES_PER_PIN_REG/2);
static const UINT32 MAX_DWORDS_PER_PIN_REG = (MAX_WORDS_PER_PIN_REG/2);
static const UINT32 MAX_QWORDS_PER_PIN_REG = (MAX_DWORDS_PER_PIN_REG/2);
static const UINT32 MAX_FLOATS_PER_PIN_REG = (MAX_BYTES_PER_PIN_REG/sizeof(float));
static const UINT32 MAX_DOUBLES_PER_PIN_REG = (MAX_BYTES_PER_PIN_REG/sizeof(double));






union PIN_REGISTER
{
    UINT8  byte[MAX_BYTES_PER_PIN_REG];
    UINT16 word[MAX_WORDS_PER_PIN_REG];
    UINT32 dword[MAX_DWORDS_PER_PIN_REG];
    UINT64 qword[MAX_QWORDS_PER_PIN_REG];

    INT8   s_byte[MAX_BYTES_PER_PIN_REG];
    INT16  s_word[MAX_WORDS_PER_PIN_REG];
    INT32  s_dword[MAX_DWORDS_PER_PIN_REG];
    INT64  s_qword[MAX_QWORDS_PER_PIN_REG];

    FLT32  flt[MAX_FLOATS_PER_PIN_REG];
    FLT64  dbl[MAX_DOUBLES_PER_PIN_REG];
};








 typedef enum
{
    CALLINGSTD_INVALID,
    CALLINGSTD_DEFAULT,
    CALLINGSTD_CDECL,
    CALLINGSTD_REGPARMS,
    CALLINGSTD_STDCALL,
    CALLINGSTD_ART
} CALLINGSTD_TYPE;







 typedef enum
{
    PARG_INVALID,
    PARG_POINTER,
    PARG_BOOL,
    PARG_CHAR,
    PARG_UCHAR,
    PARG_SCHAR,
    PARG_SHORT,
    PARG_USHORT,
    PARG_INT,
    PARG_UINT,
    PARG_LONG,
    PARG_ULONG,
    PARG_LONGLONG,
    PARG_ULONGLONG,
    PARG_FLOAT,
    PARG_DOUBLE,
    PARG_VOID,
    PARG_ENUM,
    PARG_AGGREGATE,
    PARG_END
} PARG_TYPE;

struct PARG_T
{
    PARG_TYPE _parg;
    size_t _size;
};

































template<typename T> struct _PinPargClass           {static PARG_T parg() {PARG_T x; x._parg = PARG_INVALID; x._size = 0; return x;}};
template<typename T> struct _PinPargClass<T*>       {static PARG_T parg() {PARG_T x; x._parg = PARG_POINTER; x._size = sizeof(T*); return x;}};
template<typename T> struct _PinPargClass<T&>       {static PARG_T parg() {PARG_T x; x._parg = PARG_POINTER; x._size = sizeof(T&); return x;}};
template<> struct _PinPargClass<bool>               {static PARG_T parg() {PARG_T x; x._parg = PARG_BOOL; x._size = sizeof(bool); return x;}};
template<> struct _PinPargClass<char>               {static PARG_T parg() {PARG_T x; x._parg = PARG_CHAR; x._size = sizeof(char); return x;}};
template<> struct _PinPargClass<unsigned char>      {static PARG_T parg() {PARG_T x; x._parg = PARG_UCHAR; x._size = sizeof(unsigned char); return x;}};
template<> struct _PinPargClass<signed char>        {static PARG_T parg() {PARG_T x; x._parg = PARG_SCHAR; x._size = sizeof(signed char); return x;}};
template<> struct _PinPargClass<short>              {static PARG_T parg() {PARG_T x; x._parg = PARG_SHORT; x._size = sizeof(short); return x;}};
template<> struct _PinPargClass<unsigned short>     {static PARG_T parg() {PARG_T x; x._parg = PARG_USHORT; x._size = sizeof(unsigned short); return x;}};
template<> struct _PinPargClass<int>                {static PARG_T parg() {PARG_T x; x._parg = PARG_INT; x._size = sizeof(int); return x;}};
template<> struct _PinPargClass<unsigned int>       {static PARG_T parg() {PARG_T x; x._parg = PARG_UINT; x._size = sizeof(unsigned int); return x;}};
template<> struct _PinPargClass<long>               {static PARG_T parg() {PARG_T x; x._parg = PARG_LONG; x._size = sizeof(long); return x;}};
template<> struct _PinPargClass<unsigned long>      {static PARG_T parg() {PARG_T x; x._parg = PARG_ULONG; x._size = sizeof(unsigned long); return x;}};
template<> struct _PinPargClass<long long>          {static PARG_T parg() {PARG_T x; x._parg = PARG_LONGLONG; x._size = sizeof(long long); return x;}};
template<> struct _PinPargClass<unsigned long long> {static PARG_T parg() {PARG_T x; x._parg = PARG_ULONGLONG; x._size = sizeof(unsigned long long); return x;}};
template<> struct _PinPargClass<float>              {static PARG_T parg() {PARG_T x; x._parg = PARG_FLOAT; x._size = sizeof(float); return x;}};
template<> struct _PinPargClass<double>             {static PARG_T parg() {PARG_T x; x._parg = PARG_DOUBLE; x._size = sizeof(double); return x;}};
template<> struct _PinPargClass<void>             {static PARG_T parg() {PARG_T x; x._parg = PARG_VOID; x._size = 0; return x;}};


static inline PARG_T _PinParg(PARG_TYPE p, size_t s) {PARG_T x; x._parg = p; x._size = s; return x;}




class IARGLIST_CLASS;
class PROTO_CLASS;




struct PIN_CODE_RANGE {
  ADDRINT start_address;
  size_t size;
};






 typedef IARGLIST_CLASS * IARGLIST;

























#line 602 "C:\\Pin35\\source\\include\\pin\\gen\\types_vmapi.TLH"

#line 604 "C:\\Pin35\\source\\include\\pin\\gen\\types_vmapi.TLH"



#line 608 "C:\\Pin35\\source\\include\\pin\\gen\\types_vmapi.TLH"





 typedef enum
{
    PIN_MEMOP_LOAD,
    PIN_MEMOP_STORE
} PIN_MEMOP_ENUM;





 typedef struct
{
    ADDRINT        memoryAddress;
    PIN_MEMOP_ENUM memopType;
    UINT32         bytesAccessed;
    BOOL           maskOn;
} PIN_MEM_ACCESS_INFO;





const int MAX_MULTI_MEMOPS = 16;





 typedef struct
{
    UINT32              numberOfMemops; 
                                        
    PIN_MEM_ACCESS_INFO memop[MAX_MULTI_MEMOPS];
} PIN_MULTI_MEM_ACCESS_INFO;







 typedef PROTO_CLASS * PROTO;





 typedef UINT32 BUFFER_ID;





const BUFFER_ID BUFFER_ID_INVALID = 0;




 typedef UINT32 THREADID;




const THREADID INVALID_THREADID = static_cast<THREADID>(-1);






 typedef UINT64 PIN_THREAD_UID;




const PIN_THREAD_UID INVALID_PIN_THREAD_UID = static_cast<PIN_THREAD_UID>(-1);




 typedef NATIVE_TID OS_THREAD_ID;




const OS_THREAD_ID INVALID_OS_THREAD_ID = ((NATIVE_TID)0);






 typedef VOID ROOT_THREAD_FUNC(VOID * arg);




const size_t DEFAULT_THREAD_STACK_SIZE = 256*sizeof(ADDRINT)*1024;




 typedef UINT32 OS_PROCESS_ID;




 enum DEBUG_STATUS
{
    DEBUG_STATUS_DISABLED,      
    DEBUG_STATUS_UNCONNECTABLE, 
    DEBUG_STATUS_UNCONNECTED,   
    DEBUG_STATUS_CONNECTED      
};





 enum DEBUG_CONNECTION_TYPE
{
    DEBUG_CONNECTION_TYPE_NONE,         
    DEBUG_CONNECTION_TYPE_TCP_SERVER,   
    DEBUG_CONNECTION_TYPE_TCP_CLIENT    
};




 enum DEBUGGER_TYPE
{
    DEBUGGER_TYPE_UNKNOWN,              
    DEBUGGER_TYPE_GDB,                  
    DEBUGGER_TYPE_IDB,                  
    DEBUGGER_TYPE_VISUAL_STUDIO_VSDBG,  
    DEBUGGER_TYPE_VISUAL_STUDIO         
};




 enum DEBUG_MODE_OPTION
{
    DEBUG_MODE_OPTION_NONE = 0,     

    





    DEBUG_MODE_OPTION_STOP_AT_ENTRY = (1<<0),

    




    DEBUG_MODE_OPTION_SILENT = (1<<1),

    




    DEBUG_MODE_OPTION_ALLOW_REMOTE = (1<<2)
};
 typedef UINT64 DEBUG_MODE_OPTIONS; 




struct _tcpServerStruct
{
    int _tcpPort;   
};




 struct DEBUG_CONNECTION_INFO
{
    DEBUG_CONNECTION_TYPE _type;    
    BOOL _stopAtEntry;              

    
    
    union
    {
        struct _tcpServerStruct _tcpServer;
    };
};




struct _tcpClientStruct
{
    const char *_ip;    
    int _tcpPort;       
};




 struct DEBUG_MODE
{
    DEBUG_CONNECTION_TYPE _type;    
    DEBUG_MODE_OPTIONS _options;    

    
    
    union
    {
        


        struct _tcpClientStruct _tcpClient;
    };
};




enum DEBUGGING_EVENT
{
    



    DEBUGGING_EVENT_BREAKPOINT,

    DEBUGGING_EVENT_SINGLE_STEP,    

    



    DEBUGGING_EVENT_ASYNC_BREAK
};





struct DEBUGGER_REG_DESCRIPTION
{
    REG _pinReg;            
                            
    unsigned _toolRegId;    
    unsigned _widthInBits;  
                            
    const char* _name;      
    int _gccId;             
};






 typedef union
{
    UINT32 data;
    struct
    {
        UINT32 isAtomic:1;
        UINT32 isRmw:1;
        UINT32 isPrefetch:1;
        UINT32 isFromPin:1;
    } bits;
} PIN_MEM_TRANS_FLAGS;

 typedef struct
{
    
    
    
    UINT8 dummySpace[32];
    THREADID threadIndex;
    ADDRINT addr;
    size_t bytes;
    PIN_MEMOP_ENUM memOpType;
    ADDRINT ip;
    PIN_MEM_TRANS_FLAGS flags;
} PIN_MEM_TRANS_INFO;




 typedef struct
{
    UINT32 native:1;   
} CALL_APPLICATION_FUNCTION_PARAM;





 enum PIN_CALLBACK_TYPE
{
    PIN_CALLBACK_TYPE_NONE    = 0, 
    PIN_CALLBACK_TYPE_SYSCALL = 1 
};

#line 919 "C:\\Pin35\\source\\include\\pin\\gen\\types_vmapi.TLH"

#line 55 "c:\\pin35\\source\\include\\pin\\level_vmapi.PLH"

}

#line 59 "c:\\pin35\\source\\include\\pin\\level_vmapi.PLH"
#line 46 "C:\\Pin35\\source\\include\\pin\\pin.H"
#line 1 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"











































#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"


#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdarg.h"















































#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 38 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 42 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"



#line 46 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 48 "C:\\Pin35\\extras\\stlport\\include\\stdarg.h"
#line 45 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\vector"



























































#line 46 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"

namespace LEVEL_PINCLIENT
{


using namespace LEVEL_VM;

#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\pin_client.PH"

















#line 19 "C:\\Pin35\\source\\include\\pin\\gen\\pin_client.PH"
class TRACE_CLASS;

                                                                  
typedef TRACE_CLASS * TRACE;

                                                                  
typedef VOID * PIN_CONFIGURATION_INFO;

                                                                  
class COMPLEX_CALLBACKVAL_BASE;

                                                                  
typedef COMPLEX_CALLBACKVAL_BASE * PIN_CALLBACK;

                                                                  
const PIN_CALLBACK PIN_CALLBACK_INVALID(0);

                                                                  
typedef VOID (*REMOVE_INSTRUMENTATION_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*DETACH_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*DETACH_PROBED_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*ATTACH_PROBED_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*ATTACH_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*APPLICATION_START_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*PREPARE_FOR_FINI_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*FINI_CALLBACK)(INT32 code, VOID *v);

                                                                  
typedef size_t (*FETCH_CALLBACK)(void *buf, ADDRINT addr, size_t size,
    EXCEPTION_INFO *pExceptInfo, VOID *v);

                                                                  
typedef VOID (*OUT_OF_MEMORY_CALLBACK)(size_t size, VOID *v);

                                                                  
typedef ADDRINT (__fastcall * MEMORY_ADDR_TRANS_CALLBACK)(PIN_MEM_TRANS_INFO* memTransInfo, VOID *v);

                                                                  
typedef VOID (*SMC_CALLBACK)(ADDRINT traceStartAddress, ADDRINT traceEndAddress, VOID *v);

                                                                  
typedef VOID (*FORK_CALLBACK)(THREADID threadid, const CONTEXT *ctxt, VOID *v);

                                                                  
typedef VOID (*THREAD_START_CALLBACK)(THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v);

                                                                  
typedef VOID (*THREAD_ATTACH_PROBED_CALLBACK)(VOID *sigmask, VOID *v);

                                                                  
typedef VOID (*THREAD_DETACH_PROBED_CALLBACK)(VOID *v);

                                                                  
typedef VOID (*THREAD_ATTACH_CALLBACK)(THREADID threadIndex, CONTEXT *ctxt, VOID *v);

                                                                  
typedef VOID (*THREAD_DETACH_CALLBACK)(THREADID threadIndex, const CONTEXT *ctxt, VOID *v);

                                                                  
typedef VOID (*THREAD_FINI_CALLBACK)(THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v);

                                                                  
typedef VOID (*CONTEXT_CHANGE_CALLBACK)(THREADID threadIndex, CONTEXT_CHANGE_REASON reason,
                                                   const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v);

                                                                  
typedef VOID (*SYSCALL_ENTRY_CALLBACK)(THREADID threadIndex, CONTEXT *ctxt,
                                                  SYSCALL_STANDARD std, VOID *v);

                                                                  
typedef VOID (*SYSCALL_EXIT_CALLBACK)(THREADID threadIndex, CONTEXT *ctxt,
                                                 SYSCALL_STANDARD std, VOID *v);

                                                                  
typedef BOOL (*INTERCEPT_SIGNAL_CALLBACK)(THREADID tid, INT32 sig, CONTEXT *ctxt,
    BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v);

                                                                  
typedef VOID (*PROBES_INSERTED_CALLBACK)(IMG img, VOID *v);

                                                                  
typedef VOID * (*TRACE_BUFFER_CALLBACK)(BUFFER_ID id, THREADID tid, const CONTEXT *ctxt,
                           VOID *buf, UINT64 numElements, VOID *v);

                                                                  
typedef VOID (*INS_INSTRUMENT_CALLBACK)(INS ins, VOID *v);

                                                                  
typedef VOID (*TRACE_INSTRUMENT_CALLBACK)(TRACE trace, VOID *v);

                                                                  
typedef VOID (*RTN_INSTRUMENT_CALLBACK)(RTN rtn, VOID *v);

                                                                  
enum REPLAY_MODE
{
    REPLAY_MODE_NONE            = 0x00,
    REPLAY_MODE_IMAGEOPS        = 0x01,   
    REPLAY_MODE_ALL             = REPLAY_MODE_IMAGEOPS
};

                                                                  
extern VOID PIN_LockClient();

                                                                  
extern VOID PIN_UnlockClient();

                                                                  
extern VOID PIN_WriteErrorMessage( const char * msg, INT32 type, PIN_ERR_SEVERITY_TYPE severity, INT32 num, ... );

                                                                  
extern AFUNPTR RTN_Replace(RTN replacedRtn, AFUNPTR replacementFun);

                                                                  
extern AFUNPTR RTN_ReplaceSignature(RTN replacedRtn, AFUNPTR replacementFun, ...);

                                                                  
enum PROBE_MODE
{
    PROBE_MODE_DEFAULT = 0,
    PROBE_MODE_ALLOW_RELOCATION = (1<<0)
};

                                                                  
extern AFUNPTR RTN_ReplaceProbed(RTN replacedRtn, AFUNPTR replacementFun);

                                                                  
extern AFUNPTR RTN_ReplaceProbedEx(RTN replacedRtn, PROBE_MODE mode,
                                 AFUNPTR replacementFun);

                                                                  
extern VOID PIN_CallApplicationFunction(const CONTEXT * ctxt, THREADID tid, CALLINGSTD_TYPE cstype,
    AFUNPTR origFunPtr, CALL_APPLICATION_FUNCTION_PARAM* param, ... );

                                                                  
extern BOOL INS_IsAddedForFunctionReplacement(INS ins);

                                                                  


extern __declspec(deprecated) VOID PIN_RegisterItcAuxCallBackPushFun(AFUNPTR callBackPushFun);

                                                                  


extern __declspec(deprecated) VOID RTN_ComplexReplaceWithUninstrumentedRoutine(RTN replacedRtn, AFUNPTR replacementFun);

                                                                  


extern __declspec(deprecated) ADDRINT PIN_FindAlternateAppStack();

                                                                  
extern VOID CALLBACK_SetExecutionPriority(PIN_CALLBACK callback, INT32 priority);

                                                                  
extern INT32 CALLBACK_GetExecutionPriority(PIN_CALLBACK callback);

                                                                  
extern PIN_CALLBACK TRACE_AddInstrumentFunction(TRACE_INSTRUMENT_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK INS_AddInstrumentFunction(INS_INSTRUMENT_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddFiniFunction(FINI_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddPrepareForFiniFunction(PREPARE_FOR_FINI_CALLBACK fun, VOID *val);

                                                                  
extern VOID PIN_AddFetchFunction(FETCH_CALLBACK fun, VOID *val);

                                                                  
extern size_t PIN_FetchCode(void *copyBuf, const VOID *address, size_t maxSize,
                               EXCEPTION_INFO *pExceptInfo);

                                                                  
extern VOID PIN_AddOutOfMemoryFunction(OUT_OF_MEMORY_CALLBACK fun, VOID *val);

                                                                  
extern VOID PIN_AddMemoryAddressTransFunction(MEMORY_ADDR_TRANS_CALLBACK fun, VOID *val);

                                                                  
extern VOID TRACE_AddSmcDetectedFunction(SMC_CALLBACK fun, VOID *val);

                                                                  
extern MEMORY_ADDR_TRANS_CALLBACK PIN_GetMemoryAddressTransFunction();

                                                                  
extern PIN_CALLBACK PIN_AddDetachFunction(DETACH_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddDetachFunctionProbed(DETACH_PROBED_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddThreadStartFunction(THREAD_START_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddThreadAttachProbedFunction(THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddThreadAttachFunction(THREAD_ATTACH_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddThreadDetachProbedFunction(
        THREAD_DETACH_PROBED_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddThreadDetachFunction(THREAD_DETACH_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddApplicationStartFunction(APPLICATION_START_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddThreadFiniFunction(THREAD_FINI_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddContextChangeFunction(CONTEXT_CHANGE_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddSyscallEntryFunction(SYSCALL_ENTRY_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK PIN_AddSyscallExitFunction(SYSCALL_EXIT_CALLBACK fun, VOID *val);

                                                                  
extern BOOL PIN_InterceptSignal(INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val);

                                                                  
extern BOOL PIN_UnblockSignal(INT32 sig, BOOL enable);

                                                                  
typedef enum
{
    SMC_ENABLE,
    SMC_DISABLE
} SMC_ENABLE_DISABLE_TYPE;

                                                                  
extern VOID PIN_SetSmcSupport(SMC_ENABLE_DISABLE_TYPE enable_disable);

                                                                  
extern PIN_CALLBACK PIN_AddProbesInsertedFunction( PROBES_INSERTED_CALLBACK fun, VOID *val );

                                                                  
enum FPOINT
{
    FPOINT_BEFORE,          
    FPOINT_AFTER_IN_PARENT, 
    FPOINT_AFTER_IN_CHILD   
};

                                                                  
extern PIN_CALLBACK PIN_AddForkFunction(FPOINT point, FORK_CALLBACK fun, VOID *val);

                                                                  
extern VOID PIN_RemoveInstrumentation();

                                                                  
extern VOID PIN_RemoveInstrumentationInRange(ADDRINT start, ADDRINT end);

                                                                  
extern VOID PIN_RemoveFiniFunctions();

                                                                  
extern VOID PIN_Detach();

                                                                  
enum ATTACH_STATUS
{
    ATTACH_INITIATED,       
    ATTACH_FAILED_DETACH    
                            
};

                                                                  
extern ATTACH_STATUS PIN_Attach(ATTACH_CALLBACK fun, VOID *val);

                                                                  
extern VOID PIN_DetachProbed();

                                                                  
extern ATTACH_STATUS PIN_AttachProbed(ATTACH_PROBED_CALLBACK fun, VOID *val);

                                                                  
extern VOID INS_InsertPredicatedCall(INS ins, IPOINT ipoint, AFUNPTR funptr, ...);

                                                                  
extern VOID INS_InsertCall(INS ins, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID INS_InsertIfCall(INS ins, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID INS_InsertThenCall(INS ins, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID INS_InsertIfPredicatedCall(INS ins, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID INS_InsertThenPredicatedCall(INS ins, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern PIN_CONFIGURATION_INFO PIN_CreateDefaultConfigurationInfo();

                                                                  
extern VOID PIN_SetAllowedConcurrentCallbacks(PIN_CONFIGURATION_INFO options, PIN_CALLBACK_TYPE callbackType);

                                                                  
extern VOID PIN_StartProgram(PIN_CONFIGURATION_INFO options=PIN_CreateDefaultConfigurationInfo());

                                                                  
extern VOID PIN_StartProgram(PIN_CONFIGURATION_INFO options);

                                                                  
extern VOID PIN_StartProgramProbed();

                                                                  
extern MESSAGE_TYPE MessageTypeLogProbe;

                                                                  
extern MESSAGE_TYPE MessageTypeLogBuffer;

                                                                  
extern MESSAGE_TYPE MessageTypeLogUnwind;

                                                                  
extern MESSAGE_TYPE MessageTypeLogFetchRtnIns;

                                                                  


extern __declspec(deprecated) BOOL ParseCommandLine(int xargc, CHAR **xargv);

                                                                  
extern BOOL PIN_Init(INT32 argc, CHAR ** argv);

                                                                  
extern VOID PIN_SetReplayMode(UINT32 flags);

                                                                  
extern VOID TRACE_InsertCall(TRACE trace, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID TRACE_InsertIfCall(TRACE trace, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID TRACE_InsertThenCall(TRACE trace, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern BBL TRACE_BblHead(TRACE trace);

                                                                  
extern BBL TRACE_BblTail(TRACE trace);

                                                                  
extern ADDRINT TRACE_Address(TRACE trace);

                                                                  
extern USIZE TRACE_Size(TRACE trace);

                                                                  
extern RTN TRACE_Rtn(TRACE trace);

                                                                  
extern BOOL TRACE_HasFallThrough(TRACE trace);

                                                                  
extern UINT32 TRACE_NumBbl(TRACE trace);

                                                                  
extern UINT32 TRACE_NumIns(TRACE trace);

                                                                  
extern VOID BBL_InsertCall(BBL bbl, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID BBL_InsertIfCall(BBL bbl, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern VOID BBL_InsertThenCall(BBL bbl, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern BOOL BBL_HasFallThrough(BBL bbl);

                                                                  
extern BOOL PIN_SupportsProcessorState(PROCESSOR_STATE state);

                                                                  
extern BOOL PIN_ContextContainsState(CONTEXT * ctxt, PROCESSOR_STATE state);

                                                                  
extern VOID PIN_SetContextRegval(CONTEXT * ctxt, REG reg, const UINT8 * val);

                                                                  
extern VOID PIN_GetContextRegval(const CONTEXT * ctxt, REG reg, UINT8 * val);

                                                                  
extern VOID PIN_SetContextReg(CONTEXT * ctxt, REG reg, ADDRINT val);

                                                                  
extern ADDRINT PIN_GetContextReg(const CONTEXT * ctxt, REG reg);

                                                                  
extern VOID PIN_SetContextFPState(CONTEXT * ctxt, const FPSTATE * fpstate);

                                                                  
extern VOID PIN_GetContextFPState(const CONTEXT * ctxt, FPSTATE * fpstate);

                                                                  
extern REGSET PIN_GetFullContextRegsSet();

                                                                  
extern VOID PIN_SaveContext(const CONTEXT * ctxtFrom, CONTEXT * ctxtTo);

                                                                  
extern VOID PIN_ExecuteAt(const CONTEXT * ctxt);

                                                                  
extern VOID PIN_SetSyscallArgument(CONTEXT *ctxt, SYSCALL_STANDARD std, UINT32 argNum, ADDRINT val);

                                                                  
extern ADDRINT PIN_GetSyscallArgument(const CONTEXT *ctxt, SYSCALL_STANDARD std, UINT32 argNum);

                                                                  
extern VOID PIN_SetSyscallNumber(CONTEXT *ctxt, SYSCALL_STANDARD std, ADDRINT val);

                                                                  
extern ADDRINT PIN_GetSyscallNumber(const CONTEXT *ctxt, SYSCALL_STANDARD std);

                                                                  
extern ADDRINT PIN_GetSyscallReturn(const CONTEXT *ctxt, SYSCALL_STANDARD std);

                                                                  
extern ADDRINT PIN_GetSyscallErrno(const CONTEXT *ctxt, SYSCALL_STANDARD std);

                                                                  
extern VOID PIN_SetPhysicalContextReg(PHYSICAL_CONTEXT * pPhysCtxt, REG reg, ADDRINT val);

                                                                  
extern ADDRINT PIN_GetPhysicalContextReg(const PHYSICAL_CONTEXT * pPhysCtxt, REG reg);

                                                                  
extern VOID PIN_SetPhysicalContextFPState(PHYSICAL_CONTEXT * pPhysCtxt, const VOID * fpstate);

                                                                  
extern VOID PIN_GetPhysicalContextFPState(const PHYSICAL_CONTEXT * pPhysCtxt, VOID * fpstate);

                                                                  
extern VOID PIN_RaiseException(const CONTEXT * ctxt, THREADID tid, const EXCEPTION_INFO * pExceptInfo);

                                                                  
extern BOOL PIN_SpawnApplicationThread(const CONTEXT * ctxt);

                                                                  




extern __declspec(deprecated) BOOL INS_ChangeMemOpToBaseRegisterAddressMode(INS ins, MEMORY_TYPE mtype, REG newBase);

                                                                  




extern __declspec(deprecated)  BOOL INS_RewriteMemoryAddressingToBaseRegisterOnly(INS ins,
                                                                                MEMORY_TYPE mtype,
                                                                                REG newBase);

                                                                  
extern VOID INS_RewriteMemoryOperand(INS ins,
                                        UINT32 memindex,
                                        REG reg);

                                                                  
extern VOID INS_InsertIndirectJump(INS ins, IPOINT ipoint, REG reg);

                                                                  
extern VOID INS_InsertDirectJump(INS ins, IPOINT ipoint, ADDRINT tgt);

                                                                  
extern REG PIN_ClaimToolRegister();

                                                                  
extern CHAR * PIN_VmFullPath();

                                                                  
extern const CHAR * PIN_ToolFullPath();

                                                                  
extern __declspec(noreturn) VOID PIN_ExitProcess(INT32 exitCode);

                                                                  
extern INT PIN_GetPid();

                                                                  
extern VOID INS_Delete(INS ins);

                                                                  
extern VOID IARGLIST_AddArguments(IARGLIST args,  ...);

                                                                  
extern IARGLIST IARGLIST_Alloc();

                                                                  
extern VOID IARGLIST_Free(IARGLIST args);

                                                                  
extern size_t PIN_SafeCopy(VOID * dst, const VOID * src, size_t size);

                                                                  
extern size_t PIN_SafeCopyEx(VOID * dst,
                                const VOID * src,
                                size_t size,
                                EXCEPTION_INFO * pExceptInfo);

                                                                  
extern VOID INS_InsertFillBuffer(INS ins, IPOINT action, BUFFER_ID id, ...);

                                                                  
extern VOID INS_InsertFillBufferPredicated(INS ins, IPOINT action, BUFFER_ID id, ...);

                                                                  
extern VOID INS_InsertFillBufferThen(INS ins, IPOINT action, BUFFER_ID id, ...);

                                                                  
extern BUFFER_ID PIN_DefineTraceBuffer(size_t recordSize, UINT32 numPages, TRACE_BUFFER_CALLBACK fun, VOID *val);

                                                                  
extern VOID *PIN_AllocateBuffer(BUFFER_ID id);

                                                                  
extern VOID PIN_DeallocateBuffer(BUFFER_ID id, VOID *buf);

                                                                  
extern BOOL PIN_IsActionPending(THREADID tid);

                                                                  
extern UINT32 PIN_GetInitialThreadCount();

                                                                  
extern VOID * PIN_GetBufferPointer(CONTEXT * const ctxt, BUFFER_ID id);

                                                                  
extern BOOL PIN_CheckReadAccess(VOID * addr);

                                                                  
extern BOOL PIN_CheckWriteAccess(VOID * addr);

                                                                  
extern ADDRINT PIN_GetAuxVectorValue(ADDRINT type, bool *found);

                                                                  


#line 54 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\versions_client.PH"






extern VOID BBL_SetTargetVersion(BBL bbl, ADDRINT version);

                                                                  
extern ADDRINT TRACE_Version(TRACE trace);

                                                                  
extern VOID INS_InsertVersionCase(INS ins, REG reg, INT32 case_value, ADDRINT version, ...);

                                                                  

#line 55 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\pin_client_replay.PH"






enum REPLAY_IMAGE_TYPE {
    REPLAY_IMAGE_TYPE_REGULAR     = 0,  
    REPLAY_IMAGE_TYPE_MAIN_EXE    = 1,  
    REPLAY_IMAGE_TYPE_INTERPRETER = 2   
};

                                                                  
extern VOID PIN_ReplaySyscallEntry(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std);

                                                                  
extern VOID PIN_ReplaySyscallExit(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std);

                                                                  
extern __declspec(noreturn) VOID PIN_ExitApplication(INT32 status);

                                                                  
extern VOID PIN_ReplayContextChange(THREADID tid, const CONTEXT *from, CONTEXT *to, CONTEXT_CHANGE_REASON reason, INT32 info);

                                                                  
extern IMG PIN_ReplayImageLoad(const char *imageName, const char * fileName, ADDRINT loadOffset, REPLAY_IMAGE_TYPE imageType);

                                                                  
extern VOID PIN_ReplayImageUnload(IMG img);

                                                                  
extern BOOL PIN_WasMemoryReservedInLoadTime();

                                                                  

#line 56 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\thread_client.PH"






extern OS_THREAD_ID PIN_GetTid();

                                                                  
extern THREADID PIN_ThreadId();

                                                                  
extern PIN_THREAD_UID PIN_ThreadUid();

                                                                  
extern OS_THREAD_ID PIN_GetParentTid();

                                                                  
extern VOID PIN_Sleep(UINT32 milliseconds);

                                                                  
extern VOID PIN_Yield();

                                                                  
extern THREADID PIN_SpawnInternalThread(ROOT_THREAD_FUNC * pThreadFunc,
                                           VOID * arg,
                                           size_t stackSize,
                                           PIN_THREAD_UID * pThreadUid);

                                                                  
extern VOID PIN_ExitThread(INT32 exitCode);

                                                                  
extern BOOL PIN_IsApplicationThread();

                                                                  
extern BOOL PIN_WaitForThreadTermination(const PIN_THREAD_UID & threadUid,
                                            UINT32 milliseconds,
                                            INT32 * pExitCode);

                                                                  

#line 57 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\debugger_client.PH"






typedef BOOL (*DEBUG_INTERPRETER_CALLBACK)(THREADID threadIndex, CONTEXT *ctxt, const std::string &cmd,
    std::string *reply, VOID *v);

                                                                  
typedef BOOL (*DEBUG_BREAKPOINT_CALLBACK)(ADDRINT addr, UINT size, BOOL insert, VOID *v);

                                                                  
typedef BOOL (*INTERCEPT_DEBUGGING_EVENT_CALLBACK)(THREADID tid, DEBUGGING_EVENT eventType,
    CONTEXT *ctxt, VOID *arg);

                                                                  
typedef VOID (*GET_EMULATED_REGISTER_CALLBACK)(unsigned toolRegId, THREADID tid, CONTEXT *ctxt,
    VOID *data, VOID *v);

                                                                  
typedef VOID (*SET_EMULATED_REGISTER_CALLBACK)(unsigned toolRegId, THREADID tid, CONTEXT *ctxt,
    const VOID *data, VOID *v);

                                                                  
typedef USIZE (*GET_TARGET_DESCRIPTION_CALLBACK)(const std::string &name, USIZE size, VOID *buf,
    VOID *v);

                                                                  
extern PIN_CALLBACK PIN_AddDebugInterpreter(DEBUG_INTERPRETER_CALLBACK fun, VOID *val);

                                                                  
extern VOID PIN_RemoveDebugInterpreter(DEBUG_INTERPRETER_CALLBACK fun);

                                                                  
extern PIN_CALLBACK PIN_AddBreakpointHandler(DEBUG_BREAKPOINT_CALLBACK fun, VOID *val);

                                                                  
extern VOID PIN_RemoveBreakpointHandler(DEBUG_BREAKPOINT_CALLBACK fun);

                                                                  
extern VOID PIN_ResetBreakpointAt(ADDRINT addr);

                                                                  
extern VOID PIN_ApplicationBreakpoint(const CONTEXT *ctxt, THREADID tid, BOOL waitIfNoDebugger,
    const std::string &msg);

                                                                  
extern BOOL PIN_SetDebugMode(const DEBUG_MODE *mode);

                                                                  
extern DEBUG_STATUS PIN_GetDebugStatus();

                                                                  
extern BOOL PIN_GetDebugConnectionInfo(DEBUG_CONNECTION_INFO *info);

                                                                  
extern DEBUGGER_TYPE PIN_GetDebuggerType();

                                                                  
extern BOOL PIN_WaitForDebuggerToConnect(unsigned timeout);

                                                                  
extern BOOL PIN_GetStoppedThreadPendingToolBreakpoint(THREADID tid, std::string *msg);

                                                                  
extern BOOL PIN_ChangePendingToolBreakpointOnStoppedThread(THREADID tid, BOOL squash,
    const std::string &msg);

                                                                  
extern VOID PIN_InterceptDebuggingEvent(DEBUGGING_EVENT eventType,
    INTERCEPT_DEBUGGING_EVENT_CALLBACK fun, VOID *arg);

                                                                  
extern VOID PIN_AddDebuggerRegisterEmulator(unsigned numRegisters,
    const DEBUGGER_REG_DESCRIPTION *registerDescriptions,
    GET_EMULATED_REGISTER_CALLBACK getFun,
    SET_EMULATED_REGISTER_CALLBACK setFun,
    GET_TARGET_DESCRIPTION_CALLBACK getDescriptionFun,
    VOID *val);

                                                                  

#line 58 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\stopped_thread_client.PH"






extern BOOL PIN_StopApplicationThreads(THREADID tid);

                                                                  
extern BOOL PIN_IsThreadStoppedInDebugger(THREADID tid);

                                                                  
extern VOID PIN_ResumeApplicationThreads(THREADID tid);

                                                                  
extern UINT32 PIN_GetStoppedThreadCount();

                                                                  
extern THREADID PIN_GetStoppedThreadId(UINT32 i);

                                                                  
extern const CONTEXT *PIN_GetStoppedThreadContext(THREADID tid);

                                                                  
extern CONTEXT *PIN_GetStoppedThreadWriteableContext(THREADID tid);

                                                                  

#line 59 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\deprecated_client.PH"






typedef VOID (*SIGNAL_BEFORE_CALLBACK)(THREADID threadIndex, INT32 sig, const CONTEXT *ctxtFrom,
    const CONTEXT *ctxtTo, VOID *v);

                                                                  
typedef VOID (*SIGNAL_AFTER_CALLBACK)(THREADID threadIndex, const CONTEXT *ctxtFrom,
    const CONTEXT *ctxtTo, VOID *v);

                                                                  
typedef VOID (*THREAD_BEGIN_CALLBACK)(THREADID threadIndex, VOID * sp, int flags, VOID *v);

                                                                  
typedef VOID (*THREAD_END_CALLBACK)(THREADID threadIndex, INT32 code, VOID *v);

                                                                  
typedef BOOL (*SIGNAL_INTERCEPT_CALLBACK)(THREADID threadIndex, INT32 sig,
 CONTEXT *ctxt, BOOL hasHndlr, VOID *v);

                                                                  



extern __declspec(deprecated) BOOL PIN_AddSignalBeforeFunction(SIGNAL_BEFORE_CALLBACK fun, VOID *val);

                                                                  



extern __declspec(deprecated) BOOL PIN_AddSignalAfterFunction(SIGNAL_AFTER_CALLBACK fun, VOID *val);

                                                                  




extern __declspec(deprecated) BOOL PIN_AddSignalInterceptFunction(INT32 sig, SIGNAL_INTERCEPT_CALLBACK fun,
    VOID *val);

                                                                  



extern __declspec(deprecated) VOID PIN_AddThreadBeginFunction(THREAD_BEGIN_CALLBACK fun, VOID *val);

                                                                  



extern __declspec(deprecated) VOID PIN_AddThreadEndFunction(THREAD_END_CALLBACK fun, VOID *val);

                                                                  



extern __declspec(deprecated) VOID PIN_StartProbedProgram();

                                                                  



extern __declspec(deprecated) BOOL RTN_IsSafeForProbe(RTN rtn);

                                                                  




extern __declspec(deprecated) VOID RTN_ReplaceWithUninstrumentedRoutine(RTN replacedRtn, AFUNPTR replacementFun);

                                                                  



extern __declspec(deprecated) BOOL CODECACHE_FlushCache();

                                                                  



extern __declspec(deprecated) UINT32 CODECACHE_InvalidateTraceAtProgramAddress(ADDRINT app_pc);

                                                                  



extern __declspec(deprecated) UINT32 CODECACHE_InvalidateRange(ADDRINT start, ADDRINT end);

                                                                  



extern __declspec(deprecated) BOOL TRACE_Original(TRACE trace);

                                                                  

#line 60 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\opin_client.PH"






typedef VOID (*TRACEGENCODE_CALLBACK)(TRACE trace, VOID *v);

                                                                  
extern BOOL PIN_IsProbeMode();

                                                                  
extern BOOL PIN_IsAttaching();

                                                                  
extern BOOL RTN_IsSafeForProbedInsertion(RTN rtn);

                                                                  
extern BOOL RTN_IsSafeForProbedInsertionEx(RTN rtn, PROBE_MODE mode);

                                                                  
extern BOOL RTN_IsSafeForProbedReplacement(RTN rtn);

                                                                  
extern BOOL RTN_IsSafeForProbedReplacementEx(RTN rtn, PROBE_MODE mode);

                                                                  
extern AFUNPTR RTN_ReplaceSignatureProbed(RTN replacedRtn, AFUNPTR replacementFun, ...);

                                                                  
extern AFUNPTR RTN_ReplaceSignatureProbedEx(RTN replacedRtn, PROBE_MODE mode,
                                               AFUNPTR replacementFun, ...);

                                                                  
extern VOID RTN_InsertCallProbed( RTN orgRtn, IPOINT action, AFUNPTR funptr, ... );

                                                                  
extern VOID RTN_InsertCallProbedEx( RTN orgRtn, IPOINT action,
                                      PROBE_MODE mode,
                                      AFUNPTR funptr, ... );

                                                                  
extern BOOL PIN_IsSafeForProbedInsertion(ADDRINT addr);

                                                                  
extern VOID PIN_InsertCallProbed(ADDRINT addr, AFUNPTR funptr, ...);

                                                                  
extern INT32 RTN_CodeRangesProbed( RTN rtn, INT32 num, PIN_CODE_RANGE * buffer );

                                                                  
extern PROTO PROTO_Allocate( PARG_T returnArg,
                                CALLINGSTD_TYPE cstype, const char * name, ... );

                                                                  
extern VOID PROTO_Free( PROTO proto );

                                                                  

#line 61 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\tls_client.PH"






enum
{
    
    TLS_KEY_INTERNAL_EXCEPTION,

    TLS_KEY_CLIENT_FIRST,
    
    
    TLS_KEY_CLIENT_LAST = TLS_KEY_CLIENT_FIRST + 63
};

                                                                  
const UINT32 MAX_CLIENT_TLS_KEYS = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1);

                                                                  
class CLIENT_TLS
{
  public:

    



    TLS_KEY AllocateKey(DESTRUCTFUN destructFun = 0);

    



    BOOL FreeKey(TLS_KEY tlsKey);

    



    BOOL IsKeyAllocated(TLS_KEY tlsKey);

    














    static VOID * GetData(TLS_KEY tlsKey, THREADID threadId)
    {
        return (*(m_pSlots[threadId]))[tlsKey];
    }

    



    static BOOL SetData(TLS_KEY tlsKey, const VOID *  value, THREADID threadId)
    {
        (*(m_pSlots[threadId]))[tlsKey] = const_cast<VOID *>(value);
        return 1;
    }

    





    VOID InitCurrentTls(THREADID currentThreadId);

    





    VOID DestructThreadTls(THREADID threadId);

    



    BOOL IsCurrentTlsAllocated(THREADID currentThreadId);

    





    static BOOL IsValidTlsKey(TLS_KEY tlsKey, THREADID threadId)
    {
        return m_pSlots[threadId]->IsValidKey(tlsKey) && CLIENT_TLS::Instance()->IsKeyAllocated(tlsKey);
    }

    


    static CLIENT_TLS * Instance();

  private:
    


    typedef TLS_ARRAY<0, TLS_KEY_CLIENT_LAST> SLOTS;

  private:
    
    CLIENT_TLS() {}
    friend class DUMMY_GCC32; 
                              
    
    CLIENT_TLS(const CLIENT_TLS &);
    CLIENT_TLS & operator = (const CLIENT_TLS &);

    static SLOTS * m_pSlots[PIN_MAX_THREADS];

    



    static CLIENT_TLS * m_pInstance;

};

                                                                  
inline TLS_KEY PIN_CreateThreadDataKey(DESTRUCTFUN destruct_func)
{
    return CLIENT_TLS::Instance()->AllocateKey(destruct_func);
}

                                                                  
inline BOOL PIN_DeleteThreadDataKey(TLS_KEY key)
{
    if (CLIENT_TLS::Instance()->IsKeyAllocated(key))
        return CLIENT_TLS::Instance()->FreeKey(key);
    else
        return 0;
}

                                                                  




inline BOOL PIN_SetThreadData( TLS_KEY key, const VOID * data )
{
    do{ if(!(0)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\tls_client.PH",   __FUNCTION__   , 160, std::string("") + "This version of PIN_SetThreadData is now deprecated. Please use the version of this function which " "takes a THREADID argument."),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
#line 161 "C:\\Pin35\\source\\include\\pin\\gen\\tls_client.PH"
    return 0;
}

                                                                  
inline BOOL PIN_SetThreadData( TLS_KEY key, const VOID * data , THREADID threadId)
{
    if (CLIENT_TLS::IsValidTlsKey(key, threadId))
        return CLIENT_TLS::SetData( key, data, threadId );
    else
        return 0;
}

                                                                  




inline VOID * PIN_GetThreadData( TLS_KEY key )
{
    do{ if(!(0)) do{ if(LEVEL_BASE::MessageTypeAssert.on()) LEVEL_BASE::MessageTypeAssert.MessageNoReturn(LEVEL_BASE::AssertString("C:\\Pin35\\source\\include\\pin\\gen\\tls_client.PH",   __FUNCTION__   , 181, std::string("") + "This version of PIN_GetThreadData is now deprecated. Please use the version of this function which " "takes a THREADID argument."),1,PIN_ERR_ASSERT,0); }while(0);} while(0);
#line 182 "C:\\Pin35\\source\\include\\pin\\gen\\tls_client.PH"
    return 0;
}

                                                                  
inline VOID * PIN_GetThreadData( TLS_KEY key, THREADID threadId )
{
    if (CLIENT_TLS::IsValidTlsKey(key, threadId))
        return CLIENT_TLS::GetData( key, threadId );
    else
        return 0;
}

                                                                  

#line 62 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\child_process_client.PH"






typedef LEVEL_BASE::CHILD_PROCESS_CLASS * CHILD_PROCESS;

                                                                  
typedef BOOL (*FOLLOW_CHILD_PROCESS_CALLBACK)(CHILD_PROCESS childProcess, VOID * val);

                                                                  
extern PIN_CALLBACK PIN_AddFollowChildProcessFunction(FOLLOW_CHILD_PROCESS_CALLBACK fun, VOID * val);

                                                                  
extern OS_PROCESS_ID CHILD_PROCESS_GetId(CHILD_PROCESS childProcess);

                                                                  
extern VOID CHILD_PROCESS_GetCommandLine(CHILD_PROCESS childProcess,
                                            INT * pArgc, const CHAR * const ** pArgv);

                                                                  
extern VOID CHILD_PROCESS_SetPinCommandLine(CHILD_PROCESS childProcess,
                                     INT argc, const CHAR * const * argv);

                                                                  

#line 63 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\image.PH"






extern IMG IMG_Next(IMG img);

                                                                  
extern IMG IMG_Prev(IMG img);

                                                                  
extern IMG IMG_Invalid();

                                                                  
extern BOOL IMG_Valid(IMG img);

                                                                  
extern SEC IMG_SecHead(IMG img);

                                                                  
extern SEC IMG_SecTail(IMG img);

                                                                  
extern SYM IMG_RegsymHead(IMG img);

                                                                  
extern ADDRINT IMG_Entry(IMG img);

                                                                  
extern const string& IMG_Name(IMG img);

                                                                  
extern ADDRINT IMG_Gp(IMG img);

                                                                  
extern ADDRINT IMG_LoadOffset(IMG img);

                                                                  
extern ADDRINT IMG_LowAddress(IMG img);

                                                                  
extern ADDRINT IMG_HighAddress(IMG img);

                                                                  
extern  ADDRINT IMG_StartAddress(IMG img);

                                                                  
extern USIZE IMG_SizeMapped(IMG img);

                                                                  
extern IMG_TYPE IMG_Type(IMG img);

                                                                  
extern BOOL IMG_IsMainExecutable(IMG x);

                                                                  
extern BOOL IMG_IsInterpreter(IMG x);

                                                                  
extern BOOL IMG_IsStaticExecutable(IMG x);

                                                                  
extern BOOL IMG_IsVDSO(IMG img);

                                                                  
extern UINT32 IMG_NumRegions(IMG img);

                                                                  
extern ADDRINT IMG_RegionHighAddress(IMG img, UINT32 n);

                                                                  
extern ADDRINT IMG_RegionLowAddress(IMG img, UINT32 n);

                                                                  
extern IMG IMG_CreateAt(const char* filename, ADDRINT start, USIZE size, ADDRINT loadOffset, BOOL mainExecutable);

                                                                  
extern IMG SEC_Img(SEC sec);

                                                                  
extern SEC SEC_Next(SEC sec);

                                                                  
extern SEC SEC_Prev(SEC sec);

                                                                  
extern SEC SEC_Invalid();

                                                                  
extern BOOL SEC_Valid(SEC x);

                                                                  
extern RTN SEC_RtnHead(SEC sec);

                                                                  
extern RTN SEC_RtnTail(SEC sec);

                                                                  
extern const string& SEC_Name(SEC sec);

                                                                  
extern SEC_TYPE SEC_Type(SEC sec);

                                                                  
extern BOOL SEC_Mapped(SEC sec);

                                                                  
extern const VOID *SEC_Data(SEC sec);

                                                                  
extern SEC RTN_Sec(RTN x);

                                                                  
extern RTN RTN_Next(RTN x);

                                                                  
extern RTN RTN_Prev(RTN x);

                                                                  
extern RTN RTN_Invalid();

                                                                  
extern BOOL RTN_Valid(RTN x);

                                                                  



extern __declspec(deprecated) BBL RTN_BblHead(RTN x);

                                                                  



extern __declspec(deprecated) BBL RTN_BblTail(RTN x);

                                                                  
extern const string& RTN_Name(RTN x);

                                                                  
extern BOOL RTN_IsArtificial(RTN x);

                                                                  
extern SYM RTN_Sym(RTN x);

                                                                  
extern AFUNPTR RTN_Funptr(RTN x);

                                                                  
inline UINT32 RTN_Id(RTN x) { return x.q();}

                                                                  



inline __declspec(deprecated) INT32 RTN_No(RTN x) { return x.q();}

                                                                  
extern INS BBL_InsHead(BBL x);

                                                                  
extern INS BBL_InsTail(BBL x);

                                                                  
extern BBL BBL_Next(BBL x);

                                                                  
extern BBL BBL_Prev(BBL x);

                                                                  
extern BOOL BBL_Valid(BBL x);

                                                                  
extern RTN INS_Rtn(INS x);

                                                                  
extern INS INS_Next(INS x);

                                                                  
extern INS INS_Prev(INS x);

                                                                  
extern INS INS_Invalid();

                                                                  
extern BOOL INS_Valid(INS x);

                                                                  
extern ADDRINT INS_Address(INS ins);

                                                                  
extern USIZE INS_Size(INS ins);

                                                                  
extern ADDRINT INS_DirectBranchOrCallTargetAddress(INS ins);

                                                                  
extern ADDRINT INS_NextAddress(INS ins);

                                                                  
extern SYM SYM_Next(SYM x);

                                                                  
extern SYM SYM_Prev(SYM x);

                                                                  
extern const string& SYM_Name(SYM x);

                                                                  
extern SYM SYM_Invalid();

                                                                  
extern BOOL SYM_Valid(SYM x);

                                                                  
extern BOOL SYM_Dynamic(SYM x);

                                                                  
extern BOOL SYM_GeneratedByPin(SYM x);

                                                                  
extern BOOL SYM_IFuncImplementation(SYM x);

                                                                  
extern BOOL SYM_IFuncResolver(SYM x);

                                                                  
extern ADDRINT SYM_Value(SYM x);

                                                                  
extern UINT32 SYM_Index(SYM x);

                                                                  
extern ADDRINT SYM_Address(SYM x);

                                                                  
typedef VOID (*IMAGECALLBACK)(IMG, VOID *);

                                                                  
enum UNDECORATION {
    UNDECORATION_COMPLETE,  
    UNDECORATION_NAME_ONLY  
};

                                                                  
enum SYMBOL_INFO_MODE {
    NO_SYMBOLS     = 0,       
    EXPORT_SYMBOLS = (1<<0),  
    DEBUG_SYMBOLS  = (1<<1),  
    IFUNC_SYMBOLS  = (1<<2),  
    DEBUG_OR_EXPORT_SYMBOLS = (DEBUG_SYMBOLS | EXPORT_SYMBOLS) 
                                                               
};

                                                                  
class SymbolAddressRange
{
    public:
        SymbolAddressRange() : base(0), size(0), name("") {}
        SymbolAddressRange(string sym_name, ADDRINT sym_base, size_t sym_size) :
            base(sym_base), size(sym_size), name(sym_name) {}
        SymbolAddressRange(const SymbolAddressRange &obj) {base=obj.base; size=obj.size; name=obj.name;}
        void operator = (const SymbolAddressRange &obj) {base=obj.base; size=obj.size; name=obj.name;}
        BOOL operator < (const SymbolAddressRange &  range) const {return (base < range.base);}
        BOOL Contains(const ADDRINT addr) const { return ((addr-base)<size); }
    public:
        ADDRINT base;
        size_t size;
        string name;
};

                                                                  
struct SymbolDebugInfo
{
    SymbolDebugInfo(string sym_name, ADDRINT sym_base, size_t sym_size) :
        name(sym_name), range(sym_name, sym_base, sym_size) {}
    string name;
    SymbolAddressRange range;
};

                                                                  
extern UINT32 IMG_Id(IMG x);

                                                                  
extern IMG IMG_FindImgById(UINT32 id);

                                                                  
extern IMG IMG_FindByAddress(ADDRINT address);

                                                                  
extern PIN_CALLBACK RTN_AddInstrumentFunction(RTN_INSTRUMENT_CALLBACK fun, VOID *val);

                                                                  
extern PIN_CALLBACK IMG_AddInstrumentFunction(IMAGECALLBACK fun, VOID *v);

                                                                  
extern PIN_CALLBACK IMG_AddUnloadFunction(IMAGECALLBACK fun, VOID *v);

                                                                  
extern USIZE RTN_Range(RTN rtn);

                                                                  
extern USIZE RTN_Size(RTN rtn);

                                                                  
extern RTN RTN_IFuncResolver(RTN rtn);

                                                                  
extern RTN RTN_IFuncImplementation(RTN rtn);

                                                                  
extern IMG IMG_Open(const string& filename);

                                                                  
extern VOID IMG_Close(IMG img);

                                                                  
extern VOID IMG_ReplayImageLoad(IMG img);

                                                                  
extern VOID* IMG_GetLoaderInfo(IMG img);

                                                                  
extern VOID IMG_SetLoaderInfo(IMG img, VOID* loaderInfo);

                                                                  
extern string RTN_FindNameByAddress(ADDRINT address);

                                                                  
extern RTN RTN_FindByAddress(ADDRINT address);

                                                                  
extern RTN RTN_FindByName(IMG img, const CHAR * name);

                                                                  
extern VOID RTN_Open(RTN rtn);

                                                                  
extern VOID RTN_Close(RTN rtn);

                                                                  
extern INS RTN_InsHead(RTN rtn);

                                                                  
extern INS RTN_InsHeadOnly(RTN rtn);

                                                                  
extern INS RTN_InsTail(RTN rtn);

                                                                  
extern UINT32 RTN_NumIns(RTN rtn);

                                                                  
extern VOID RTN_InsertCall(RTN rtn, IPOINT action, AFUNPTR funptr, ...);

                                                                  
extern ADDRINT RTN_Address(RTN rtn);

                                                                  
extern RTN RTN_CreateAt(ADDRINT address, string name);

                                                                  
extern BOOL RTN_IsDynamic(RTN rtn);

                                                                  
extern ADDRINT SEC_Address(SEC sec);

                                                                  
extern BOOL SEC_IsReadable(SEC sec);

                                                                  
extern BOOL SEC_IsWriteable(SEC sec);

                                                                  
extern BOOL SEC_IsExecutable(SEC sec);

                                                                  
extern USIZE SEC_Size(SEC sec);

                                                                  
extern BOOL BBL_Original(BBL bbl);

                                                                  
extern ADDRINT BBL_Address(BBL bbl);

                                                                  
extern USIZE BBL_Size(BBL bbl);

                                                                  
extern IMG APP_ImgHead();

                                                                  
extern IMG APP_ImgTail();

                                                                  
extern string PIN_UndecorateSymbolName(const string & symbolName, UNDECORATION style);

                                                                  

#line 64 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\debug.PH"






extern void PIN_GetSourceLocation(ADDRINT address, INT32 * column, INT32 * line, string * fileName);

                                                                  

#line 65 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\internal_exception_client.PH"






const UINT32 MAX_IEH_CALLBACKS = 32;

                                                                  
typedef EXCEPT_HANDLING_RESULT (*INTERNAL_EXCEPTION_CALLBACK)(THREADID tid, 
                   EXCEPTION_INFO * pExceptInfo, PHYSICAL_CONTEXT * pPhysCtxt, VOID * v);

                                                                  
extern PIN_CALLBACK PIN_AddInternalExceptionHandler(INTERNAL_EXCEPTION_CALLBACK fun, VOID *val);

                                                                  
extern VOID PIN_TryStart(THREADID tid, INTERNAL_EXCEPTION_CALLBACK fun, VOID * val);

                                                                  
extern VOID PIN_TryEnd(THREADID tid);

                                                                  

#line 66 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"






#line 73 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"





#line 79 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\os_info_client_windows.PH"






extern UINT32 PIN_GetWindowsSyscallFromKey(SYSCALL_KEY key);

                                                                  
extern SYSCALL_KEY PIN_GetKeyFromWindowsSyscall(UINT32 syscallNo);

                                                                  

#line 80 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\image_win.PH"







#line 81 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\symbol_win.PH"






extern VOID PIN_InitSymbols();

                                                                  
extern BOOL PIN_InitSymbolsAlt(SYMBOL_INFO_MODE mode);

                                                                  

#line 82 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 1 "C:\\Pin35\\source\\include\\pin\\gen\\debug_win.PH"









extern __declspec(deprecated) VOID PIN_FindLineFileByAddress(ADDRINT address, INT32 * line, const CHAR ** file);

                                                                  



extern __declspec(deprecated) VOID PIN_FindColumnLineFileByAddress(ADDRINT address,
                                               INT32 * column, INT32 * line, const CHAR ** file);

                                                                  

#line 83 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"






#line 90 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"

}

#line 94 "c:\\pin35\\source\\include\\pin\\level_pinclient.PLH"
#line 47 "C:\\Pin35\\source\\include\\pin\\pin.H"




using namespace LEVEL_PINCLIENT;

#line 54 "C:\\Pin35\\source\\include\\pin\\pin.H"

#line 2 "analyzer.cpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


#line 28 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"


#line 35 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/stdio.h"


























































































































































































































































































































































































































































































#line 36 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 37 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 41 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"





#line 47 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 51 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"



#line 55 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 56 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"

#line 58 "C:\\Pin35\\extras\\stlport\\include\\stdio.h"
#line 3 "analyzer.cpp"
#line 1 "C:\\Pin35\\extras\\stlport\\include\\string.h"

























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"























#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"



#pragma warning (push)
#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"











#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"













#line 28 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#line 32 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"



#pragma warning( disable : 4100 ) 
#pragma warning( disable : 4127 ) 
#pragma warning( disable : 4146 ) 
#pragma warning( disable : 4245 ) 
#pragma warning( disable : 4355 ) 
#pragma warning( disable : 4510 ) 
#pragma warning( disable : 4512 ) 
#pragma warning( disable : 4571 ) 
#pragma warning( disable : 4610 ) 







#line 52 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_warnings_off.h"
#line 6 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"




#pragma pack(push, 8)


#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"





























#line 44 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_prolog.h"
#line 25 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_cprolog.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 31 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 35 "C:\\Pin35\\extras\\stlport\\include\\string.h"






#line 42 "C:\\Pin35\\extras\\stlport\\include\\string.h"






#line 49 "C:\\Pin35\\extras\\stlport\\include\\string.h"


#line 52 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 1 "C:\\Pin35\\extras\\crt\\include/string.h"








































































































































































































































































































































#line 53 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 54 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 55 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 56 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"














#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"


#pragma warning (pop)
#pragma pack (pop)
























#line 30 "C:\\Pin35\\extras\\stlport\\include\\stl/config/_epilog.h"
#line 16 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 17 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 1 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"







#line 9 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 14 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"




#line 19 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"






#line 26 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"
#line 27 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"























#line 51 "C:\\Pin35\\extras\\stlport\\include\\stl/_config_compat_post.h"

#line 20 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"
#line 21 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"



















#line 41 "C:\\Pin35\\extras\\stlport\\include\\stl/_epilog.h"


#line 60 "C:\\Pin35\\extras\\stlport\\include\\string.h"



#line 64 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 65 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 66 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 67 "C:\\Pin35\\extras\\stlport\\include\\string.h"
#line 4 "analyzer.cpp"
#line 1 "c:\\users\\tulim\\works\\pincfgreconstructor\\icount\\types.h"
#pragma once

typedef struct trace_s {
	char* buf;
	size_t cursor;
} trace_t;











#line 5 "analyzer.cpp"

static TLS_KEY tls_key = INVALID_TLS_KEY;
PIN_LOCK pin_lock;


KNOB <BOOL> KnobIsBuffered(KNOB_MODE_WRITEONCE, "pintool",
	"buffered", "false", "whether or not the trace is buffered");
KNOB <size_t> KnobTraceLimit(KNOB_MODE_WRITEONCE, "pintool",
	"trace_limit", "0", "size of the trace limit");

static size_t spawned_threads_no;

bool isBuffered;
size_t trace_limit;

bool isFirstIns = true;
const char* prog_name;

short unsigned int hasDone = 0;

trace_t* traces[256];
FILE* files[256];
bool hasReachedTraceLimit[256];










void printAllRawTraces(FILE* f, trace_t* trace) {
	for (size_t i = 0; i < trace->cursor; i++) {
		fputc(trace->buf[i], f);
	}
}

void printRawTrace(FILE* f, const char* buf, size_t buf_len) {
	for (size_t i = 0; i < buf_len; i++) {
		fputc(buf[i], f);
	}
}

void INS_Analysis(char* buf, UINT32 buf_len, THREADID thread_idx) {
	trace_t* trace = (trace_t*)PIN_GetThreadData(tls_key, thread_idx);
	
	if (trace->cursor + buf_len >= trace_limit) {
		hasReachedTraceLimit[thread_idx] = true;
		return;
	}

	if (isBuffered)
		{ memcpy(trace->buf + trace->cursor, buf, buf_len); trace->cursor += buf_len; }
	else
		printRawTrace(files[thread_idx], buf, buf_len);
}

void INS_JumpAnalysis(ADDRINT target_branch, INT32 taken, THREADID thread_idx) {
	if (!taken) return;
	trace_t* trace = (trace_t*) PIN_GetThreadData(tls_key, thread_idx);
	




	size_t buf_len = (sizeof(ADDRINT) * 2 + 5);
	
	if (trace->cursor + buf_len >= trace_limit) {
		hasReachedTraceLimit[thread_idx] = true;
		return;
	}

	char* buf = (char*)calloc(1, sizeof(char) * buf_len);
	buf[0] = '\n';
	buf[1] = '@';
	sprintf(buf + 2, "%x", target_branch);
	if (isBuffered)
		{ memcpy(trace->buf + trace->cursor, buf, buf_len); trace->cursor += buf_len; }
	else
		printRawTrace(files[thread_idx], buf, buf_len);
}

void Ins(INS ins, void* v) {
	string disassembled_ins_s = INS_Disassemble(ins);
	




	uint32_t disassembled_ins_len = strlen(disassembled_ins_s.c_str()) + 2;
	char* disassembled_ins = (char*)malloc(sizeof(char) * (disassembled_ins_len));
	disassembled_ins[0] = '\n';
	disassembled_ins[disassembled_ins_len - 1] = '\0';
	strcpy(disassembled_ins + 1, disassembled_ins_s.c_str());
	if (isFirstIns) {
		isFirstIns = false;
		strcpy(disassembled_ins, disassembled_ins + 1);
	}

	INS_InsertCall(ins, IPOINT_BEFORE,
		(AFUNPTR)INS_Analysis,
		IARG_PTR,
		disassembled_ins,
		IARG_UINT32,
		disassembled_ins_len,
		IARG_THREAD_ID,
		IARG_FILE_NAME, "analyzer.cpp", IARG_LINE_NO, LEVEL_BASE::UINT32(113), IARG_LAST);


	if (INS_IsBranchOrCall(ins)) {
		INS_InsertCall(ins, IPOINT_BEFORE,
			(AFUNPTR)INS_JumpAnalysis,
			IARG_BRANCH_TARGET_ADDR,
			IARG_BRANCH_TAKEN,
			IARG_THREAD_ID,
			IARG_FILE_NAME, "analyzer.cpp", IARG_LINE_NO, LEVEL_BASE::UINT32(122), IARG_LAST);
	}
}

void ThreadStart(THREADID thread_idx, CONTEXT* ctx, INT32 flags, VOID* v) {
	fprintf((&__sF[1]), "[*] Spawned thread %d\n", thread_idx);
	fflush((&__sF[1]));

	PIN_GetLock(&pin_lock, thread_idx);
	
	char filename[128] = { 0 };
	sprintf(filename, "trace_%d.out", thread_idx);
	FILE* out = fopen(filename, "w+");
	fprintf((&__sF[1]), "[+] Created file %s\n", filename);
	fflush((&__sF[1]));

	
	trace_t* trace = (trace_t*)malloc(sizeof(trace_t*));
	trace->buf = (char*)malloc(sizeof(char) * trace_limit);
	trace->cursor = 0;
	files[thread_idx] = out;

	traces[thread_idx] = trace;
	if (PIN_SetThreadData(tls_key, trace, thread_idx) == 0) {
		fprintf((&__sF[2]), "[x] PIN_SetThreadData failed");
		PIN_ExitProcess(1);
	}
	spawned_threads_no++;
	PIN_ReleaseLock(&pin_lock);
}

void ThreadFini(THREADID thread_idx, const CONTEXT* ctx, INT32 code, VOID* v) {
	fprintf((&__sF[1]), "[*] Finished thread %d, trace limit reached: %d\n", thread_idx, hasReachedTraceLimit[thread_idx]);
	if (isBuffered)
		printAllRawTraces(files[thread_idx], (trace_t*) PIN_GetThreadData(tls_key, thread_idx));
	fprintf((&__sF[1]), "[*] Trace for thread #%d saved\n", thread_idx);
}

void Config() {
	isBuffered = KnobIsBuffered.Value();
	fprintf((&__sF[1]), "[*] Is Buffered? %d\n", isBuffered);

	trace_limit = KnobTraceLimit.Value() > 0 ? KnobTraceLimit.Value()*(1024*1024) : 128*(1024*1024);
	fprintf((&__sF[1]), "[*] Trace limit %dMb\n", trace_limit/(1024*1024));

}

void Usage() {
	fprintf((&__sF[2]), "--- PinCFGReconstructor ---\n");
}

void Fini(INT32 code, VOID *v) {
	fprintf((&__sF[1]), "=======================\n");
	fprintf((&__sF[1]), "Trace finished\n");
	
	fprintf((&__sF[1]), "Threads spawned: %d\n", spawned_threads_no);
	fprintf((&__sF[1]), "=======================\n");
}

int main(int argc, char *argv[]) {
	
	if (PIN_Init(argc, argv)) {
		fprintf((&__sF[2]), "[x] An error occured while initiating PIN\n");
		return 0;
	}

	
	Config();

	
	tls_key = PIN_CreateThreadDataKey(0);
	if (tls_key == INVALID_TLS_KEY) {
		fprintf((&__sF[2]), "[x] Number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit\n");
		PIN_ExitProcess(1);
	}

	
	PIN_InitLock(&pin_lock);

	prog_name = argv[argc - 1];
	INS_AddInstrumentFunction(Ins, 0);

	PIN_AddThreadStartFunction(ThreadStart, 0);
	PIN_AddThreadFiniFunction(ThreadFini, 0);

	PIN_AddFiniFunction(Fini, 0);
	PIN_StartProgram();
	return 0;
}
